{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "$ref": "#/definitions/Bootstrap",
    "$package": "envoy.config.bootstrap.v3",
    "definitions": {
        "Bootstrap": {
            "properties": {
                "node": {
                    "$ref": "#/definitions/envoy.config.core.v3.Node",
                    "additionalProperties": true,
                    "description": "Node identity to present to the management server and for instance identification purposes (e.g. in generated headers)."
                },
                "node_context_params": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "A list of :ref:`Node \u003cenvoy_v3_api_msg_config.core.v3.Node\u003e` field names that will be included in the context parameters of the effective xdstp:// URL that is sent in a discovery request when resource locators are used for LDS/CDS. Any non-string field will have its JSON encoding set as the context parameter value, with the exception of metadata, which will be flattened (see example below). The supported field names are: - \"cluster\" - \"id\" - \"locality.region\" - \"locality.sub_zone\" - \"locality.zone\" - \"metadata\" - \"user_agent_build_version.metadata\" - \"user_agent_build_version.version\" - \"user_agent_name\" - \"user_agent_version\" The node context parameters act as a base layer dictionary for the context parameters (i.e. more specific resource specific context parameters will override). Field names will be prefixed with “udpa.node.” when included in context parameters. For example, if node_context_params is ``[\"user_agent_name\", \"metadata\"]``, the implied context parameters might be::   node.user_agent_name: \"envoy\"   node.metadata.foo: \"{\\\"bar\\\": \\\"baz\\\"}\"   node.metadata.some: \"42\"   node.metadata.thing: \"\\\"thing\\\"\" [#not-implemented-hide:]"
                },
                "static_resources": {
                    "$ref": "#/definitions/envoy.config.bootstrap.v3.Bootstrap.StaticResources",
                    "additionalProperties": true,
                    "description": "Statically specified resources."
                },
                "dynamic_resources": {
                    "$ref": "#/definitions/envoy.config.bootstrap.v3.Bootstrap.DynamicResources",
                    "additionalProperties": true,
                    "description": "xDS configuration sources."
                },
                "cluster_manager": {
                    "$ref": "#/definitions/envoy.config.bootstrap.v3.ClusterManager",
                    "additionalProperties": true,
                    "description": "Configuration for the cluster manager which owns all upstream clusters within the server."
                },
                "hds_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.ApiConfigSource",
                    "additionalProperties": true,
                    "description": "Health discovery service config option. (:ref:`core.ApiConfigSource \u003cenvoy_v3_api_msg_config.core.v3.ApiConfigSource\u003e`)"
                },
                "flags_path": {
                    "type": "string",
                    "description": "Optional file system path to search for startup flag files."
                },
                "stats_sinks": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.metrics.v3.StatsSink"
                    },
                    "type": "array",
                    "description": "Optional set of stats sinks."
                },
                "deferred_stat_options": {
                    "$ref": "#/definitions/envoy.config.bootstrap.v3.Bootstrap.DeferredStatOptions",
                    "additionalProperties": true,
                    "description": "Options to control behaviors of deferred creation compatible stats."
                },
                "stats_config": {
                    "$ref": "#/definitions/envoy.config.metrics.v3.StatsConfig",
                    "additionalProperties": true,
                    "description": "Configuration for internal processing of stats."
                },
                "stats_flush_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Optional duration between flushes to configured stats sinks. For performance reasons Envoy latches counters and only flushes counters and gauges at a periodic interval. If not specified the default is 5000ms (5 seconds). Only one of ``stats_flush_interval`` or ``stats_flush_on_admin`` can be set. Duration must be at least 1ms and at most 5 min.",
                    "format": "regex"
                },
                "stats_flush_on_admin": {
                    "type": "boolean",
                    "description": "Flush stats to sinks only when queried for on the admin interface. If set, a flush timer is not created. Only one of ``stats_flush_on_admin`` or ``stats_flush_interval`` can be set."
                },
                "watchdog": {
                    "$ref": "#/definitions/envoy.config.bootstrap.v3.Watchdog",
                    "additionalProperties": true,
                    "description": "Optional watchdog configuration. This is for a single watchdog configuration for the entire system. Deprecated in favor of ``watchdogs`` which has finer granularity."
                },
                "watchdogs": {
                    "$ref": "#/definitions/envoy.config.bootstrap.v3.Watchdogs",
                    "additionalProperties": true,
                    "description": "Optional watchdogs configuration. This is used for specifying different watchdogs for the different subsystems. [#extension-category: envoy.guarddog_actions]"
                },
                "tracing": {
                    "$ref": "#/definitions/envoy.config.trace.v3.Tracing",
                    "additionalProperties": true,
                    "description": "Configuration for an external tracing provider. .. attention::  This field has been deprecated in favor of :ref:`HttpConnectionManager.Tracing.provider  \u003cenvoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.provider\u003e`."
                },
                "layered_runtime": {
                    "$ref": "#/definitions/envoy.config.bootstrap.v3.LayeredRuntime",
                    "additionalProperties": true,
                    "description": "Configuration for the runtime configuration provider. If not specified, a “null” provider will be used which will result in all defaults being used."
                },
                "admin": {
                    "$ref": "#/definitions/envoy.config.bootstrap.v3.Admin",
                    "additionalProperties": true,
                    "description": "Configuration for the local administration HTTP server."
                },
                "overload_manager": {
                    "$ref": "#/definitions/envoy.config.overload.v3.OverloadManager",
                    "additionalProperties": true,
                    "description": "Optional overload manager configuration."
                },
                "enable_dispatcher_stats": {
                    "type": "boolean",
                    "description": "Enable :ref:`stats for event dispatcher \u003coperations_performance\u003e`, defaults to false. Note that this records a value for each iteration of the event loop on every thread. This should normally be minimal overhead, but when using :ref:`statsd \u003cenvoy_v3_api_msg_config.metrics.v3.StatsdSink\u003e`, it will send each observed value over the wire individually because the statsd protocol doesn't have any way to represent a histogram summary. Be aware that this can be a very large volume of data."
                },
                "header_prefix": {
                    "type": "string",
                    "description": "Optional string which will be used in lieu of x-envoy in prefixing headers. For example, if this string is present and set to X-Foo, then x-envoy-retry-on will be transformed into x-foo-retry-on etc. Note this applies to the headers Envoy will generate, the headers Envoy will sanitize, and the headers Envoy will trust for core code and core extensions only. Be VERY careful making changes to this string, especially in multi-layer Envoy deployments or deployments using extensions which are not upstream."
                },
                "stats_server_version_override": {
                    "additionalProperties": true,
                    "type": "string",
                    "description": "Optional proxy version which will be used to set the value of :ref:`server.version statistic \u003cserver_statistics\u003e` if specified. Envoy will not process this value, it will be sent as is to :ref:`stats sinks \u003cenvoy_v3_api_msg_config.metrics.v3.StatsSink\u003e`."
                },
                "use_tcp_for_dns_lookups": {
                    "type": "boolean",
                    "description": "Always use TCP queries instead of UDP queries for DNS lookups. This may be overridden on a per-cluster basis in cds_config, when :ref:`dns_resolvers \u003cenvoy_v3_api_field_config.cluster.v3.Cluster.dns_resolvers\u003e` and :ref:`use_tcp_for_dns_lookups \u003cenvoy_v3_api_field_config.cluster.v3.Cluster.use_tcp_for_dns_lookups\u003e` are specified. This field is deprecated in favor of ``dns_resolution_config`` which aggregates all of the DNS resolver configuration in a single message."
                },
                "dns_resolution_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.DnsResolutionConfig",
                    "additionalProperties": true,
                    "description": "DNS resolution configuration which includes the underlying dns resolver addresses and options. This may be overridden on a per-cluster basis in cds_config, when :ref:`dns_resolution_config \u003cenvoy_v3_api_field_config.cluster.v3.Cluster.dns_resolution_config\u003e` is specified. This field is deprecated in favor of :ref:`typed_dns_resolver_config \u003cenvoy_v3_api_field_config.bootstrap.v3.Bootstrap.typed_dns_resolver_config\u003e`."
                },
                "typed_dns_resolver_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "DNS resolver type configuration extension. This extension can be used to configure c-ares, apple, or any other DNS resolver types and the related parameters. For example, an object of :ref:`CaresDnsResolverConfig \u003cenvoy_v3_api_msg_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig\u003e` can be packed into this ``typed_dns_resolver_config``. This configuration replaces the :ref:`dns_resolution_config \u003cenvoy_v3_api_field_config.bootstrap.v3.Bootstrap.dns_resolution_config\u003e` configuration. During the transition period when both ``dns_resolution_config`` and ``typed_dns_resolver_config`` exists, when ``typed_dns_resolver_config`` is in place, Envoy will use it and ignore ``dns_resolution_config``. When ``typed_dns_resolver_config`` is missing, the default behavior is in place. [#extension-category: envoy.network.dns_resolver]"
                },
                "bootstrap_extensions": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig"
                    },
                    "type": "array",
                    "description": "Specifies optional bootstrap extensions to be instantiated at startup time. Each item contains extension specific configuration. [#extension-category: envoy.bootstrap]"
                },
                "fatal_actions": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.bootstrap.v3.FatalAction"
                    },
                    "type": "array",
                    "description": "Specifies optional extensions instantiated at startup time and invoked during crash time on the request that caused the crash."
                },
                "config_sources": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.ConfigSource"
                    },
                    "type": "array",
                    "description": "Configuration sources that will participate in xdstp:// URL authority resolution. The algorithm is as follows: 1. The authority field is taken from the xdstp:// URL, call    this ``resource_authority``. 2. ``resource_authority`` is compared against the authorities in any peer    ``ConfigSource``. The peer ``ConfigSource`` is the configuration source    message which would have been used unconditionally for resolution    with opaque resource names. If there is a match with an authority, the    peer ``ConfigSource`` message is used. 3. ``resource_authority`` is compared sequentially with the authorities in    each configuration source in ``config_sources``. The first ``ConfigSource``    to match wins. 4. As a fallback, if no configuration source matches, then    ``default_config_source`` is used. 5. If ``default_config_source`` is not specified, resolution fails. [#not-implemented-hide:]"
                },
                "default_config_source": {
                    "$ref": "#/definitions/envoy.config.core.v3.ConfigSource",
                    "additionalProperties": true,
                    "description": "Default configuration source for xdstp:// URLs if all other resolution fails. [#not-implemented-hide:]"
                },
                "default_socket_interface": {
                    "type": "string",
                    "description": "Optional overriding of default socket interface. The value must be the name of one of the socket interface factories initialized through a bootstrap extension"
                },
                "certificate_provider_instances": {
                    "additionalProperties": {
                        "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                        "additionalProperties": true
                    },
                    "type": "object",
                    "description": "Global map of CertificateProvider instances. These instances are referred to by name in the :ref:`CommonTlsContext.CertificateProviderInstance.instance_name \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance.instance_name\u003e` field. [#not-implemented-hide:]"
                },
                "inline_headers": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.bootstrap.v3.CustomInlineHeader"
                    },
                    "type": "array",
                    "description": "Specifies a set of headers that need to be registered as inline header. This configuration allows users to customize the inline headers on-demand at Envoy startup without modifying Envoy's source code. Note that the 'set-cookie' header cannot be registered as inline header."
                },
                "perf_tracing_file_path": {
                    "type": "string",
                    "description": "Optional path to a file with performance tracing data created by \"Perfetto\" SDK in binary ProtoBuf format. The default value is \"envoy.pftrace\"."
                },
                "default_regex_engine": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Optional overriding of default regex engine. If the value is not specified, Google RE2 will be used by default. [#extension-category: envoy.regex_engines]"
                },
                "xds_delegate_extension": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Optional XdsResourcesDelegate configuration, which allows plugging custom logic into both fetch and load events during xDS processing. If a value is not specified, no XdsResourcesDelegate will be used. TODO(abeyad): Add public-facing documentation. [#not-implemented-hide:]"
                },
                "xds_config_tracker_extension": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Optional XdsConfigTracker configuration, which allows tracking xDS responses in external components, e.g., external tracer or monitor. It provides the process point when receive, ingest, or fail to process xDS resources and messages. If a value is not specified, no XdsConfigTracker will be used. .. note::    There are no in-repo extensions currently, and the :repo:`XdsConfigTracker \u003cenvoy/config/xds_config_tracker.h\u003e`    interface should be implemented before using.    See :repo:`xds_config_tracker_integration_test \u003ctest/integration/xds_config_tracker_integration_test.cc\u003e`    for an example usage of the interface."
                },
                "listener_manager": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "[#not-implemented-hide:] This controls the type of listener manager configured for Envoy. Currently Envoy only supports ListenerManager for this field and Envoy Mobile supports ApiListenerManager."
                },
                "application_log_config": {
                    "$ref": "#/definitions/envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig",
                    "additionalProperties": true,
                    "description": "Optional application log configuration."
                },
                "grpc_async_client_manager_config": {
                    "$ref": "#/definitions/envoy.config.bootstrap.v3.Bootstrap.GrpcAsyncClientManagerConfig",
                    "additionalProperties": true,
                    "description": "Optional gRPC async manager config."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Bootstrap]\n This proto is supplied via the :option:`-c` CLI flag and acts as the root\n of the Envoy v3 configuration. See the :ref:`v3 configuration overview\n \u003cconfig_overview_bootstrap\u003e` for more detail.",
            "description": "[#protodoc-title: Bootstrap] This proto is supplied via the :option:`-c` CLI flag and acts as the root of the Envoy v3 configuration. See the :ref:`v3 configuration overview \u003cconfig_overview_bootstrap\u003e` for more detail.  Bootstrap :ref:`configuration overview \u003cconfig_overview_bootstrap\u003e`. [#next-free-field: 41]"
        },
        "envoy.config.accesslog.v3.AccessLog": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the access log extension configuration."
                },
                "filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.AccessLogFilter",
                    "additionalProperties": true,
                    "description": "Filter which is used to determine if the access log needs to be written."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Common access log types]",
            "description": "[#protodoc-title: Common access log types]"
        },
        "envoy.config.accesslog.v3.AccessLogFilter": {
            "properties": {
                "status_code_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.StatusCodeFilter",
                    "additionalProperties": true,
                    "description": "Status code filter."
                },
                "duration_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.DurationFilter",
                    "additionalProperties": true,
                    "description": "Duration filter."
                },
                "not_health_check_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.NotHealthCheckFilter",
                    "additionalProperties": true,
                    "description": "Not health check filter."
                },
                "traceable_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.TraceableFilter",
                    "additionalProperties": true,
                    "description": "Traceable filter."
                },
                "runtime_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.RuntimeFilter",
                    "additionalProperties": true,
                    "description": "Runtime filter."
                },
                "and_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.AndFilter",
                    "additionalProperties": true,
                    "description": "And filter."
                },
                "or_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.OrFilter",
                    "additionalProperties": true,
                    "description": "Or filter."
                },
                "header_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.HeaderFilter",
                    "additionalProperties": true,
                    "description": "Header filter."
                },
                "response_flag_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.ResponseFlagFilter",
                    "additionalProperties": true,
                    "description": "Response flag filter."
                },
                "grpc_status_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.GrpcStatusFilter",
                    "additionalProperties": true,
                    "description": "gRPC status filter."
                },
                "extension_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.ExtensionFilter",
                    "additionalProperties": true,
                    "description": "Extension filter. [#extension-category: envoy.access_loggers.extension_filters]"
                },
                "metadata_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.MetadataFilter",
                    "additionalProperties": true,
                    "description": "Metadata Filter"
                },
                "log_type_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.LogTypeFilter",
                    "additionalProperties": true,
                    "description": "Log Type Filter"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Access Log Filter",
            "description": "[#next-free-field: 14]"
        },
        "envoy.config.accesslog.v3.AndFilter": {
            "properties": {
                "filters": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.accesslog.v3.AccessLogFilter"
                    },
                    "type": "array"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "And Filter",
            "description": "Performs a logical “and” operation on the result of each filter in filters. Filters are evaluated sequentially and if one of them returns false, the filter returns false immediately."
        },
        "envoy.config.accesslog.v3.ComparisonFilter": {
            "properties": {
                "op": {
                    "enum": [
                        "EQ",
                        0,
                        "GE",
                        1,
                        "LE",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Op"
                },
                "value": {
                    "$ref": "#/definitions/envoy.config.core.v3.RuntimeUInt32",
                    "additionalProperties": true,
                    "description": "Value to compare against."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Comparison Filter",
            "description": "Filter on an integer comparison."
        },
        "envoy.config.accesslog.v3.DurationFilter": {
            "properties": {
                "comparison": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.ComparisonFilter",
                    "additionalProperties": true,
                    "description": "Comparison."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Duration Filter",
            "description": "Filters based on the duration of the request or stream, in milliseconds. For end of stream access logs, the total duration of the stream will be used. For :ref:`periodic access logs\u003carch_overview_access_log_periodic\u003e`, the duration of the stream at the time of log recording will be used."
        },
        "envoy.config.accesslog.v3.ExtensionFilter": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the filter implementation to instantiate. The name must match a statically registered filter."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Extension Filter",
            "description": "Extension filter is statically registered at runtime."
        },
        "envoy.config.accesslog.v3.GrpcStatusFilter": {
            "properties": {
                "statuses": {
                    "items": {
                        "enum": [
                            "OK",
                            0,
                            "CANCELED",
                            1,
                            "UNKNOWN",
                            2,
                            "INVALID_ARGUMENT",
                            3,
                            "DEADLINE_EXCEEDED",
                            4,
                            "NOT_FOUND",
                            5,
                            "ALREADY_EXISTS",
                            6,
                            "PERMISSION_DENIED",
                            7,
                            "RESOURCE_EXHAUSTED",
                            8,
                            "FAILED_PRECONDITION",
                            9,
                            "ABORTED",
                            10,
                            "OUT_OF_RANGE",
                            11,
                            "UNIMPLEMENTED",
                            12,
                            "INTERNAL",
                            13,
                            "UNAVAILABLE",
                            14,
                            "DATA_LOSS",
                            15,
                            "UNAUTHENTICATED",
                            16
                        ]
                    },
                    "type": "array",
                    "title": "Status"
                },
                "exclude": {
                    "type": "boolean",
                    "description": "If included and set to true, the filter will instead block all responses with a gRPC status or inferred gRPC status enumerated in statuses, and allow all other responses."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Grpc Status Filter",
            "description": "Filters gRPC requests based on their response status. If a gRPC status is not provided, the filter will infer the status from the HTTP status code."
        },
        "envoy.config.accesslog.v3.HeaderFilter": {
            "properties": {
                "header": {
                    "$ref": "#/definitions/envoy.config.route.v3.HeaderMatcher",
                    "additionalProperties": true,
                    "description": "Only requests with a header which matches the specified HeaderMatcher will pass the filter check."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Header Filter",
            "description": "Filters requests based on the presence or value of a request header."
        },
        "envoy.config.accesslog.v3.LogTypeFilter": {
            "properties": {
                "types": {
                    "items": {
                        "enum": [
                            "NotSet",
                            0,
                            "TcpUpstreamConnected",
                            1,
                            "TcpPeriodic",
                            2,
                            "TcpConnectionEnd",
                            3,
                            "DownstreamStart",
                            4,
                            "DownstreamPeriodic",
                            5,
                            "DownstreamEnd",
                            6,
                            "UpstreamPoolReady",
                            7,
                            "UpstreamPeriodic",
                            8,
                            "UpstreamEnd",
                            9,
                            "DownstreamTunnelSuccessfullyEstablished",
                            10,
                            "UdpTunnelUpstreamConnected",
                            11,
                            "UdpPeriodic",
                            12,
                            "UdpSessionEnd",
                            13
                        ]
                    },
                    "type": "array",
                    "title": "[#protodoc-title: gRPC access logs]\n Envoy access logs describe incoming interaction with Envoy over a fixed\n period of time, and typically cover a single request/response exchange,\n (e.g. HTTP), stream (e.g. over HTTP/gRPC), or proxied connection (e.g. TCP).\n Access logs contain fields defined in protocol-specific protobuf messages.\n\n Except where explicitly declared otherwise, all fields describe\n *downstream* interaction between Envoy and a connected client.\n Fields describing *upstream* interaction will explicitly include ``upstream``\n in their name.",
                    "description": "[#protodoc-title: gRPC access logs] Envoy access logs describe incoming interaction with Envoy over a fixed period of time, and typically cover a single request/response exchange, (e.g. HTTP), stream (e.g. over HTTP/gRPC), or proxied connection (e.g. TCP). Access logs contain fields defined in protocol-specific protobuf messages. Except where explicitly declared otherwise, all fields describe *downstream* interaction between Envoy and a connected client. Fields describing *upstream* interaction will explicitly include ``upstream`` in their name."
                },
                "exclude": {
                    "type": "boolean",
                    "description": "If this field is set to true, the filter will instead block all records with a access log type in types field, and allow all other records."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Log Type Filter",
            "description": "Filters based on access log type."
        },
        "envoy.config.accesslog.v3.MetadataFilter": {
            "properties": {
                "matcher": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.MetadataMatcher",
                    "additionalProperties": true,
                    "description": "Matcher to check metadata for specified value. For example, to match on the access_log_hint metadata, set the filter to \"envoy.common\" and the path to \"access_log_hint\", and the value to \"true\"."
                },
                "match_if_key_not_found": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Default result if the key does not exist in dynamic metadata: if unset or true, then log; if false, then don't log."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata Filter",
            "description": "Filters based on matching dynamic metadata. If the matcher path and key correspond to an existing key in dynamic metadata, the request is logged only if the matcher value is equal to the metadata value. If the matcher path and key *do not* correspond to an existing key in dynamic metadata, the request is logged only if match_if_key_not_found is \"true\" or unset."
        },
        "envoy.config.accesslog.v3.NotHealthCheckFilter": {
            "additionalProperties": true,
            "type": "object",
            "title": "Not Health Check Filter",
            "description": "Filters for requests that are not health check requests. A health check request is marked by the health check filter."
        },
        "envoy.config.accesslog.v3.OrFilter": {
            "properties": {
                "filters": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.accesslog.v3.AccessLogFilter"
                    },
                    "type": "array"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Or Filter",
            "description": "Performs a logical “or” operation on the result of each individual filter. Filters are evaluated sequentially and if one of them returns true, the filter returns true immediately."
        },
        "envoy.config.accesslog.v3.ResponseFlagFilter": {
            "properties": {
                "flags": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "Only responses with the any of the flags listed in this field will be logged. This field is optional. If it is not specified, then any response flag will pass the filter check."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Response Flag Filter",
            "description": "Filters requests that received responses with an Envoy response flag set. A list of the response flags can be found in the access log formatter :ref:`documentation\u003cconfig_access_log_format_response_flags\u003e`."
        },
        "envoy.config.accesslog.v3.RuntimeFilter": {
            "properties": {
                "runtime_key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Runtime key to get an optional overridden numerator for use in the ``percent_sampled`` field. If found in runtime, this value will replace the default numerator."
                },
                "percent_sampled": {
                    "$ref": "#/definitions/envoy.type.v3.FractionalPercent",
                    "additionalProperties": true,
                    "description": "The default sampling percentage. If not specified, defaults to 0% with denominator of 100."
                },
                "use_independent_randomness": {
                    "type": "boolean",
                    "description": "By default, sampling pivots on the header :ref:`x-request-id\u003cconfig_http_conn_man_headers_x-request-id\u003e` being present. If :ref:`x-request-id\u003cconfig_http_conn_man_headers_x-request-id\u003e` is present, the filter will consistently sample across multiple hosts based on the runtime key value and the value extracted from :ref:`x-request-id\u003cconfig_http_conn_man_headers_x-request-id\u003e`. If it is missing, or ``use_independent_randomness`` is set to true, the filter will randomly sample based on the runtime key value alone. ``use_independent_randomness`` can be used for logging kill switches within complex nested :ref:`AndFilter \u003cenvoy_v3_api_msg_config.accesslog.v3.AndFilter\u003e` and :ref:`OrFilter \u003cenvoy_v3_api_msg_config.accesslog.v3.OrFilter\u003e` blocks that are easier to reason about from a probability perspective (i.e., setting to true will cause the filter to behave like an independent random variable when composed within logical operator filters)."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Runtime Filter",
            "description": "Filters for random sampling of requests."
        },
        "envoy.config.accesslog.v3.StatusCodeFilter": {
            "properties": {
                "comparison": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.ComparisonFilter",
                    "additionalProperties": true,
                    "description": "Comparison."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Status Code Filter",
            "description": "Filters on HTTP response/status code."
        },
        "envoy.config.accesslog.v3.TraceableFilter": {
            "additionalProperties": true,
            "type": "object",
            "title": "Traceable Filter",
            "description": "Filters for requests that are traceable. See the tracing overview for more information on how a request becomes traceable."
        },
        "envoy.config.bootstrap.v3.Admin": {
            "properties": {
                "access_log": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.accesslog.v3.AccessLog"
                    },
                    "type": "array",
                    "description": "Configuration for :ref:`access logs \u003carch_overview_access_logs\u003e` emitted by the administration server."
                },
                "access_log_path": {
                    "type": "string",
                    "description": "The path to write the access log for the administration server. If no access log is desired specify ‘/dev/null’. This is only required if :ref:`address \u003cenvoy_v3_api_field_config.bootstrap.v3.Admin.address\u003e` is set. Deprecated in favor of ``access_log`` which offers more options."
                },
                "profile_path": {
                    "type": "string",
                    "description": "The cpu profiler output path for the administration server. If no profile path is specified, the default is ‘/var/log/envoy/envoy.prof’."
                },
                "address": {
                    "$ref": "#/definitions/envoy.config.core.v3.Address",
                    "additionalProperties": true,
                    "description": "The TCP address that the administration server will listen on. If not specified, Envoy will not start an administration server."
                },
                "socket_options": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.SocketOption"
                    },
                    "type": "array",
                    "description": "Additional socket options that may not be present in Envoy source code or precompiled binaries."
                },
                "ignore_global_conn_limit": {
                    "type": "boolean",
                    "description": "Indicates whether :ref:`global_downstream_max_connections \u003cconfig_overload_manager_limiting_connections\u003e` should apply to the admin interface or not."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Admin",
            "description": "Administration interface :ref:`operations documentation \u003coperations_admin_interface\u003e`. [#next-free-field: 7]"
        },
        "envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig": {
            "properties": {
                "log_format": {
                    "$ref": "#/definitions/envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig.LogFormat",
                    "additionalProperties": true,
                    "description": "Optional field to set the application logs format. If this field is set, it will override the default log format. Setting both this field and :option:`--log-format` command line option is not allowed, and will cause a bootstrap error."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Application Log Config"
        },
        "envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig.LogFormat": {
            "properties": {
                "json_format": {
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Flush application logs in JSON format. The configured JSON struct can support all the format flags specified in the :option:`--log-format` command line options section, except for the ``%v`` and ``%_`` flags."
                },
                "text_format": {
                    "type": "string",
                    "description": "Flush application log in a format defined by a string. The text format can support all the format flags specified in the :option:`--log-format` command line option section."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Log Format"
        },
        "envoy.config.bootstrap.v3.Bootstrap.DeferredStatOptions": {
            "properties": {
                "enable_deferred_creation_stats": {
                    "type": "boolean",
                    "description": "When the flag is enabled, Envoy will lazily initialize a subset of the stats (see below). This will save memory and CPU cycles when creating the objects that own these stats, if those stats are never referenced throughout the lifetime of the process. However, it will incur additional memory overhead for these objects, and a small increase of CPU usage when a at least one of the stats is updated for the first time. Groups of stats that will be lazily initialized: - Cluster traffic stats: a subgroup of the :ref:`cluster statistics \u003cconfig_cluster_manager_cluster_stats\u003e` that are used when requests are routed to the cluster."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Deferred Stat Options"
        },
        "envoy.config.bootstrap.v3.Bootstrap.DynamicResources": {
            "properties": {
                "lds_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.ConfigSource",
                    "additionalProperties": true,
                    "description": "All :ref:`Listeners \u003cenvoy_v3_api_msg_config.listener.v3.Listener\u003e` are provided by a single :ref:`LDS \u003carch_overview_dynamic_config_lds\u003e` configuration source."
                },
                "lds_resources_locator": {
                    "type": "string",
                    "description": "xdstp:// resource locator for listener collection. [#not-implemented-hide:]"
                },
                "cds_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.ConfigSource",
                    "additionalProperties": true,
                    "description": "All post-bootstrap :ref:`Cluster \u003cenvoy_v3_api_msg_config.cluster.v3.Cluster\u003e` definitions are provided by a single :ref:`CDS \u003carch_overview_dynamic_config_cds\u003e` configuration source."
                },
                "cds_resources_locator": {
                    "type": "string",
                    "description": "xdstp:// resource locator for cluster collection. [#not-implemented-hide:]"
                },
                "ads_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.ApiConfigSource",
                    "additionalProperties": true,
                    "description": "A single :ref:`ADS \u003cconfig_overview_ads\u003e` source may be optionally specified. This must have :ref:`api_type \u003cenvoy_v3_api_field_config.core.v3.ApiConfigSource.api_type\u003e` :ref:`GRPC \u003cenvoy_v3_api_enum_value_config.core.v3.ApiConfigSource.ApiType.GRPC\u003e`. Only :ref:`ConfigSources \u003cenvoy_v3_api_msg_config.core.v3.ConfigSource\u003e` that have the :ref:`ads \u003cenvoy_v3_api_field_config.core.v3.ConfigSource.ads\u003e` field set will be streamed on the ADS channel."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Dynamic Resources",
            "description": "[#next-free-field: 7]"
        },
        "envoy.config.bootstrap.v3.Bootstrap.GrpcAsyncClientManagerConfig": {
            "properties": {
                "max_cached_entry_idle_duration": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Optional field to set the expiration time for the cached gRPC client object. The minimal value is 5s and the default is 50s.",
                    "format": "regex"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Grpc Async Client Manager Config"
        },
        "envoy.config.bootstrap.v3.Bootstrap.StaticResources": {
            "properties": {
                "listeners": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.listener.v3.Listener"
                    },
                    "type": "array",
                    "description": "Static :ref:`Listeners \u003cenvoy_v3_api_msg_config.listener.v3.Listener\u003e`. These listeners are available regardless of LDS configuration."
                },
                "clusters": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.cluster.v3.Cluster"
                    },
                    "type": "array",
                    "description": "If a network based configuration source is specified for :ref:`cds_config \u003cenvoy_v3_api_field_config.bootstrap.v3.Bootstrap.DynamicResources.cds_config\u003e`, it's necessary to have some initial cluster definitions available to allow Envoy to know how to speak to the management server. These cluster definitions may not use :ref:`EDS \u003carch_overview_dynamic_config_eds\u003e` (i.e. they should be static IP or DNS-based)."
                },
                "secrets": {
                    "items": {
                        "$ref": "#/definitions/envoy.extensions.transport_sockets.tls.v3.Secret"
                    },
                    "type": "array",
                    "description": "These static secrets can be used by :ref:`SdsSecretConfig \u003cenvoy_v3_api_msg_extensions.transport_sockets.tls.v3.SdsSecretConfig\u003e`"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Static Resources"
        },
        "envoy.config.bootstrap.v3.ClusterManager": {
            "properties": {
                "local_cluster_name": {
                    "type": "string",
                    "description": "Name of the local cluster (i.e., the cluster that owns the Envoy running this configuration). In order to enable :ref:`zone aware routing \u003carch_overview_load_balancing_zone_aware_routing\u003e` this option must be set. If ``local_cluster_name`` is defined then :ref:`clusters \u003cenvoy_v3_api_msg_config.cluster.v3.Cluster\u003e` must be defined in the :ref:`Bootstrap static cluster resources \u003cenvoy_v3_api_field_config.bootstrap.v3.Bootstrap.StaticResources.clusters\u003e`. This is unrelated to the :option:`--service-cluster` option which does not `affect zone aware routing \u003chttps://github.com/envoyproxy/envoy/issues/774\u003e`_."
                },
                "outlier_detection": {
                    "$ref": "#/definitions/envoy.config.bootstrap.v3.ClusterManager.OutlierDetection",
                    "additionalProperties": true,
                    "description": "Optional global configuration for outlier detection."
                },
                "upstream_bind_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.BindConfig",
                    "additionalProperties": true,
                    "description": "Optional configuration used to bind newly established upstream connections. This may be overridden on a per-cluster basis by upstream_bind_config in the cds_config."
                },
                "load_stats_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.ApiConfigSource",
                    "additionalProperties": true,
                    "description": "A management server endpoint to stream load stats to via ``StreamLoadStats``. This must have :ref:`api_type \u003cenvoy_v3_api_field_config.core.v3.ApiConfigSource.api_type\u003e` :ref:`GRPC \u003cenvoy_v3_api_enum_value_config.core.v3.ApiConfigSource.ApiType.GRPC\u003e`."
                },
                "enable_deferred_cluster_creation": {
                    "type": "boolean",
                    "description": "Whether the ClusterManager will create clusters on the worker threads inline during requests. This will save memory and CPU cycles in cases where there are lots of inactive clusters and \u003e 1 worker thread."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Cluster Manager",
            "description": "Cluster manager :ref:`architecture overview \u003carch_overview_cluster_manager\u003e`. [#next-free-field: 6]"
        },
        "envoy.config.bootstrap.v3.ClusterManager.OutlierDetection": {
            "properties": {
                "event_log_path": {
                    "type": "string",
                    "description": "Specifies the path to the outlier event log."
                },
                "event_service": {
                    "$ref": "#/definitions/envoy.config.core.v3.EventServiceConfig",
                    "additionalProperties": true,
                    "description": "[#not-implemented-hide:] The gRPC service for the outlier detection event service. If empty, outlier detection events won't be sent to a remote endpoint."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Outlier Detection"
        },
        "envoy.config.bootstrap.v3.CustomInlineHeader": {
            "properties": {
                "inline_header_name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the header that is expected to be set as the inline header."
                },
                "inline_header_type": {
                    "enum": [
                        "REQUEST_HEADER",
                        0,
                        "REQUEST_TRAILER",
                        1,
                        "RESPONSE_HEADER",
                        2,
                        "RESPONSE_TRAILER",
                        3
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Inline Header Type"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Custom Inline Header",
            "description": "Used to specify the header that needs to be registered as an inline header. If request or response contain multiple headers with the same name and the header name is registered as an inline header. Then multiple headers will be folded into one, and multiple header values will be concatenated by a suitable delimiter. The delimiter is generally a comma. For example, if 'foo' is registered as an inline header, and the headers contains the following two headers: .. code-block:: text   foo: bar   foo: eep Then they will eventually be folded into: .. code-block:: text   foo: bar, eep Inline headers provide O(1) search performance, but each inline header imposes an additional memory overhead on all instances of the corresponding type of HeaderMap or TrailerMap."
        },
        "envoy.config.bootstrap.v3.FatalAction": {
            "properties": {
                "config": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Extension specific configuration for the action. It's expected to conform to the ``Envoy::Server::Configuration::FatalAction`` interface."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Fatal Action",
            "description": "Fatal actions to run while crashing. Actions can be safe (meaning they are async-signal safe) or unsafe. We run all safe actions before we run unsafe actions. If using an unsafe action that could get stuck or deadlock, it important to have an out of band system to terminate the process. The interface for the extension is ``Envoy::Server::Configuration::FatalAction``. ``FatalAction`` extensions live in the ``envoy.extensions.fatal_actions`` API namespace."
        },
        "envoy.config.bootstrap.v3.LayeredRuntime": {
            "properties": {
                "layers": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.bootstrap.v3.RuntimeLayer"
                    },
                    "type": "array",
                    "description": "The :ref:`layers \u003cconfig_runtime_layering\u003e` of the runtime. This is ordered such that later layers in the list overlay earlier entries."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Layered Runtime",
            "description": "Runtime :ref:`configuration overview \u003cconfig_runtime\u003e`."
        },
        "envoy.config.bootstrap.v3.RuntimeLayer": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Descriptive name for the runtime layer. This is only used for the runtime :http:get:`/runtime` output."
                },
                "static_layer": {
                    "additionalProperties": true,
                    "type": "object",
                    "description": ":ref:`Static runtime \u003cconfig_runtime_bootstrap\u003e` layer. This follows the :ref:`runtime protobuf JSON representation encoding \u003cconfig_runtime_proto_json\u003e`. Unlike static xDS resources, this static layer is overridable by later layers in the runtime virtual filesystem."
                },
                "disk_layer": {
                    "$ref": "#/definitions/envoy.config.bootstrap.v3.RuntimeLayer.DiskLayer",
                    "additionalProperties": true
                },
                "admin_layer": {
                    "$ref": "#/definitions/envoy.config.bootstrap.v3.RuntimeLayer.AdminLayer",
                    "additionalProperties": true
                },
                "rtds_layer": {
                    "$ref": "#/definitions/envoy.config.bootstrap.v3.RuntimeLayer.RtdsLayer",
                    "additionalProperties": true
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Runtime Layer",
            "description": "[#next-free-field: 6]"
        },
        "envoy.config.bootstrap.v3.RuntimeLayer.AdminLayer": {
            "additionalProperties": true,
            "type": "object",
            "title": "Admin Layer",
            "description": ":ref:`Admin console runtime \u003cconfig_runtime_admin\u003e` layer."
        },
        "envoy.config.bootstrap.v3.RuntimeLayer.DiskLayer": {
            "properties": {
                "symlink_root": {
                    "type": "string",
                    "description": "The implementation assumes that the file system tree is accessed via a symbolic link. An atomic link swap is used when a new tree should be switched to. This parameter specifies the path to the symbolic link. Envoy will watch the location for changes and reload the file system tree when they happen. See documentation on runtime :ref:`atomicity \u003cconfig_runtime_atomicity\u003e` for further details on how reloads are treated."
                },
                "subdirectory": {
                    "type": "string",
                    "description": "Specifies the subdirectory to load within the root directory. This is useful if multiple systems share the same delivery mechanism. Envoy configuration elements can be contained in a dedicated subdirectory."
                },
                "append_service_cluster": {
                    "type": "boolean",
                    "description": ":ref:`Append \u003cconfig_runtime_local_disk_service_cluster_subdirs\u003e` the service cluster to the path under symlink root."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Disk Layer",
            "description": ":ref:`Disk runtime \u003cconfig_runtime_local_disk\u003e` layer."
        },
        "envoy.config.bootstrap.v3.RuntimeLayer.RtdsLayer": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Resource to subscribe to at ``rtds_config`` for the RTDS layer."
                },
                "rtds_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.ConfigSource",
                    "additionalProperties": true,
                    "description": "RTDS configuration source."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Rtds Layer",
            "description": ":ref:`Runtime Discovery Service (RTDS) \u003cconfig_runtime_rtds\u003e` layer."
        },
        "envoy.config.bootstrap.v3.Watchdog": {
            "properties": {
                "actions": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.bootstrap.v3.Watchdog.WatchdogAction"
                    },
                    "type": "array",
                    "description": "Register actions that will fire on given WatchDog events. See ``WatchDogAction`` for priority of events."
                },
                "miss_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The duration after which Envoy counts a nonresponsive thread in the ``watchdog_miss`` statistic. If not specified the default is 200ms.",
                    "format": "regex"
                },
                "megamiss_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The duration after which Envoy counts a nonresponsive thread in the ``watchdog_mega_miss`` statistic. If not specified the default is 1000ms.",
                    "format": "regex"
                },
                "kill_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "If a watched thread has been nonresponsive for this duration, assume a programming error and kill the entire Envoy process. Set to 0 to disable kill behavior. If not specified the default is 0 (disabled).",
                    "format": "regex"
                },
                "max_kill_timeout_jitter": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Defines the maximum jitter used to adjust the ``kill_timeout`` if ``kill_timeout`` is enabled. Enabling this feature would help to reduce risk of synchronized watchdog kill events across proxies due to external triggers. Set to 0 to disable. If not specified the default is 0 (disabled).",
                    "format": "regex"
                },
                "multikill_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "If ``max(2, ceil(registered_threads * Fraction(*multikill_threshold*)))`` threads have been nonresponsive for at least this duration kill the entire Envoy process. Set to 0 to disable this behavior. If not specified the default is 0 (disabled).",
                    "format": "regex"
                },
                "multikill_threshold": {
                    "$ref": "#/definitions/envoy.type.v3.Percent",
                    "additionalProperties": true,
                    "description": "Sets the threshold for ``multikill_timeout`` in terms of the percentage of nonresponsive threads required for the ``multikill_timeout``. If not specified the default is 0."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Watchdog",
            "description": "Envoy process watchdog configuration. When configured, this monitors for nonresponsive threads and kills the process after the configured thresholds. See the :ref:`watchdog documentation \u003coperations_performance_watchdog\u003e` for more information. [#next-free-field: 8]"
        },
        "envoy.config.bootstrap.v3.Watchdog.WatchdogAction": {
            "properties": {
                "config": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Extension specific configuration for the action."
                },
                "event": {
                    "enum": [
                        "UNKNOWN",
                        0,
                        "KILL",
                        1,
                        "MULTIKILL",
                        2,
                        "MEGAMISS",
                        3,
                        "MISS",
                        4
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Watchdog Event",
                    "description": "The events are fired in this order: KILL, MULTIKILL, MEGAMISS, MISS. Within an event type, actions execute in the order they are configured. For KILL/MULTIKILL there is a default PANIC that will run after the registered actions and kills the process if it wasn't already killed. It might be useful to specify several debug actions, and possibly an alternate FATAL action."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Watchdog Action"
        },
        "envoy.config.bootstrap.v3.Watchdogs": {
            "properties": {
                "main_thread_watchdog": {
                    "$ref": "#/definitions/envoy.config.bootstrap.v3.Watchdog",
                    "additionalProperties": true,
                    "description": "Watchdog for the main thread."
                },
                "worker_watchdog": {
                    "$ref": "#/definitions/envoy.config.bootstrap.v3.Watchdog",
                    "additionalProperties": true,
                    "description": "Watchdog for the worker threads."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Watchdogs",
            "description": "Allows you to specify different watchdog configs for different subsystems. This allows finer tuned policies for the watchdog. If a subsystem is omitted the default values for that system will be used."
        },
        "envoy.config.cluster.v3.CircuitBreakers": {
            "properties": {
                "thresholds": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.cluster.v3.CircuitBreakers.Thresholds"
                    },
                    "type": "array",
                    "description": "If multiple :ref:`Thresholds\u003cenvoy_v3_api_msg_config.cluster.v3.CircuitBreakers.Thresholds\u003e` are defined with the same :ref:`RoutingPriority\u003cenvoy_v3_api_enum_config.core.v3.RoutingPriority\u003e`, the first one in the list is used. If no Thresholds is defined for a given :ref:`RoutingPriority\u003cenvoy_v3_api_enum_config.core.v3.RoutingPriority\u003e`, the default values are used."
                },
                "per_host_thresholds": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.cluster.v3.CircuitBreakers.Thresholds"
                    },
                    "type": "array",
                    "description": "Optional per-host limits which apply to each individual host in a cluster. .. note::  currently only the :ref:`max_connections  \u003cenvoy_v3_api_field_config.cluster.v3.CircuitBreakers.Thresholds.max_connections\u003e` field is supported for per-host limits. If multiple per-host :ref:`Thresholds\u003cenvoy_v3_api_msg_config.cluster.v3.CircuitBreakers.Thresholds\u003e` are defined with the same :ref:`RoutingPriority\u003cenvoy_v3_api_enum_config.core.v3.RoutingPriority\u003e`, the first one in the list is used. If no per-host Thresholds are defined for a given :ref:`RoutingPriority\u003cenvoy_v3_api_enum_config.core.v3.RoutingPriority\u003e`, the cluster will not have per-host limits."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Circuit breakers]",
            "description": "[#protodoc-title: Circuit breakers]  :ref:`Circuit breaking\u003carch_overview_circuit_break\u003e` settings can be specified individually for each defined priority."
        },
        "envoy.config.cluster.v3.CircuitBreakers.Thresholds": {
            "properties": {
                "priority": {
                    "enum": [
                        "DEFAULT",
                        0,
                        "HIGH",
                        1
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "[#protodoc-title: Common types]",
                    "description": "[#protodoc-title: Common types]  Envoy supports :ref:`upstream priority routing \u003carch_overview_http_routing_priority\u003e` both at the route and the virtual cluster level. The current priority implementation uses different connection pool and circuit breaking settings for each priority level. This means that even for HTTP/2 requests, two physical connections will be used to an upstream host. In the future Envoy will likely support true HTTP/2 priority over a single upstream connection."
                },
                "max_connections": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The maximum number of connections that Envoy will make to the upstream cluster. If not specified, the default is 1024."
                },
                "max_pending_requests": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The maximum number of pending requests that Envoy will allow to the upstream cluster. If not specified, the default is 1024. This limit is applied as a connection limit for non-HTTP traffic."
                },
                "max_requests": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The maximum number of parallel requests that Envoy will make to the upstream cluster. If not specified, the default is 1024. This limit does not apply to non-HTTP traffic."
                },
                "max_retries": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The maximum number of parallel retries that Envoy will allow to the upstream cluster. If not specified, the default is 3."
                },
                "retry_budget": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.CircuitBreakers.Thresholds.RetryBudget",
                    "additionalProperties": true,
                    "description": "Specifies a limit on concurrent retries in relation to the number of active requests. This parameter is optional. .. note::    If this field is set, the retry budget will override any configured retry circuit    breaker."
                },
                "track_remaining": {
                    "type": "boolean",
                    "description": "If track_remaining is true, then stats will be published that expose the number of resources remaining until the circuit breakers open. If not specified, the default is false. .. note::    If a retry budget is used in lieu of the max_retries circuit breaker,    the remaining retry resources remaining will not be tracked."
                },
                "max_connection_pools": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The maximum number of connection pools per cluster that Envoy will concurrently support at once. If not specified, the default is unlimited. Set this for clusters which create a large number of connection pools. See :ref:`Circuit Breaking \u003carch_overview_circuit_break_cluster_maximum_connection_pools\u003e` for more details."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Thresholds",
            "description": "A Thresholds defines CircuitBreaker settings for a :ref:`RoutingPriority\u003cenvoy_v3_api_enum_config.core.v3.RoutingPriority\u003e`. [#next-free-field: 9]"
        },
        "envoy.config.cluster.v3.CircuitBreakers.Thresholds.RetryBudget": {
            "properties": {
                "budget_percent": {
                    "$ref": "#/definitions/envoy.type.v3.Percent",
                    "additionalProperties": true,
                    "description": "Specifies the limit on concurrent retries as a percentage of the sum of active requests and active pending requests. For example, if there are 100 active requests and the budget_percent is set to 25, there may be 25 active retries. This parameter is optional. Defaults to 20%."
                },
                "min_retry_concurrency": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Specifies the minimum retry concurrency allowed for the retry budget. The limit on the number of active retries may never go below this number. This parameter is optional. Defaults to 3."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Retry Budget"
        },
        "envoy.config.cluster.v3.Cluster": {
            "properties": {
                "transport_socket_matches": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.cluster.v3.Cluster.TransportSocketMatch"
                    },
                    "type": "array",
                    "description": "Configuration to use different transport sockets for different endpoints. The entry of ``envoy.transport_socket_match`` in the :ref:`LbEndpoint.Metadata \u003cenvoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata\u003e` is used to match against the transport sockets as they appear in the list. The first :ref:`match \u003cenvoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch\u003e` is used. For example, with the following match .. code-block:: yaml  transport_socket_matches:  - name: \"enableMTLS\"    match:      acceptMTLS: true    transport_socket:      name: envoy.transport_sockets.tls      config: { ... } # tls socket configuration  - name: \"defaultToPlaintext\"    match: {}    transport_socket:      name: envoy.transport_sockets.raw_buffer Connections to the endpoints whose metadata value under ``envoy.transport_socket_match`` having \"acceptMTLS\"/\"true\" key/value pair use the \"enableMTLS\" socket configuration. If a :ref:`socket match \u003cenvoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch\u003e` with empty match criteria is provided, that always match any endpoint. For example, the \"defaultToPlaintext\" socket match in case above. If an endpoint metadata's value under ``envoy.transport_socket_match`` does not match any ``TransportSocketMatch``, socket configuration fallbacks to use the ``tls_context`` or ``transport_socket`` specified in this cluster. This field allows gradual and flexible transport socket configuration changes. The metadata of endpoints in EDS can indicate transport socket capabilities. For example, an endpoint's metadata can have two key value pairs as \"acceptMTLS\": \"true\", \"acceptPlaintext\": \"true\". While some other endpoints, only accepting plaintext traffic has \"acceptPlaintext\": \"true\" metadata information. Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS traffic for endpoints with \"acceptMTLS\": \"true\", by adding a corresponding ``TransportSocketMatch`` in this field. Other client Envoys receive CDS without ``transport_socket_match`` set, and still send plain text traffic to the same cluster. This field can be used to specify custom transport socket configurations for health checks by adding matching key/value pairs in a health check's :ref:`transport socket match criteria \u003cenvoy_v3_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria\u003e` field. [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]"
                },
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Supplies the name of the cluster which must be unique across all clusters. The cluster name is used when emitting :ref:`statistics \u003cconfig_cluster_manager_cluster_stats\u003e` if :ref:`alt_stat_name \u003cenvoy_v3_api_field_config.cluster.v3.Cluster.alt_stat_name\u003e` is not provided. Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics."
                },
                "alt_stat_name": {
                    "type": "string",
                    "description": "An optional alternative to the cluster name to be used for observability. This name is used emitting stats for the cluster and access logging the cluster name. This will appear as additional information in configuration dumps of a cluster's current status as :ref:`observability_name \u003cenvoy_v3_api_field_admin.v3.ClusterStatus.observability_name\u003e` and as an additional tag \"upstream_cluster.name\" while tracing. Note: Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be confused with :ref:`Router Filter Header \u003cconfig_http_filters_router_x-envoy-upstream-alt-stat-name\u003e`."
                },
                "type": {
                    "enum": [
                        "STATIC",
                        0,
                        "STRICT_DNS",
                        1,
                        "LOGICAL_DNS",
                        2,
                        "EDS",
                        3,
                        "ORIGINAL_DST",
                        4
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Discovery Type",
                    "description": "Refer to :ref:`service discovery type \u003carch_overview_service_discovery_types\u003e` for an explanation on each type."
                },
                "cluster_type": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.Cluster.CustomClusterType",
                    "additionalProperties": true,
                    "description": "The custom cluster type."
                },
                "eds_cluster_config": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.Cluster.EdsClusterConfig",
                    "additionalProperties": true,
                    "description": "Configuration to use for EDS updates for the Cluster."
                },
                "connect_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The timeout for new network connections to hosts in the cluster. If not set, a default value of 5s will be used.",
                    "format": "regex"
                },
                "per_connection_buffer_limit_bytes": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Soft limit on size of the cluster’s connections read and write buffers. If unspecified, an implementation defined default is applied (1MiB)."
                },
                "lb_policy": {
                    "enum": [
                        "ROUND_ROBIN",
                        0,
                        "LEAST_REQUEST",
                        1,
                        "RING_HASH",
                        2,
                        "RANDOM",
                        3,
                        "MAGLEV",
                        5,
                        "CLUSTER_PROVIDED",
                        6,
                        "LOAD_BALANCING_POLICY_CONFIG",
                        7
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Lb Policy",
                    "description": "Refer to :ref:`load balancer type \u003carch_overview_load_balancing_types\u003e` architecture overview section for information on each type."
                },
                "load_assignment": {
                    "$ref": "#/definitions/envoy.config.endpoint.v3.ClusterLoadAssignment",
                    "additionalProperties": true,
                    "description": "Setting this is required for specifying members of :ref:`STATIC\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC\u003e`, :ref:`STRICT_DNS\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS\u003e` or :ref:`LOGICAL_DNS\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS\u003e` clusters. This field supersedes the ``hosts`` field in the v2 API. .. attention::   Setting this allows non-EDS cluster types to contain embedded EDS equivalent   :ref:`endpoint assignments\u003cenvoy_v3_api_msg_config.endpoint.v3.ClusterLoadAssignment\u003e`."
                },
                "health_checks": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.HealthCheck"
                    },
                    "type": "array",
                    "description": "Optional :ref:`active health checking \u003carch_overview_health_checking\u003e` configuration for the cluster. If no configuration is specified no health checking will be done and all cluster members will be considered healthy at all times."
                },
                "max_requests_per_connection": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Optional maximum requests for a single upstream connection. This parameter is respected by both the HTTP/1.1 and HTTP/2 connection pool implementations. If not specified, there is no limit. Setting this parameter to 1 will effectively disable keep alive. .. attention::   This field has been deprecated in favor of the :ref:`max_requests_per_connection \u003cenvoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_requests_per_connection\u003e` field."
                },
                "circuit_breakers": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.CircuitBreakers",
                    "additionalProperties": true,
                    "description": "Optional :ref:`circuit breaking \u003carch_overview_circuit_break\u003e` for the cluster."
                },
                "upstream_http_protocol_options": {
                    "$ref": "#/definitions/envoy.config.core.v3.UpstreamHttpProtocolOptions",
                    "additionalProperties": true,
                    "description": "HTTP protocol options that are applied only to upstream HTTP connections. These options apply to all HTTP versions. This has been deprecated in favor of :ref:`upstream_http_protocol_options \u003cenvoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options\u003e` in the :ref:`http_protocol_options \u003cenvoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions\u003e` message. upstream_http_protocol_options can be set via the cluster's :ref:`extension_protocol_options\u003cenvoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options\u003e`. See :ref:`upstream_http_protocol_options \u003cenvoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options\u003e` for example usage."
                },
                "common_http_protocol_options": {
                    "$ref": "#/definitions/envoy.config.core.v3.HttpProtocolOptions",
                    "additionalProperties": true,
                    "description": "Additional options when handling HTTP requests upstream. These options will be applicable to both HTTP1 and HTTP2 requests. This has been deprecated in favor of :ref:`common_http_protocol_options \u003cenvoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options\u003e` in the :ref:`http_protocol_options \u003cenvoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions\u003e` message. common_http_protocol_options can be set via the cluster's :ref:`extension_protocol_options\u003cenvoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options\u003e`. See :ref:`upstream_http_protocol_options \u003cenvoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options\u003e` for example usage."
                },
                "http_protocol_options": {
                    "$ref": "#/definitions/envoy.config.core.v3.Http1ProtocolOptions",
                    "additionalProperties": true,
                    "description": "Additional options when handling HTTP1 requests. This has been deprecated in favor of http_protocol_options fields in the :ref:`http_protocol_options \u003cenvoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions\u003e` message. http_protocol_options can be set via the cluster's :ref:`extension_protocol_options\u003cenvoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options\u003e`. See :ref:`upstream_http_protocol_options \u003cenvoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options\u003e` for example usage."
                },
                "http2_protocol_options": {
                    "$ref": "#/definitions/envoy.config.core.v3.Http2ProtocolOptions",
                    "additionalProperties": true,
                    "description": "Even if default HTTP2 protocol options are desired, this field must be set so that Envoy will assume that the upstream supports HTTP/2 when making new HTTP connection pool connections. Currently, Envoy only supports prior knowledge for upstream connections. Even if TLS is used with ALPN, ``http2_protocol_options`` must be specified. As an aside this allows HTTP/2 connections to happen over plain text. This has been deprecated in favor of http2_protocol_options fields in the :ref:`http_protocol_options \u003cenvoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions\u003e` message. http2_protocol_options can be set via the cluster's :ref:`extension_protocol_options\u003cenvoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options\u003e`. See :ref:`upstream_http_protocol_options \u003cenvoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options\u003e` for example usage."
                },
                "typed_extension_protocol_options": {
                    "additionalProperties": {
                        "properties": {
                            "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                            },
                            "value": {
                                "type": "string",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "format": "binary",
                                "binaryEncoding": "base64"
                            }
                        },
                        "additionalProperties": true,
                        "type": "object"
                    },
                    "type": "object",
                    "description": "The extension_protocol_options field is used to provide extension-specific protocol options for upstream connections. The key should match the extension filter name, such as \"envoy.filters.network.thrift_proxy\". See the extension's documentation for details on specific options. [#next-major-version: make this a list of typed extensions.]"
                },
                "dns_refresh_rate": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "If the DNS refresh rate is specified and the cluster type is either :ref:`STRICT_DNS\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS\u003e`, or :ref:`LOGICAL_DNS\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS\u003e`, this value is used as the cluster’s DNS refresh rate. The value configured must be at least 1ms. If this setting is not specified, the value defaults to 5000ms. For cluster types other than :ref:`STRICT_DNS\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS\u003e` and :ref:`LOGICAL_DNS\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS\u003e` this setting is ignored.",
                    "format": "regex"
                },
                "dns_failure_refresh_rate": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.Cluster.RefreshRate",
                    "additionalProperties": true,
                    "description": "If the DNS failure refresh rate is specified and the cluster type is either :ref:`STRICT_DNS\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS\u003e`, or :ref:`LOGICAL_DNS\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS\u003e`, this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types other than :ref:`STRICT_DNS\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS\u003e` and :ref:`LOGICAL_DNS\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS\u003e` this setting is ignored."
                },
                "respect_dns_ttl": {
                    "type": "boolean",
                    "description": "Optional configuration for setting cluster's DNS refresh rate. If the value is set to true, cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS resolution."
                },
                "dns_lookup_family": {
                    "enum": [
                        "AUTO",
                        0,
                        "V4_ONLY",
                        1,
                        "V6_ONLY",
                        2,
                        "V4_PREFERRED",
                        3,
                        "ALL",
                        4
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Dns Lookup Family",
                    "description": "When V4_ONLY is selected, the DNS resolver will only perform a lookup for addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will only perform a lookup for addresses in the IPv6 family. If AUTO is specified, the DNS resolver will first perform a lookup for addresses in the IPv6 family and fallback to a lookup for addresses in the IPv4 family. This is semantically equivalent to a non-existent V6_PREFERRED option. AUTO is a legacy name that is more opaque than necessary and will be deprecated in favor of V6_PREFERRED in a future major version of the API. If V4_PREFERRED is specified, the DNS resolver will first perform a lookup for addresses in the IPv4 family and fallback to a lookup for addresses in the IPv6 family. i.e., the callback target will only get v6 addresses if there were NO v4 addresses to return. If ALL is specified, the DNS resolver will perform a lookup for both IPv4 and IPv6 families, and return all resolved addresses. When this is used, Happy Eyeballs will be enabled for upstream connections. Refer to :ref:`Happy Eyeballs Support \u003carch_overview_happy_eyeballs\u003e` for more information. For cluster types other than :ref:`STRICT_DNS\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS\u003e` and :ref:`LOGICAL_DNS\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS\u003e`, this setting is ignored. [#next-major-version: deprecate AUTO in favor of a V6_PREFERRED option.]"
                },
                "dns_resolvers": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.Address"
                    },
                    "type": "array",
                    "description": "If DNS resolvers are specified and the cluster type is either :ref:`STRICT_DNS\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS\u003e`, or :ref:`LOGICAL_DNS\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS\u003e`, this value is used to specify the cluster’s dns resolvers. If this setting is not specified, the value defaults to the default resolver, which uses /etc/resolv.conf for configuration. For cluster types other than :ref:`STRICT_DNS\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS\u003e` and :ref:`LOGICAL_DNS\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS\u003e` this setting is ignored. This field is deprecated in favor of ``dns_resolution_config`` which aggregates all of the DNS resolver configuration in a single message."
                },
                "use_tcp_for_dns_lookups": {
                    "type": "boolean",
                    "description": "Always use TCP queries instead of UDP queries for DNS lookups. This field is deprecated in favor of ``dns_resolution_config`` which aggregates all of the DNS resolver configuration in a single message."
                },
                "dns_resolution_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.DnsResolutionConfig",
                    "additionalProperties": true,
                    "description": "DNS resolution configuration which includes the underlying dns resolver addresses and options. This field is deprecated in favor of :ref:`typed_dns_resolver_config \u003cenvoy_v3_api_field_config.cluster.v3.Cluster.typed_dns_resolver_config\u003e`."
                },
                "typed_dns_resolver_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "DNS resolver type configuration extension. This extension can be used to configure c-ares, apple, or any other DNS resolver types and the related parameters. For example, an object of :ref:`CaresDnsResolverConfig \u003cenvoy_v3_api_msg_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig\u003e` can be packed into this ``typed_dns_resolver_config``. This configuration replaces the :ref:`dns_resolution_config \u003cenvoy_v3_api_field_config.cluster.v3.Cluster.dns_resolution_config\u003e` configuration. During the transition period when both ``dns_resolution_config`` and ``typed_dns_resolver_config`` exists, when ``typed_dns_resolver_config`` is in place, Envoy will use it and ignore ``dns_resolution_config``. When ``typed_dns_resolver_config`` is missing, the default behavior is in place. [#extension-category: envoy.network.dns_resolver]"
                },
                "wait_for_warm_on_init": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Optional configuration for having cluster readiness block on warm-up. Currently, only applicable for :ref:`STRICT_DNS\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS\u003e`, or :ref:`LOGICAL_DNS\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS\u003e`, or :ref:`Redis Cluster\u003carch_overview_redis\u003e`. If true, cluster readiness blocks on warm-up. If false, the cluster will complete initialization whether or not warm-up has completed. Defaults to true."
                },
                "outlier_detection": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.OutlierDetection",
                    "additionalProperties": true,
                    "description": "If specified, outlier detection will be enabled for this upstream cluster. Each of the configuration values can be overridden via :ref:`runtime values \u003cconfig_cluster_manager_cluster_runtime_outlier_detection\u003e`."
                },
                "cleanup_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The interval for removing stale hosts from a cluster type :ref:`ORIGINAL_DST\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST\u003e`. Hosts are considered stale if they have not been used as upstream destinations during this interval. New hosts are added to original destination clusters on demand as new connections are redirected to Envoy, causing the number of hosts in the cluster to grow over time. Hosts that are not stale (they are actively used as destinations) are kept in the cluster, which allows connections to them remain open, saving the latency that would otherwise be spent on opening new connections. If this setting is not specified, the value defaults to 5000ms. For cluster types other than :ref:`ORIGINAL_DST\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST\u003e` this setting is ignored.",
                    "format": "regex"
                },
                "upstream_bind_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.BindConfig",
                    "additionalProperties": true,
                    "description": "Optional configuration used to bind newly established upstream connections. This overrides any bind_config specified in the bootstrap proto. If the address and port are empty, no bind will be performed."
                },
                "lb_subset_config": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.Cluster.LbSubsetConfig",
                    "additionalProperties": true,
                    "description": "Configuration for load balancing subsetting."
                },
                "ring_hash_lb_config": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.Cluster.RingHashLbConfig",
                    "additionalProperties": true,
                    "description": "Optional configuration for the Ring Hash load balancing policy."
                },
                "maglev_lb_config": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.Cluster.MaglevLbConfig",
                    "additionalProperties": true,
                    "description": "Optional configuration for the Maglev load balancing policy."
                },
                "original_dst_lb_config": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.Cluster.OriginalDstLbConfig",
                    "additionalProperties": true,
                    "description": "Optional configuration for the Original Destination load balancing policy."
                },
                "least_request_lb_config": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.Cluster.LeastRequestLbConfig",
                    "additionalProperties": true,
                    "description": "Optional configuration for the LeastRequest load balancing policy."
                },
                "round_robin_lb_config": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.Cluster.RoundRobinLbConfig",
                    "additionalProperties": true,
                    "description": "Optional configuration for the RoundRobin load balancing policy."
                },
                "common_lb_config": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.Cluster.CommonLbConfig",
                    "additionalProperties": true,
                    "description": "Common configuration for all load balancer implementations."
                },
                "transport_socket": {
                    "$ref": "#/definitions/envoy.config.core.v3.TransportSocket",
                    "additionalProperties": true,
                    "description": "Optional custom transport socket implementation to use for upstream connections. To setup TLS, set a transport socket with name ``envoy.transport_sockets.tls`` and :ref:`UpstreamTlsContexts \u003cenvoy_v3_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext\u003e` in the ``typed_config``. If no transport socket configuration is specified, new connections will be set up with plaintext."
                },
                "metadata": {
                    "$ref": "#/definitions/envoy.config.core.v3.Metadata",
                    "additionalProperties": true,
                    "description": "The Metadata field can be used to provide additional information about the cluster. It can be used for stats, logging, and varying filter behavior. Fields should use reverse DNS notation to denote which entity within Envoy will need the information. For instance, if the metadata is intended for the Router filter, the filter name should be specified as ``envoy.filters.http.router``."
                },
                "protocol_selection": {
                    "enum": [
                        "USE_CONFIGURED_PROTOCOL",
                        0,
                        "USE_DOWNSTREAM_PROTOCOL",
                        1
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Cluster Protocol Selection"
                },
                "upstream_connection_options": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.UpstreamConnectionOptions",
                    "additionalProperties": true,
                    "description": "Optional options for upstream connections."
                },
                "close_connections_on_host_health_failure": {
                    "type": "boolean",
                    "description": "If an upstream host becomes unhealthy (as determined by the configured health checks or outlier detection), immediately close all connections to the failed host. .. note::   This is currently only supported for connections created by tcp_proxy. .. note::   The current implementation of this feature closes all connections immediately when   the unhealthy status is detected. If there are a large number of connections open   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of   time exclusively closing these connections, and not processing any other traffic."
                },
                "ignore_health_on_host_removal": {
                    "type": "boolean",
                    "description": "If set to true, Envoy will ignore the health value of a host when processing its removal from service discovery. This means that if active health checking is used, Envoy will *not* wait for the endpoint to go unhealthy before removing it."
                },
                "filters": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.cluster.v3.Filter"
                    },
                    "type": "array",
                    "description": "An (optional) network filter chain, listed in the order the filters should be applied. The chain will be applied to all outgoing connections that Envoy makes to the upstream servers of this cluster."
                },
                "load_balancing_policy": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.LoadBalancingPolicy",
                    "additionalProperties": true,
                    "description": "If this field is set and is supported by the client, it will supersede the value of :ref:`lb_policy\u003cenvoy_v3_api_field_config.cluster.v3.Cluster.lb_policy\u003e`."
                },
                "lrs_server": {
                    "$ref": "#/definitions/envoy.config.core.v3.ConfigSource",
                    "additionalProperties": true,
                    "description": "[#not-implemented-hide:] If present, tells the client where to send load reports via LRS. If not present, the client will fall back to a client-side default, which may be either (a) don't send any load reports or (b) send load reports for all clusters to a single default server (which may be configured in the bootstrap file). Note that if multiple clusters point to the same LRS server, the client may choose to create a separate stream for each cluster or it may choose to coalesce the data for multiple clusters onto a single stream. Either way, the client must make sure to send the data for any given cluster on no more than one stream. [#next-major-version: In the v3 API, we should consider restructuring this somehow, maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation from the LRS stream here.]"
                },
                "track_timeout_budgets": {
                    "type": "boolean",
                    "description": "If track_timeout_budgets is true, the :ref:`timeout budget histograms \u003cconfig_cluster_manager_cluster_stats_timeout_budgets\u003e` will be published for each request. These show what percentage of a request's per try and global timeout was used. A value of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value of 100 would indicate that the request took the entirety of the timeout given to it. .. attention::   This field has been deprecated in favor of ``timeout_budgets``, part of   :ref:`track_cluster_stats \u003cenvoy_v3_api_field_config.cluster.v3.Cluster.track_cluster_stats\u003e`."
                },
                "upstream_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Optional customization and configuration of upstream connection pool, and upstream type. Currently this field only applies for HTTP traffic but is designed for eventual use for custom TCP upstreams. For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream HTTP, using the http connection pool and the codec from ``http2_protocol_options`` For routes where CONNECT termination is configured, Envoy will take downstream CONNECT requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool. The default pool used is the generic connection pool which creates the HTTP upstream for most HTTP requests, and the TCP upstream if CONNECT termination is configured. If users desire custom connection pool or upstream behavior, for example terminating CONNECT only if a custom filter indicates it is appropriate, the custom factories can be registered and configured here. [#extension-category: envoy.upstreams]"
                },
                "track_cluster_stats": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.TrackClusterStats",
                    "additionalProperties": true,
                    "description": "Configuration to track optional cluster stats."
                },
                "preconnect_policy": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.Cluster.PreconnectPolicy",
                    "additionalProperties": true,
                    "description": "Preconnect configuration for this cluster."
                },
                "connection_pool_per_downstream_connection": {
                    "type": "boolean",
                    "description": "If ``connection_pool_per_downstream_connection`` is true, the cluster will use a separate connection pool for every downstream connection"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Cluster",
            "description": "Configuration for a single upstream cluster. [#next-free-field: 57]"
        },
        "envoy.config.cluster.v3.Cluster.CommonLbConfig": {
            "properties": {
                "healthy_panic_threshold": {
                    "$ref": "#/definitions/envoy.type.v3.Percent",
                    "additionalProperties": true,
                    "description": "Configures the :ref:`healthy panic threshold \u003carch_overview_load_balancing_panic_threshold\u003e`. If not specified, the default is 50%. To disable panic mode, set to 0%. .. note::   The specified percent will be truncated to the nearest 1%."
                },
                "zone_aware_lb_config": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig",
                    "additionalProperties": true
                },
                "locality_weighted_lb_config": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig",
                    "additionalProperties": true
                },
                "update_merge_window": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "If set, all health check/weight/metadata updates that happen within this duration will be merged and delivered in one shot when the duration expires. The start of the duration is when the first update happens. This is useful for big clusters, with potentially noisy deploys that might trigger excessive CPU usage due to a constant stream of healthcheck state changes or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new cluster). Please always keep in mind that the use of sandbox technologies may change this behavior. If this is not set, we default to a merge window of 1000ms. To disable it, set the merge window to 0. Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is because merging those updates isn't currently safe. See https://github.com/envoyproxy/envoy/pull/3941.",
                    "format": "regex"
                },
                "ignore_new_hosts_until_first_hc": {
                    "type": "boolean",
                    "description": "If set to true, Envoy will :ref:`exclude \u003carch_overview_load_balancing_excluded\u003e` new hosts when computing load balancing weights until they have been health checked for the first time. This will have no effect unless active health checking is also configured."
                },
                "close_connections_on_host_set_change": {
                    "type": "boolean",
                    "description": "If set to ``true``, the cluster manager will drain all existing connections to upstream hosts whenever hosts are added or removed from the cluster."
                },
                "consistent_hashing_lb_config": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig",
                    "additionalProperties": true,
                    "description": "Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)"
                },
                "override_host_status": {
                    "$ref": "#/definitions/envoy.config.core.v3.HealthStatusSet",
                    "additionalProperties": true,
                    "description": "This controls what hosts are considered valid when using :ref:`host overrides \u003carch_overview_load_balancing_override_host\u003e`, which is used by some filters to modify the load balancing decision. If this is unset then [UNKNOWN, HEALTHY, DEGRADED] will be applied by default. If this is set with an empty set of statuses then host overrides will be ignored by the load balancing."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Common Lb Config",
            "description": "Common configuration for all load balancer implementations. [#next-free-field: 9]"
        },
        "envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig": {
            "properties": {
                "use_hostname_for_hashing": {
                    "type": "boolean",
                    "description": "If set to ``true``, the cluster will use hostname instead of the resolved address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address."
                },
                "hash_balance_factor": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150 no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster. If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200. Minimum is 100. Applies to both Ring Hash and Maglev load balancers. This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified ``hash_balance_factor``, requests to any upstream host are capped at ``hash_balance_factor/100`` times the average number of requests across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the cascading overflow effect when choosing the next host in the ring/table). If weights are specified on the hosts, they are respected. This is an O(N) algorithm, unlike other load balancers. Using a lower ``hash_balance_factor`` results in more hosts being probed, so use a higher value if you require better performance."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Consistent Hashing Lb Config",
            "description": "Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)"
        },
        "envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig": {
            "additionalProperties": true,
            "type": "object",
            "title": "Locality Weighted Lb Config",
            "description": "Configuration for :ref:`locality weighted load balancing \u003carch_overview_load_balancing_locality_weighted_lb\u003e`"
        },
        "envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig": {
            "properties": {
                "routing_enabled": {
                    "$ref": "#/definitions/envoy.type.v3.Percent",
                    "additionalProperties": true,
                    "description": "Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, the default is 100%. * :ref:`runtime values \u003cconfig_cluster_manager_cluster_runtime_zone_routing\u003e`. * :ref:`Zone aware routing support \u003carch_overview_load_balancing_zone_aware_routing\u003e`."
                },
                "min_cluster_size": {
                    "additionalProperties": true,
                    "type": "string",
                    "description": "Configures minimum upstream cluster size required for zone aware routing If upstream cluster size is less than specified, zone aware routing is not performed even if zone aware routing is configured. If not specified, the default is 6. * :ref:`runtime values \u003cconfig_cluster_manager_cluster_runtime_zone_routing\u003e`. * :ref:`Zone aware routing support \u003carch_overview_load_balancing_zone_aware_routing\u003e`."
                },
                "fail_traffic_on_panic": {
                    "type": "boolean",
                    "description": "If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic mode\u003carch_overview_load_balancing_panic_threshold\u003e`. Instead, the cluster will fail all requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a failing service."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Zone Aware Lb Config",
            "description": "Configuration for :ref:`zone aware routing \u003carch_overview_load_balancing_zone_aware_routing\u003e`."
        },
        "envoy.config.cluster.v3.Cluster.CustomClusterType": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The type of the cluster to instantiate. The name must match a supported cluster type."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Cluster specific configuration which depends on the cluster being instantiated. See the supported cluster for further documentation. [#extension-category: envoy.clusters]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Custom Cluster Type",
            "description": "Extended cluster type."
        },
        "envoy.config.cluster.v3.Cluster.EdsClusterConfig": {
            "properties": {
                "eds_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.ConfigSource",
                    "additionalProperties": true,
                    "description": "Configuration for the source of EDS updates for this Cluster."
                },
                "service_name": {
                    "type": "string",
                    "description": "Optional alternative to cluster name to present to EDS. This does not have the same restrictions as cluster name, i.e. it may be arbitrary length. This may be a xdstp:// URL."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Eds Cluster Config",
            "description": "Only valid when discovery type is EDS."
        },
        "envoy.config.cluster.v3.Cluster.LbSubsetConfig": {
            "properties": {
                "fallback_policy": {
                    "enum": [
                        "NO_FALLBACK",
                        0,
                        "ANY_ENDPOINT",
                        1,
                        "DEFAULT_SUBSET",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Lb Subset Fallback Policy",
                    "description": "If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected, any cluster endpoint may be returned (subject to policy, health checks, etc). If DEFAULT_SUBSET is selected, load balancing is performed over the endpoints matching the values from the default_subset field."
                },
                "default_subset": {
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Specifies the default subset of endpoints used during fallback if fallback_policy is :ref:`DEFAULT_SUBSET\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET\u003e`. Each field in default_subset is compared to the matching LbEndpoint.Metadata under the ``envoy.lb`` namespace. It is valid for no hosts to match, in which case the behavior is the same as a fallback_policy of :ref:`NO_FALLBACK\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK\u003e`."
                },
                "subset_selectors": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector"
                    },
                    "type": "array",
                    "description": "For each entry, LbEndpoint.Metadata's ``envoy.lb`` namespace is traversed and a subset is created for each unique combination of key and value. For example: .. code-block:: json   { \"subset_selectors\": [       { \"keys\": [ \"version\" ] },       { \"keys\": [ \"stage\", \"hardware_type\" ] }   ]} A subset is matched when the metadata from the selected route and weighted cluster contains the same keys and values as the subset's metadata. The same host may appear in multiple subsets."
                },
                "locality_weight_aware": {
                    "type": "boolean",
                    "description": "If true, routing to subsets will take into account the localities and locality weights of the endpoints when making the routing decision. There are some potential pitfalls associated with enabling this feature, as the resulting traffic split after applying both a subset match and locality weights might be undesirable. Consider for example a situation in which you have 50/50 split across two localities X/Y which have 100 hosts each without subsetting. If the subset LB results in X having only 1 host selected but Y having 100, then a lot more load is being dumped on the single host in X than originally anticipated in the load balancing assignment delivered via EDS."
                },
                "scale_locality_weight": {
                    "type": "boolean",
                    "description": "When used with locality_weight_aware, scales the weight of each locality by the ratio of hosts in the subset vs hosts in the original subset. This aims to even out the load going to an individual locality if said locality is disproportionately affected by the subset predicate."
                },
                "panic_mode_any": {
                    "type": "boolean",
                    "description": "If true, when a fallback policy is configured and its corresponding subset fails to find a host this will cause any host to be selected instead. This is useful when using the default subset as the fallback policy, given the default subset might become empty. With this option enabled, if that happens the LB will attempt to select a host from the entire cluster."
                },
                "list_as_any": {
                    "type": "boolean",
                    "description": "If true, metadata specified for a metadata key will be matched against the corresponding endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value and any of the elements in the list matches the criteria."
                },
                "metadata_fallback_policy": {
                    "enum": [
                        "METADATA_NO_FALLBACK",
                        0,
                        "FALLBACK_LIST",
                        1
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Lb Subset Metadata Fallback Policy"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Lb Subset Config",
            "description": "Optionally divide the endpoints in this cluster into subsets defined by endpoint metadata and selected by route and weighted cluster metadata. [#next-free-field: 9]"
        },
        "envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector": {
            "properties": {
                "keys": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "List of keys to match with the weighted cluster metadata."
                },
                "single_host_per_subset": {
                    "type": "boolean",
                    "description": "Selects a mode of operation in which each subset has only one host. This mode uses the same rules for choosing a host, but updating hosts is faster, especially for large numbers of hosts. If a match is found to a host, that host will be used regardless of priority levels. When this mode is enabled, configurations that contain more than one host with the same metadata value for the single key in ``keys`` will use only one of the hosts with the given key; no requests will be routed to the others. The cluster gauge :ref:`lb_subsets_single_host_per_subset_duplicate\u003cconfig_cluster_manager_cluster_stats_subset_lb\u003e` indicates how many duplicates are present in the current configuration."
                },
                "fallback_policy": {
                    "enum": [
                        "NOT_DEFINED",
                        0,
                        "NO_FALLBACK",
                        1,
                        "ANY_ENDPOINT",
                        2,
                        "DEFAULT_SUBSET",
                        3,
                        "KEYS_SUBSET",
                        4
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Lb Subset Selector Fallback Policy",
                    "description": "Allows to override top level fallback policy per selector."
                },
                "fallback_keys_subset": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "Subset of :ref:`keys\u003cenvoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys\u003e` used by :ref:`KEYS_SUBSET\u003cenvoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET\u003e` fallback policy. It has to be a non empty list if KEYS_SUBSET fallback policy is selected. For any other fallback policy the parameter is not used and should not be set. Only values also present in :ref:`keys\u003cenvoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys\u003e` are allowed, but ``fallback_keys_subset`` cannot be equal to ``keys``."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Lb Subset Selector",
            "description": "Specifications for subsets."
        },
        "envoy.config.cluster.v3.Cluster.LeastRequestLbConfig": {
            "properties": {
                "choice_count": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The number of random healthy hosts from which the host with the fewest active requests will be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set."
                },
                "active_request_bias": {
                    "$ref": "#/definitions/envoy.config.core.v3.RuntimeDouble",
                    "additionalProperties": true,
                    "description": "The following formula is used to calculate the dynamic weights when hosts have different load balancing weights: ``weight = load_balancing_weight / (active_requests + 1)^active_request_bias`` The larger the active request bias is, the more aggressively active requests will lower the effective weight when all host weights are not equal. ``active_request_bias`` must be greater than or equal to 0.0. When ``active_request_bias == 0.0`` the Least Request Load Balancer doesn't consider the number of active requests at the time it picks a host and behaves like the Round Robin Load Balancer. When ``active_request_bias \u003e 0.0`` the Least Request Load Balancer scales the load balancing weight by the number of active requests at the time it does a pick. The value is cached for performance reasons and refreshed whenever one of the Load Balancer's host sets changes, e.g., whenever there is a host membership update or a host load balancing weight change. .. note::   This setting only takes effect if all host weights are not equal."
                },
                "slow_start_config": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.Cluster.SlowStartConfig",
                    "additionalProperties": true,
                    "description": "Configuration for slow start mode. If this configuration is not set, slow start will not be not enabled."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Least Request Lb Config",
            "description": "Specific configuration for the LeastRequest load balancing policy."
        },
        "envoy.config.cluster.v3.Cluster.MaglevLbConfig": {
            "properties": {
                "table_size": {
                    "additionalProperties": true,
                    "type": "string",
                    "description": "The table size for Maglev hashing. Maglev aims for \"minimal disruption\" rather than an absolute guarantee. Minimal disruption means that when the set of upstream hosts change, a connection will likely be sent to the same upstream as it was before. Increasing the table size reduces the amount of disruption. The table size must be prime number limited to 5000011. If it is not specified, the default is 65537."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Maglev Lb Config",
            "description": "Specific configuration for the :ref:`Maglev\u003carch_overview_load_balancing_types_maglev\u003e` load balancing policy."
        },
        "envoy.config.cluster.v3.Cluster.OriginalDstLbConfig": {
            "properties": {
                "use_http_header": {
                    "type": "boolean",
                    "description": "When true, a HTTP header can be used to override the original dst address. The default header is :ref:`x-envoy-original-dst-host \u003cconfig_http_conn_man_headers_x-envoy-original-dst-host\u003e`. .. attention::   This header isn't sanitized by default, so enabling this feature allows HTTP clients to   route traffic to arbitrary hosts and/or ports, which may have serious security   consequences. .. note::   If the header appears multiple times only the first value is used."
                },
                "http_header_name": {
                    "type": "string",
                    "description": "The http header to override destination address if :ref:`use_http_header \u003cenvoy_v3_api_field_config.cluster.v3.Cluster.OriginalDstLbConfig.use_http_header\u003e`. is set to true. If the value is empty, :ref:`x-envoy-original-dst-host \u003cconfig_http_conn_man_headers_x-envoy-original-dst-host\u003e` will be used."
                },
                "upstream_port_override": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The port to override for the original dst address. This port will take precedence over filter state and header override ports"
                },
                "metadata_key": {
                    "$ref": "#/definitions/envoy.type.metadata.v3.MetadataKey",
                    "additionalProperties": true,
                    "description": "The dynamic metadata key to override destination address. First the request metadata is considered, then the connection one."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Original Dst Lb Config",
            "description": "Specific configuration for the :ref:`Original Destination \u003carch_overview_load_balancing_types_original_destination\u003e` load balancing policy. [#extension: envoy.clusters.original_dst]"
        },
        "envoy.config.cluster.v3.Cluster.PreconnectPolicy": {
            "properties": {
                "per_upstream_preconnect_ratio": {
                    "additionalProperties": true,
                    "type": "number",
                    "description": "Indicates how many streams (rounded up) can be anticipated per-upstream for each incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting will only be done if the upstream is healthy and the cluster has traffic. For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be established, one for the new incoming stream, and one for a presumed follow-up stream. For HTTP/2, only one connection would be established by default as one connection can serve both the original and presumed follow-up stream. In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100 active streams, there would be 100 connections in use, and 50 connections preconnected. This might be a useful value for something like short lived single-use connections, for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more reasonable, where for every 100 connections, 5 preconnected connections would be in the queue in case of unexpected disconnects where the connection could not be reused. If this value is not set, or set explicitly to one, Envoy will fetch as many connections as needed to serve streams in flight. This means in steady state if a connection is torn down, a subsequent streams will pay an upstream-rtt latency penalty waiting for a new connection. This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can harm latency more than the preconnecting helps."
                },
                "predictive_preconnect_ratio": {
                    "additionalProperties": true,
                    "type": "number",
                    "description": "Indicates how many streams (rounded up) can be anticipated across a cluster for each stream, useful for low QPS services. This is currently supported for a subset of deterministic non-hash-based load-balancing algorithms (weighted round robin, random). Unlike ``per_upstream_preconnect_ratio`` this preconnects across the upstream instances in a cluster, doing best effort predictions of what upstream would be picked next and pre-establishing a connection. Preconnecting will be limited to one preconnect per configured upstream in the cluster and will only be done if there are healthy upstreams and the cluster has traffic. For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first incoming stream, 2 connections will be preconnected - one to the first upstream for this cluster, one to the second on the assumption there will be a follow-up stream. If this value is not set, or set explicitly to one, Envoy will fetch as many connections as needed to serve streams in flight, so during warm up and in steady state if a connection is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for connection establishment. If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met, basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each upstream."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Preconnect Policy"
        },
        "envoy.config.cluster.v3.Cluster.RefreshRate": {
            "properties": {
                "base_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Specifies the base interval between refreshes. This parameter is required and must be greater than zero and less than :ref:`max_interval \u003cenvoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval\u003e`.",
                    "format": "regex"
                },
                "max_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Specifies the maximum interval between refreshes. This parameter is optional, but must be greater than or equal to the :ref:`base_interval \u003cenvoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval\u003e`  if set. The default is 10 times the :ref:`base_interval \u003cenvoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval\u003e`.",
                    "format": "regex"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Refresh Rate"
        },
        "envoy.config.cluster.v3.Cluster.RingHashLbConfig": {
            "properties": {
                "minimum_ring_size": {
                    "additionalProperties": true,
                    "type": "string",
                    "description": "Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each provided host) the better the request distribution will reflect the desired weights. Defaults to 1024 entries, and limited to 8M entries. See also :ref:`maximum_ring_size\u003cenvoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size\u003e`."
                },
                "hash_function": {
                    "enum": [
                        "XX_HASH",
                        0,
                        "MURMUR_HASH_2",
                        1
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Hash Function",
                    "description": "The hash function used to hash hosts onto the ketama ring."
                },
                "maximum_ring_size": {
                    "additionalProperties": true,
                    "type": "string",
                    "description": "Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered to further constrain resource use. See also :ref:`minimum_ring_size\u003cenvoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size\u003e`."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Ring Hash Lb Config",
            "description": "Specific configuration for the :ref:`RingHash\u003carch_overview_load_balancing_types_ring_hash\u003e` load balancing policy."
        },
        "envoy.config.cluster.v3.Cluster.RoundRobinLbConfig": {
            "properties": {
                "slow_start_config": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.Cluster.SlowStartConfig",
                    "additionalProperties": true,
                    "description": "Configuration for slow start mode. If this configuration is not set, slow start will not be not enabled."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Round Robin Lb Config",
            "description": "Specific configuration for the RoundRobin load balancing policy."
        },
        "envoy.config.cluster.v3.Cluster.SlowStartConfig": {
            "properties": {
                "slow_start_window": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Represents the size of slow start window. If set, the newly created host remains in slow start mode starting from its creation time for the duration of slow start window.",
                    "format": "regex"
                },
                "aggression": {
                    "$ref": "#/definitions/envoy.config.core.v3.RuntimeDouble",
                    "additionalProperties": true,
                    "description": "This parameter controls the speed of traffic increase over the slow start window. Defaults to 1.0, so that endpoint would get linearly increasing amount of traffic. When increasing the value for this parameter, the speed of traffic ramp-up increases non-linearly. The value of aggression parameter should be greater than 0.0. By tuning the parameter, is possible to achieve polynomial or exponential shape of ramp-up curve. During slow start window, effective weight of an endpoint would be scaled with time factor and aggression: ``new_weight = weight * max(min_weight_percent, time_factor ^ (1 / aggression))``, where ``time_factor=(time_since_start_seconds / slow_start_time_seconds)``. As time progresses, more and more traffic would be sent to endpoint, which is in slow start window. Once host exits slow start, time_factor and aggression no longer affect its weight."
                },
                "min_weight_percent": {
                    "$ref": "#/definitions/envoy.type.v3.Percent",
                    "additionalProperties": true,
                    "description": "Configures the minimum percentage of origin weight that avoids too small new weight, which may cause endpoints in slow start mode receive no traffic in slow start window. If not specified, the default is 10%."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Slow Start Config",
            "description": "Configuration for :ref:`slow start mode \u003carch_overview_load_balancing_slow_start\u003e`."
        },
        "envoy.config.cluster.v3.Cluster.TransportSocketMatch": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the match, used in stats generation."
                },
                "match": {
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Optional endpoint metadata match criteria. The connection to the endpoint with metadata matching what is set in this field will use the transport socket configuration specified here. The endpoint's metadata entry in ``envoy.transport_socket_match`` is used to match against the values specified in this field."
                },
                "transport_socket": {
                    "$ref": "#/definitions/envoy.config.core.v3.TransportSocket",
                    "additionalProperties": true,
                    "description": "The configuration of the transport socket. [#extension-category: envoy.transport_sockets.upstream]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Transport Socket Match",
            "description": "TransportSocketMatch specifies what transport socket config will be used when the match conditions are satisfied."
        },
        "envoy.config.cluster.v3.Filter": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the filter configuration."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Filter specific configuration which depends on the filter being instantiated. See the supported filters for further documentation. Note that Envoy's :ref:`downstream network filters \u003cconfig_network_filters\u003e` are not valid upstream network filters. Only one of typed_config or config_discovery can be used."
                },
                "config_discovery": {
                    "$ref": "#/definitions/envoy.config.core.v3.ExtensionConfigSource",
                    "additionalProperties": true,
                    "description": "Configuration source specifier for an extension configuration discovery service. In case of a failure and without the default configuration, the listener closes the connections. Only one of typed_config or config_discovery can be used."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Upstream network filters]\n Upstream network filters apply to the connections to the upstream cluster hosts.",
            "description": "[#protodoc-title: Upstream network filters] Upstream network filters apply to the connections to the upstream cluster hosts."
        },
        "envoy.config.cluster.v3.LoadBalancingPolicy": {
            "properties": {
                "policies": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.cluster.v3.LoadBalancingPolicy.Policy"
                    },
                    "type": "array",
                    "description": "Each client will iterate over the list in order and stop at the first policy that it supports. This provides a mechanism for starting to use new LB policies that are not yet supported by all clients."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Load Balancing Policy",
            "description": "Extensible load balancing policy configuration. Every LB policy defined via this mechanism will be identified via a unique name using reverse DNS notation. If the policy needs configuration parameters, it must define a message for its own configuration, which will be stored in the config field. The name of the policy will tell clients which type of message they should expect to see in the config field. Note that there are cases where it is useful to be able to independently select LB policies for choosing a locality and for choosing an endpoint within that locality. For example, a given deployment may always use the same policy to choose the locality, but for choosing the endpoint within the locality, some clusters may use weighted-round-robin, while others may use some sort of session-based balancing. This can be accomplished via hierarchical LB policies, where the parent LB policy creates a child LB policy for each locality. For each request, the parent chooses the locality and then delegates to the child policy for that locality to choose the endpoint within the locality. To facilitate this, the config message for the top-level LB policy may include a field of type LoadBalancingPolicy that specifies the child policy."
        },
        "envoy.config.cluster.v3.LoadBalancingPolicy.Policy": {
            "properties": {
                "typed_extension_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "[#extension-category: envoy.load_balancing_policies]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Policy"
        },
        "envoy.config.cluster.v3.OutlierDetection": {
            "properties": {
                "consecutive_5xx": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The number of consecutive server-side error responses (for HTTP traffic, 5xx responses; for TCP traffic, connection failures; for Redis, failure to respond PONG; etc.) before a consecutive 5xx ejection occurs. Defaults to 5."
                },
                "interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The time interval between ejection analysis sweeps. This can result in both new ejections as well as hosts being returned to service. Defaults to 10000ms or 10s.",
                    "format": "regex"
                },
                "base_ejection_time": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The base time that a host is ejected for. The real time is equal to the base time multiplied by the number of times the host has been ejected and is capped by :ref:`max_ejection_time\u003cenvoy_v3_api_field_config.cluster.v3.OutlierDetection.max_ejection_time\u003e`. Defaults to 30000ms or 30s.",
                    "format": "regex"
                },
                "max_ejection_percent": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The maximum % of an upstream cluster that can be ejected due to outlier detection. Defaults to 10% but will eject at least one host regardless of the value."
                },
                "enforcing_consecutive_5xx": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The % chance that a host will be actually ejected when an outlier status is detected through consecutive 5xx. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100."
                },
                "enforcing_success_rate": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The % chance that a host will be actually ejected when an outlier status is detected through success rate statistics. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100."
                },
                "success_rate_minimum_hosts": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The number of hosts in a cluster that must have enough request volume to detect success rate outliers. If the number of hosts is less than this setting, outlier detection via success rate statistics is not performed for any host in the cluster. Defaults to 5."
                },
                "success_rate_request_volume": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The minimum number of total requests that must be collected in one interval (as defined by the interval duration above) to include this host in success rate based outlier detection. If the volume is lower than this setting, outlier detection via success rate statistics is not performed for that host. Defaults to 100."
                },
                "success_rate_stdev_factor": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "This factor is used to determine the ejection threshold for success rate outlier ejection. The ejection threshold is the difference between the mean success rate, and the product of this factor and the standard deviation of the mean success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided by a thousand to get a double. That is, if the desired factor is 1.9, the runtime value should be 1900. Defaults to 1900."
                },
                "consecutive_gateway_failure": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The number of consecutive gateway failures (502, 503, 504 status codes) before a consecutive gateway failure ejection occurs. Defaults to 5."
                },
                "enforcing_consecutive_gateway_failure": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The % chance that a host will be actually ejected when an outlier status is detected through consecutive gateway failures. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 0."
                },
                "split_external_local_origin_errors": {
                    "type": "boolean",
                    "description": "Determines whether to distinguish local origin failures from external errors. If set to true the following configuration parameters are taken into account: :ref:`consecutive_local_origin_failure\u003cenvoy_v3_api_field_config.cluster.v3.OutlierDetection.consecutive_local_origin_failure\u003e`, :ref:`enforcing_consecutive_local_origin_failure\u003cenvoy_v3_api_field_config.cluster.v3.OutlierDetection.enforcing_consecutive_local_origin_failure\u003e` and :ref:`enforcing_local_origin_success_rate\u003cenvoy_v3_api_field_config.cluster.v3.OutlierDetection.enforcing_local_origin_success_rate\u003e`. Defaults to false."
                },
                "consecutive_local_origin_failure": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The number of consecutive locally originated failures before ejection occurs. Defaults to 5. Parameter takes effect only when :ref:`split_external_local_origin_errors\u003cenvoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors\u003e` is set to true."
                },
                "enforcing_consecutive_local_origin_failure": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The % chance that a host will be actually ejected when an outlier status is detected through consecutive locally originated failures. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100. Parameter takes effect only when :ref:`split_external_local_origin_errors\u003cenvoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors\u003e` is set to true."
                },
                "enforcing_local_origin_success_rate": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The % chance that a host will be actually ejected when an outlier status is detected through success rate statistics for locally originated errors. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100. Parameter takes effect only when :ref:`split_external_local_origin_errors\u003cenvoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors\u003e` is set to true."
                },
                "failure_percentage_threshold": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The failure percentage to use when determining failure percentage-based outlier detection. If the failure percentage of a given host is greater than or equal to this value, it will be ejected. Defaults to 85."
                },
                "enforcing_failure_percentage": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The % chance that a host will be actually ejected when an outlier status is detected through failure percentage statistics. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 0. [#next-major-version: setting this without setting failure_percentage_threshold should be invalid in v4.]"
                },
                "enforcing_failure_percentage_local_origin": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The % chance that a host will be actually ejected when an outlier status is detected through local-origin failure percentage statistics. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 0."
                },
                "failure_percentage_minimum_hosts": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The minimum number of hosts in a cluster in order to perform failure percentage-based ejection. If the total number of hosts in the cluster is less than this value, failure percentage-based ejection will not be performed. Defaults to 5."
                },
                "failure_percentage_request_volume": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The minimum number of total requests that must be collected in one interval (as defined by the interval duration above) to perform failure percentage-based ejection for this host. If the volume is lower than this setting, failure percentage-based ejection will not be performed for this host. Defaults to 50."
                },
                "max_ejection_time": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The maximum time that a host is ejected for. See :ref:`base_ejection_time\u003cenvoy_v3_api_field_config.cluster.v3.OutlierDetection.base_ejection_time\u003e` for more information. If not specified, the default value (300000ms or 300s) or :ref:`base_ejection_time\u003cenvoy_v3_api_field_config.cluster.v3.OutlierDetection.base_ejection_time\u003e` value is applied, whatever is larger.",
                    "format": "regex"
                },
                "max_ejection_time_jitter": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The maximum amount of jitter to add to the ejection time, in order to prevent a 'thundering herd' effect where all proxies try to reconnect to host at the same time. See :ref:`max_ejection_time_jitter\u003cenvoy_v3_api_field_config.cluster.v3.OutlierDetection.base_ejection_time\u003e` Defaults to 0s.",
                    "format": "regex"
                },
                "successful_active_health_check_uneject_host": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "If active health checking is enabled and a host is ejected by outlier detection, a successful active health check unejects the host by default and considers it as healthy. Unejection also clears all the outlier detection counters. To change this default behavior set this config to ``false`` where active health checking will not uneject the host. Defaults to true."
                },
                "monitors": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig"
                    },
                    "type": "array",
                    "description": "Set of host's passive monitors. [#not-implemented-hide:]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Outlier detection]",
            "description": "[#protodoc-title: Outlier detection]  See the :ref:`architecture overview \u003carch_overview_outlier_detection\u003e` for more information on outlier detection. [#next-free-field: 25]"
        },
        "envoy.config.cluster.v3.TrackClusterStats": {
            "properties": {
                "timeout_budgets": {
                    "type": "boolean",
                    "description": "If timeout_budgets is true, the :ref:`timeout budget histograms \u003cconfig_cluster_manager_cluster_stats_timeout_budgets\u003e` will be published for each request. These show what percentage of a request's per try and global timeout was used. A value of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value of 100 would indicate that the request took the entirety of the timeout given to it."
                },
                "request_response_sizes": {
                    "type": "boolean",
                    "description": "If request_response_sizes is true, then the :ref:`histograms \u003cconfig_cluster_manager_cluster_stats_request_response_sizes\u003e`  tracking header and body sizes of requests and responses will be published."
                },
                "per_endpoint_stats": {
                    "type": "boolean",
                    "description": "If true, some stats will be emitted per-endpoint, similar to the stats in admin ``/clusters`` output. This does not currently output correct stats during a hot-restart. This is not currently implemented by all stat sinks. These stats do not honor filtering or tag extraction rules in :ref:`StatsConfig \u003cenvoy_v3_api_msg_config.metrics.v3.StatsConfig\u003e` (but fixed-value tags are supported). Admin endpoint filtering is supported. This may not be used at the same time as :ref:`load_stats_config \u003cenvoy_v3_api_field_config.bootstrap.v3.ClusterManager.load_stats_config\u003e`."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Track Cluster Stats"
        },
        "envoy.config.cluster.v3.UpstreamConnectionOptions": {
            "properties": {
                "tcp_keepalive": {
                    "$ref": "#/definitions/envoy.config.core.v3.TcpKeepalive",
                    "additionalProperties": true,
                    "description": "If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives."
                },
                "set_local_interface_name_on_upstream_connections": {
                    "type": "boolean",
                    "description": "If enabled, associates the interface name of the local address with the upstream connection. This can be used by extensions during processing of requests. The association mechanism is implementation specific. Defaults to false due to performance concerns."
                },
                "happy_eyeballs_config": {
                    "$ref": "#/definitions/envoy.config.cluster.v3.UpstreamConnectionOptions.HappyEyeballsConfig",
                    "additionalProperties": true,
                    "description": "Configurations for happy eyeballs algorithm. Add configs for first_address_family_version and first_address_family_count when sorting destination ip addresses."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Upstream Connection Options"
        },
        "envoy.config.cluster.v3.UpstreamConnectionOptions.HappyEyeballsConfig": {
            "properties": {
                "first_address_family_version": {
                    "enum": [
                        "DEFAULT",
                        0,
                        "V4",
                        1,
                        "V6",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "First Address Family Version"
                },
                "first_address_family_count": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Specify the number of addresses of the first_address_family_version being attempted for connection before the other address family."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Happy Eyeballs Config"
        },
        "envoy.config.core.v3.Address": {
            "properties": {
                "socket_address": {
                    "$ref": "#/definitions/envoy.config.core.v3.SocketAddress",
                    "additionalProperties": true
                },
                "pipe": {
                    "$ref": "#/definitions/envoy.config.core.v3.Pipe",
                    "additionalProperties": true
                },
                "envoy_internal_address": {
                    "$ref": "#/definitions/envoy.config.core.v3.EnvoyInternalAddress",
                    "additionalProperties": true,
                    "description": "Specifies a user-space address handled by :ref:`internal listeners \u003cenvoy_v3_api_field_config.listener.v3.Listener.internal_listener\u003e`."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Address",
            "description": "Addresses specify either a logical or physical address and port, which are used to tell Envoy where to bind/listen, connect to upstream and find management servers."
        },
        "envoy.config.core.v3.AggregatedConfigSource": {
            "additionalProperties": true,
            "type": "object",
            "title": "Aggregated Config Source",
            "description": "Aggregated Discovery Service (ADS) options. This is currently empty, but when set in :ref:`ConfigSource \u003cenvoy_v3_api_msg_config.core.v3.ConfigSource\u003e` can be used to specify that ADS is to be used."
        },
        "envoy.config.core.v3.ApiConfigSource": {
            "properties": {
                "api_type": {
                    "enum": [
                        "DEPRECATED_AND_UNAVAILABLE_DO_NOT_USE",
                        0,
                        "REST",
                        1,
                        "GRPC",
                        2,
                        "DELTA_GRPC",
                        3,
                        "AGGREGATED_GRPC",
                        5,
                        "AGGREGATED_DELTA_GRPC",
                        6
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Api Type",
                    "description": "APIs may be fetched via either REST or gRPC."
                },
                "transport_api_version": {
                    "enum": [
                        "AUTO",
                        0,
                        "V2",
                        1,
                        "V3",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "[#protodoc-title: Configuration sources]",
                    "description": "[#protodoc-title: Configuration sources]  xDS API and non-xDS services version. This is used to describe both resource and transport protocol versions (in distinct configuration fields)."
                },
                "cluster_names": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "Cluster names should be used only with REST. If \u003e 1 cluster is defined, clusters will be cycled through if any kind of failure occurs. .. note::  The cluster with name ``cluster_name`` must be statically defined and its  type must not be ``EDS``."
                },
                "grpc_services": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.GrpcService"
                    },
                    "type": "array",
                    "description": "Multiple gRPC services be provided for GRPC. If \u003e 1 cluster is defined, services will be cycled through if any kind of failure occurs."
                },
                "refresh_delay": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "For REST APIs, the delay between successive polls.",
                    "format": "regex"
                },
                "request_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "For REST APIs, the request timeout. If not set, a default value of 1s will be used.",
                    "format": "regex"
                },
                "rate_limit_settings": {
                    "$ref": "#/definitions/envoy.config.core.v3.RateLimitSettings",
                    "additionalProperties": true,
                    "description": "For GRPC APIs, the rate limit settings. If present, discovery requests made by Envoy will be rate limited."
                },
                "set_node_on_first_message_only": {
                    "type": "boolean",
                    "description": "Skip the node identifier in subsequent discovery requests for streaming gRPC config types."
                },
                "config_validators": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig"
                    },
                    "type": "array",
                    "description": "A list of config validators that will be executed when a new update is received from the ApiConfigSource. Note that each validator handles a specific xDS service type, and only the validators corresponding to the type url (in ``:ref: DiscoveryResponse`` or ``:ref: DeltaDiscoveryResponse``) will be invoked. If the validator returns false or throws an exception, the config will be rejected by the client, and a NACK will be sent. [#extension-category: envoy.config.validators]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Api Config Source",
            "description": "API configuration source. This identifies the API type and cluster that Envoy will use to fetch an xDS API. [#next-free-field: 10]"
        },
        "envoy.config.core.v3.BackoffStrategy": {
            "properties": {
                "base_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The base interval to be used for the next back off computation. It should be greater than zero and less than or equal to :ref:`max_interval \u003cenvoy_v3_api_field_config.core.v3.BackoffStrategy.max_interval\u003e`.",
                    "format": "regex"
                },
                "max_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Specifies the maximum interval between retries. This parameter is optional, but must be greater than or equal to the :ref:`base_interval \u003cenvoy_v3_api_field_config.core.v3.BackoffStrategy.base_interval\u003e` if set. The default is 10 times the :ref:`base_interval \u003cenvoy_v3_api_field_config.core.v3.BackoffStrategy.base_interval\u003e`.",
                    "format": "regex"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Backoff strategy]",
            "description": "[#protodoc-title: Backoff strategy]  Configuration defining a jittered exponential back off strategy."
        },
        "envoy.config.core.v3.BindConfig": {
            "properties": {
                "source_address": {
                    "$ref": "#/definitions/envoy.config.core.v3.SocketAddress",
                    "additionalProperties": true,
                    "description": "The address to bind to when creating a socket."
                },
                "freebind": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Whether to set the ``IP_FREEBIND`` option when creating the socket. When this flag is set to true, allows the :ref:`source_address \u003cenvoy_v3_api_field_config.core.v3.BindConfig.source_address\u003e` to be an IP address that is not configured on the system running Envoy. When this flag is set to false, the option ``IP_FREEBIND`` is disabled on the socket. When this flag is not set (default), the socket is not modified, i.e. the option is neither enabled nor disabled."
                },
                "socket_options": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.SocketOption"
                    },
                    "type": "array",
                    "description": "Additional socket options that may not be present in Envoy source code or precompiled binaries."
                },
                "extra_source_addresses": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.ExtraSourceAddress"
                    },
                    "type": "array",
                    "description": "Extra source addresses appended to the address specified in the ``source_address`` field. This enables to specify multiple source addresses. The source address selection is determined by :ref:`local_address_selector \u003cenvoy_v3_api_field_config.core.v3.BindConfig.local_address_selector\u003e`."
                },
                "additional_source_addresses": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.SocketAddress"
                    },
                    "type": "array",
                    "description": "Deprecated by :ref:`extra_source_addresses \u003cenvoy_v3_api_field_config.core.v3.BindConfig.extra_source_addresses\u003e`"
                },
                "local_address_selector": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Custom local address selector to override the default (i.e. :ref:`DefaultLocalAddressSelector \u003cenvoy_v3_api_msg_config.upstream.local_address_selector.v3.DefaultLocalAddressSelector\u003e`). [#extension-category: envoy.upstream.local_address_selector]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Bind Config",
            "description": "[#next-free-field: 7]"
        },
        "envoy.config.core.v3.BuildVersion": {
            "properties": {
                "version": {
                    "$ref": "#/definitions/envoy.type.v3.SemanticVersion",
                    "additionalProperties": true,
                    "description": "SemVer version of extension."
                },
                "metadata": {
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Free-form build information. Envoy defines several well known keys in the source/common/version/version.h file"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Build Version",
            "description": "BuildVersion combines SemVer version of extension with free-form build information (i.e. 'alpha', 'private-build') as a set of strings."
        },
        "envoy.config.core.v3.CidrRange": {
            "properties": {
                "address_prefix": {
                    "minLength": 1,
                    "type": "string",
                    "description": "IPv4 or IPv6 address, e.g. ``192.0.0.0`` or ``2001:db8::``."
                },
                "prefix_len": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Length of prefix, e.g. 0, 32. Defaults to 0 when unset."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Cidr Range",
            "description": "CidrRange specifies an IP Address and a prefix length to construct the subnet mask for a `CIDR \u003chttps://tools.ietf.org/html/rfc4632\u003e`_ range."
        },
        "envoy.config.core.v3.ConfigSource": {
            "properties": {
                "authorities": {
                    "items": {
                        "$ref": "#/definitions/xds.core.v3.Authority"
                    },
                    "type": "array",
                    "description": "Authorities that this config source may be used for. An authority specified in a xdstp:// URL is resolved to a ``ConfigSource`` prior to configuration fetch. This field provides the association between authority name and configuration source. [#not-implemented-hide:]"
                },
                "path": {
                    "type": "string",
                    "description": "Deprecated in favor of ``path_config_source``. Use that field instead."
                },
                "path_config_source": {
                    "$ref": "#/definitions/envoy.config.core.v3.PathConfigSource",
                    "additionalProperties": true,
                    "description": "Local filesystem path configuration source."
                },
                "api_config_source": {
                    "$ref": "#/definitions/envoy.config.core.v3.ApiConfigSource",
                    "additionalProperties": true,
                    "description": "API configuration source."
                },
                "ads": {
                    "$ref": "#/definitions/envoy.config.core.v3.AggregatedConfigSource",
                    "additionalProperties": true,
                    "description": "When set, ADS will be used to fetch resources. The ADS API configuration source in the bootstrap configuration is used."
                },
                "self": {
                    "$ref": "#/definitions/envoy.config.core.v3.SelfConfigSource",
                    "additionalProperties": true,
                    "description": "[#not-implemented-hide:] When set, the client will access the resources from the same server it got the ConfigSource from, although not necessarily from the same stream. This is similar to the :ref:`ads\u003cenvoy_v3_api_field.ConfigSource.ads\u003e` field, except that the client may use a different stream to the same server. As a result, this field can be used for things like LRS that cannot be sent on an ADS stream. It can also be used to link from (e.g.) LDS to RDS on the same server without requiring the management server to know its name or required credentials. [#next-major-version: In xDS v3, consider replacing the ads field with this one, since this field can implicitly mean to use the same stream in the case where the ConfigSource is provided via ADS and the specified data can also be obtained via ADS.]"
                },
                "initial_fetch_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "When this timeout is specified, Envoy will wait no longer than the specified time for first config response on this xDS subscription during the :ref:`initialization process \u003carch_overview_initialization\u003e`. After reaching the timeout, Envoy will move to the next initialization phase, even if the first config is not delivered yet. The timer is activated when the xDS API subscription starts, and is disarmed on first config update or on error. 0 means no timeout - Envoy will wait indefinitely for the first xDS config (unless another timeout applies). The default is 15s.",
                    "format": "regex"
                },
                "resource_api_version": {
                    "enum": [
                        "AUTO",
                        0,
                        "V2",
                        1,
                        "V3",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "[#protodoc-title: Configuration sources]",
                    "description": "[#protodoc-title: Configuration sources]  xDS API and non-xDS services version. This is used to describe both resource and transport protocol versions (in distinct configuration fields)."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Config Source",
            "description": "Configuration for :ref:`listeners \u003cconfig_listeners\u003e`, :ref:`clusters \u003cconfig_cluster_manager\u003e`, :ref:`routes \u003cenvoy_v3_api_msg_config.route.v3.RouteConfiguration\u003e`, :ref:`endpoints \u003carch_overview_service_discovery\u003e` etc. may either be sourced from the filesystem or from an xDS API source. Filesystem configs are watched with inotify for updates. [#next-free-field: 9]"
        },
        "envoy.config.core.v3.DataSource": {
            "properties": {
                "filename": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Local filesystem data source."
                },
                "inline_bytes": {
                    "type": "string",
                    "description": "Bytes inlined in the configuration.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "inline_string": {
                    "type": "string",
                    "description": "String inlined in the configuration."
                },
                "environment_variable": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Environment variable data source."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Data Source",
            "description": "Data source consisting of a file, an inline value, or an environment variable."
        },
        "envoy.config.core.v3.DnsResolutionConfig": {
            "properties": {
                "resolvers": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.Address"
                    },
                    "type": "array",
                    "description": "A list of dns resolver addresses. If specified, the DNS client library will perform resolution via the underlying DNS resolvers. Otherwise, the default system resolvers (e.g., /etc/resolv.conf) will be used."
                },
                "dns_resolver_options": {
                    "$ref": "#/definitions/envoy.config.core.v3.DnsResolverOptions",
                    "additionalProperties": true,
                    "description": "Configuration of DNS resolver option flags which control the behavior of the DNS resolver."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Dns Resolution Config",
            "description": "DNS resolution configuration which includes the underlying dns resolver addresses and options."
        },
        "envoy.config.core.v3.DnsResolverOptions": {
            "properties": {
                "use_tcp_for_dns_lookups": {
                    "type": "boolean",
                    "description": "Use TCP for all DNS queries instead of the default protocol UDP."
                },
                "no_default_search_domain": {
                    "type": "boolean",
                    "description": "Do not use the default search domains; only query hostnames as-is or as aliases."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Resolver]",
            "description": "[#protodoc-title: Resolver]  Configuration of DNS resolver option flags which control the behavior of the DNS resolver."
        },
        "envoy.config.core.v3.EnvoyInternalAddress": {
            "properties": {
                "server_listener_name": {
                    "type": "string",
                    "description": "Specifies the :ref:`name \u003cenvoy_v3_api_field_config.listener.v3.Listener.name\u003e` of the internal listener."
                },
                "endpoint_id": {
                    "type": "string",
                    "description": "Specifies an endpoint identifier to distinguish between multiple endpoints for the same internal listener in a single upstream pool. Only used in the upstream addresses for tracking changes to individual endpoints. This, for example, may be set to the final destination IP for the target internal listener."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Envoy Internal Address",
            "description": "The address represents an envoy internal listener. [#comment: TODO(asraa): When address available, remove workaround from test/server/server_fuzz_test.cc:30.]"
        },
        "envoy.config.core.v3.EventServiceConfig": {
            "properties": {
                "grpc_service": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService",
                    "additionalProperties": true,
                    "description": "Specifies the gRPC service that hosts the event reporting service."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Event Service Config",
            "description": "[#not-implemented-hide:] Configuration of the event reporting service endpoint."
        },
        "envoy.config.core.v3.Extension": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "This is the name of the Envoy filter as specified in the Envoy configuration, e.g. envoy.filters.http.router, com.acme.widget."
                },
                "category": {
                    "type": "string",
                    "description": "Category of the extension. Extension category names use reverse DNS notation. For instance \"envoy.filters.listener\" for Envoy's built-in listener filters or \"com.acme.filters.http\" for HTTP filters from acme.com vendor. [#comment:TODO(yanavlasov): Link to the doc with existing envoy category names.]"
                },
                "type_descriptor": {
                    "type": "string",
                    "description": "[#not-implemented-hide:] Type descriptor of extension configuration proto. [#comment:TODO(yanavlasov): Link to the doc with existing configuration protos.] [#comment:TODO(yanavlasov): Add tests when PR #9391 lands.]"
                },
                "version": {
                    "$ref": "#/definitions/envoy.config.core.v3.BuildVersion",
                    "additionalProperties": true,
                    "description": "The version is a property of the extension and maintained independently of other extensions and the Envoy API. This field is not set when extension did not provide version information."
                },
                "disabled": {
                    "type": "boolean",
                    "description": "Indicates that the extension is present but was disabled via dynamic configuration."
                },
                "type_urls": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "Type URLs of extension configuration protos."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Extension",
            "description": "Version and identification for an Envoy extension. [#next-free-field: 7]"
        },
        "envoy.config.core.v3.ExtensionConfigSource": {
            "properties": {
                "config_source": {
                    "$ref": "#/definitions/envoy.config.core.v3.ConfigSource",
                    "additionalProperties": true
                },
                "default_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Optional default configuration to use as the initial configuration if there is a failure to receive the initial extension configuration or if ``apply_default_config_without_warming`` flag is set."
                },
                "apply_default_config_without_warming": {
                    "type": "boolean",
                    "description": "Use the default config as the initial configuration without warming and waiting for the first discovery response. Requires the default configuration to be supplied."
                },
                "type_urls": {
                    "items": {
                        "type": "string"
                    },
                    "minItems": 1,
                    "type": "array",
                    "description": "A set of permitted extension type URLs. Extension configuration updates are rejected if they do not match any type URL in the set."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Extension Config Source",
            "description": "Configuration source specifier for a late-bound extension configuration. The parent resource is warmed until all the initial extension configurations are received, unless the flag to apply the default configuration is set. Subsequent extension updates are atomic on a per-worker basis. Once an extension configuration is applied to a request or a connection, it remains constant for the duration of processing. If the initial delivery of the extension configuration fails, due to a timeout for example, the optional default configuration is applied. Without a default configuration, the extension is disabled, until an extension configuration is received. The behavior of a disabled extension depends on the context. For example, a filter chain with a disabled extension filter rejects all incoming streams."
        },
        "envoy.config.core.v3.ExtraSourceAddress": {
            "properties": {
                "address": {
                    "$ref": "#/definitions/envoy.config.core.v3.SocketAddress",
                    "additionalProperties": true,
                    "description": "The additional address to bind."
                },
                "socket_options": {
                    "$ref": "#/definitions/envoy.config.core.v3.SocketOptionsOverride",
                    "additionalProperties": true,
                    "description": "Additional socket options that may not be present in Envoy source code or precompiled binaries. If specified, this will override the :ref:`socket_options \u003cenvoy_v3_api_field_config.core.v3.BindConfig.socket_options\u003e` in the BindConfig. If specified with no :ref:`socket_options \u003cenvoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options\u003e` or an empty list of :ref:`socket_options \u003cenvoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options\u003e`, it means no socket option will apply."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Extra Source Address"
        },
        "envoy.config.core.v3.GrpcService": {
            "properties": {
                "envoy_grpc": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService.EnvoyGrpc",
                    "additionalProperties": true,
                    "description": "Envoy's in-built gRPC client. See the :ref:`gRPC services overview \u003carch_overview_grpc_services\u003e` documentation for discussion on gRPC client selection."
                },
                "google_grpc": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc",
                    "additionalProperties": true,
                    "description": "`Google C++ gRPC client \u003chttps://github.com/grpc/grpc\u003e`_ See the :ref:`gRPC services overview \u003carch_overview_grpc_services\u003e` documentation for discussion on gRPC client selection."
                },
                "timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The timeout for the gRPC request. This is the timeout for a specific request.",
                    "format": "regex"
                },
                "initial_metadata": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.HeaderValue"
                    },
                    "type": "array",
                    "description": "Additional metadata to include in streams initiated to the GrpcService. This can be used for scenarios in which additional ad hoc authorization headers (e.g. ``x-foo-bar: baz-key``) are to be injected. For more information, including details on header value syntax, see the documentation on :ref:`custom request headers \u003cconfig_http_conn_man_headers_custom_request_headers\u003e`."
                },
                "retry_policy": {
                    "$ref": "#/definitions/envoy.config.core.v3.RetryPolicy",
                    "additionalProperties": true,
                    "description": "Optional default retry policy for streams toward the service. If an async stream doesn't have retry policy configured in its stream options, this retry policy is used."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: gRPC services]",
            "description": "[#protodoc-title: gRPC services]  gRPC service configuration. This is used by :ref:`ApiConfigSource \u003cenvoy_v3_api_msg_config.core.v3.ApiConfigSource\u003e` and filter configurations. [#next-free-field: 7]"
        },
        "envoy.config.core.v3.GrpcService.EnvoyGrpc": {
            "properties": {
                "cluster_name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the upstream gRPC cluster. SSL credentials will be supplied in the :ref:`Cluster \u003cenvoy_v3_api_msg_config.cluster.v3.Cluster\u003e` :ref:`transport_socket \u003cenvoy_v3_api_field_config.cluster.v3.Cluster.transport_socket\u003e`."
                },
                "authority": {
                    "type": "string",
                    "description": "The ``:authority`` header in the grpc request. If this field is not set, the authority header value will be ``cluster_name``. Note that this authority does not override the SNI. The SNI is provided by the transport socket of the cluster."
                },
                "retry_policy": {
                    "$ref": "#/definitions/envoy.config.core.v3.RetryPolicy",
                    "additionalProperties": true,
                    "description": "Indicates the retry policy for re-establishing the gRPC stream This field is optional. If max interval is not provided, it will be set to ten times the provided base interval. Currently only supported for xDS gRPC streams. If not set, xDS gRPC streams default base interval:500ms, maximum interval:30s will be applied."
                },
                "max_receive_message_length": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Maximum gRPC message size that is allowed to be received. If a message over this limit is received, the gRPC stream is terminated with the RESOURCE_EXHAUSTED error. This limit is applied to individual messages in the streaming response and not the total size of streaming response. Defaults to 0, which means unlimited."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Envoy Grpc"
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc": {
            "properties": {
                "target_uri": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The target URI when using the `Google C++ gRPC client \u003chttps://github.com/grpc/grpc\u003e`_. SSL credentials will be supplied in :ref:`channel_credentials \u003cenvoy_v3_api_field_config.core.v3.GrpcService.GoogleGrpc.channel_credentials\u003e`."
                },
                "channel_credentials": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc.ChannelCredentials",
                    "additionalProperties": true
                },
                "call_credentials": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc.CallCredentials"
                    },
                    "type": "array",
                    "description": "A set of call credentials that can be composed with `channel credentials \u003chttps://grpc.io/docs/guides/auth.html#credential-types\u003e`_."
                },
                "stat_prefix": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The human readable prefix to use when emitting statistics for the gRPC service. .. csv-table::    :header: Name, Type, Description    :widths: 1, 1, 2    streams_total, Counter, Total number of streams opened    streams_closed_\u003cgRPC status code\u003e, Counter, Total streams closed with \u003cgRPC status code\u003e"
                },
                "credentials_factory_name": {
                    "type": "string",
                    "description": "The name of the Google gRPC credentials factory to use. This must have been registered with Envoy. If this is empty, a default credentials factory will be used that sets up channel credentials based on other configuration parameters."
                },
                "config": {
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Additional configuration for site-specific customizations of the Google gRPC library."
                },
                "per_stream_buffer_limit_bytes": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "How many bytes each stream can buffer internally. If not set an implementation defined default is applied (1MiB)."
                },
                "channel_args": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc.ChannelArgs",
                    "additionalProperties": true,
                    "description": "Custom channels args."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Google Grpc",
            "description": "[#next-free-field: 9]"
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc.CallCredentials": {
            "properties": {
                "access_token": {
                    "type": "string",
                    "description": "Access token credentials. https://grpc.io/grpc/cpp/namespacegrpc.html#ad3a80da696ffdaea943f0f858d7a360d."
                },
                "google_compute_engine": {
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Google Compute Engine credentials. https://grpc.io/grpc/cpp/namespacegrpc.html#a6beb3ac70ff94bd2ebbd89b8f21d1f61"
                },
                "google_refresh_token": {
                    "type": "string",
                    "description": "Google refresh token credentials. https://grpc.io/grpc/cpp/namespacegrpc.html#a96901c997b91bc6513b08491e0dca37c."
                },
                "service_account_jwt_access": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc.CallCredentials.ServiceAccountJWTAccessCredentials",
                    "additionalProperties": true,
                    "description": "Service Account JWT Access credentials. https://grpc.io/grpc/cpp/namespacegrpc.html#a92a9f959d6102461f66ee973d8e9d3aa."
                },
                "google_iam": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc.CallCredentials.GoogleIAMCredentials",
                    "additionalProperties": true,
                    "description": "Google IAM credentials. https://grpc.io/grpc/cpp/namespacegrpc.html#a9fc1fc101b41e680d47028166e76f9d0."
                },
                "from_plugin": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc.CallCredentials.MetadataCredentialsFromPlugin",
                    "additionalProperties": true,
                    "description": "Custom authenticator credentials. https://grpc.io/grpc/cpp/namespacegrpc.html#a823c6a4b19ffc71fb33e90154ee2ad07. https://grpc.io/docs/guides/auth.html#extending-grpc-to-support-other-authentication-mechanisms."
                },
                "sts_service": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc.CallCredentials.StsService",
                    "additionalProperties": true,
                    "description": "Custom security token service which implements OAuth 2.0 token exchange. https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-16 See https://github.com/grpc/grpc/pull/19587."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Call Credentials",
            "description": "[#next-free-field: 8]"
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc.CallCredentials.GoogleIAMCredentials": {
            "properties": {
                "authorization_token": {
                    "type": "string"
                },
                "authority_selector": {
                    "type": "string"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Google IAM Credentials"
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc.CallCredentials.MetadataCredentialsFromPlugin": {
            "properties": {
                "name": {
                    "type": "string"
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata Credentials From Plugin"
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc.CallCredentials.ServiceAccountJWTAccessCredentials": {
            "properties": {
                "json_key": {
                    "type": "string"
                },
                "token_lifetime_seconds": {
                    "type": "string"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Service Account JWT Access Credentials"
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc.CallCredentials.StsService": {
            "properties": {
                "token_exchange_service_uri": {
                    "type": "string",
                    "description": "URI of the token exchange service that handles token exchange requests. [#comment:TODO(asraa): Add URI validation when implemented. Tracked by https://github.com/bufbuild/protoc-gen-validate/issues/303]"
                },
                "resource": {
                    "type": "string",
                    "description": "Location of the target service or resource where the client intends to use the requested security token."
                },
                "audience": {
                    "type": "string",
                    "description": "Logical name of the target service where the client intends to use the requested security token."
                },
                "scope": {
                    "type": "string",
                    "description": "The desired scope of the requested security token in the context of the service or resource where the token will be used."
                },
                "requested_token_type": {
                    "type": "string",
                    "description": "Type of the requested security token."
                },
                "subject_token_path": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The path of subject token, a security token that represents the identity of the party on behalf of whom the request is being made."
                },
                "subject_token_type": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Type of the subject token."
                },
                "actor_token_path": {
                    "type": "string",
                    "description": "The path of actor token, a security token that represents the identity of the acting party. The acting party is authorized to use the requested security token and act on behalf of the subject."
                },
                "actor_token_type": {
                    "type": "string",
                    "description": "Type of the actor token."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Sts Service",
            "description": "Security token service configuration that allows Google gRPC to fetch security token from an OAuth 2.0 authorization server. See https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-16 and https://github.com/grpc/grpc/pull/19587. [#next-free-field: 10]"
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc.ChannelArgs": {
            "properties": {
                "args": {
                    "additionalProperties": {
                        "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc.ChannelArgs.Value",
                        "additionalProperties": true
                    },
                    "type": "object",
                    "description": "See grpc_types.h GRPC_ARG #defines for keys that work here."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Channel Args",
            "description": "Channel arguments."
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc.ChannelArgs.Value": {
            "properties": {
                "string_value": {
                    "type": "string"
                },
                "int_value": {
                    "type": "string"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Value"
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc.ChannelCredentials": {
            "properties": {
                "ssl_credentials": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc.SslCredentials",
                    "additionalProperties": true
                },
                "google_default": {
                    "additionalProperties": true,
                    "type": "object",
                    "description": "https://grpc.io/grpc/cpp/namespacegrpc.html#a6beb3ac70ff94bd2ebbd89b8f21d1f61"
                },
                "local_credentials": {
                    "$ref": "#/definitions/envoy.config.core.v3.GrpcService.GoogleGrpc.GoogleLocalCredentials",
                    "additionalProperties": true
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Channel Credentials",
            "description": "See https://grpc.io/docs/guides/auth.html#credential-types to understand Channel and Call credential types."
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc.GoogleLocalCredentials": {
            "additionalProperties": true,
            "type": "object",
            "title": "Google Local Credentials",
            "description": "Local channel credentials. Only UDS is supported for now. See https://github.com/grpc/grpc/pull/15909."
        },
        "envoy.config.core.v3.GrpcService.GoogleGrpc.SslCredentials": {
            "properties": {
                "root_certs": {
                    "$ref": "#/definitions/envoy.config.core.v3.DataSource",
                    "additionalProperties": true,
                    "description": "PEM encoded server root certificates."
                },
                "private_key": {
                    "$ref": "#/definitions/envoy.config.core.v3.DataSource",
                    "additionalProperties": true,
                    "description": "PEM encoded client private key."
                },
                "cert_chain": {
                    "$ref": "#/definitions/envoy.config.core.v3.DataSource",
                    "additionalProperties": true,
                    "description": "PEM encoded client certificate chain."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Ssl Credentials",
            "description": "See https://grpc.io/grpc/cpp/structgrpc_1_1_ssl_credentials_options.html."
        },
        "envoy.config.core.v3.HeaderValue": {
            "properties": {
                "key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Header name."
                },
                "value": {
                    "type": "string",
                    "description": "Header value. The same :ref:`format specifier \u003cconfig_access_log_format\u003e` as used for :ref:`HTTP access logging \u003cconfig_access_log\u003e` applies here, however unknown header values are replaced with the empty string instead of ``-``. Header value is encoded as string. This does not work for non-utf8 characters. Only one of ``value`` or ``raw_value`` can be set."
                },
                "raw_value": {
                    "type": "string",
                    "description": "Header value is encoded as bytes which can support non-utf8 characters. Only one of ``value`` or ``raw_value`` can be set.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Header Value",
            "description": "Header name/value pair."
        },
        "envoy.config.core.v3.HeaderValueOption": {
            "properties": {
                "header": {
                    "$ref": "#/definitions/envoy.config.core.v3.HeaderValue",
                    "additionalProperties": true,
                    "description": "Header name/value pair that this option applies to."
                },
                "append": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Should the value be appended? If true (default), the value is appended to existing values. Otherwise it replaces any existing values. This field is deprecated and please use :ref:`append_action \u003cenvoy_v3_api_field_config.core.v3.HeaderValueOption.append_action\u003e` as replacement. .. note::   The :ref:`external authorization service \u003cenvoy_v3_api_msg_service.auth.v3.CheckResponse\u003e` and   :ref:`external processor service \u003cenvoy_v3_api_msg_service.ext_proc.v3.ProcessingResponse\u003e` have   default value (``false``) for this field."
                },
                "append_action": {
                    "enum": [
                        "APPEND_IF_EXISTS_OR_ADD",
                        0,
                        "ADD_IF_ABSENT",
                        1,
                        "OVERWRITE_IF_EXISTS_OR_ADD",
                        2,
                        "OVERWRITE_IF_EXISTS",
                        3
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Header Append Action",
                    "description": "Describes the supported actions types for header append action."
                },
                "keep_empty_value": {
                    "type": "boolean",
                    "description": "Is the header value allowed to be empty? If false (default), custom headers with empty values are dropped, otherwise they are added."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Header Value Option",
            "description": "Header name/value pair plus option to control append behavior."
        },
        "envoy.config.core.v3.HealthCheck": {
            "properties": {
                "timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
                    "format": "regex"
                },
                "interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The interval between health checks.",
                    "format": "regex"
                },
                "initial_jitter": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "An optional jitter amount in milliseconds. If specified, Envoy will start health checking after for a random time in ms between 0 and initial_jitter. This only applies to the first health check.",
                    "format": "regex"
                },
                "interval_jitter": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "An optional jitter amount in milliseconds. If specified, during every interval Envoy will add interval_jitter to the wait time.",
                    "format": "regex"
                },
                "interval_jitter_percent": {
                    "type": "integer",
                    "description": "An optional jitter amount as a percentage of interval_ms. If specified, during every interval Envoy will add ``interval_ms`` * ``interval_jitter_percent`` / 100 to the wait time. If interval_jitter_ms and interval_jitter_percent are both set, both of them will be used to increase the wait time."
                },
                "unhealthy_threshold": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The number of unhealthy health checks required before a host is marked unhealthy. Note that for ``http`` health checking if a host responds with a code not in :ref:`expected_statuses \u003cenvoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses\u003e` or :ref:`retriable_statuses \u003cenvoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses\u003e`, this threshold is ignored and the host is considered immediately unhealthy."
                },
                "healthy_threshold": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The number of healthy health checks required before a host is marked healthy. Note that during startup, only a single successful health check is required to mark a host healthy."
                },
                "alt_port": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "[#not-implemented-hide:] Non-serving port for health checking."
                },
                "reuse_connection": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Reuse health check connection between health checks. Default is true."
                },
                "http_health_check": {
                    "$ref": "#/definitions/envoy.config.core.v3.HealthCheck.HttpHealthCheck",
                    "additionalProperties": true,
                    "description": "HTTP health check."
                },
                "tcp_health_check": {
                    "$ref": "#/definitions/envoy.config.core.v3.HealthCheck.TcpHealthCheck",
                    "additionalProperties": true,
                    "description": "TCP health check."
                },
                "grpc_health_check": {
                    "$ref": "#/definitions/envoy.config.core.v3.HealthCheck.GrpcHealthCheck",
                    "additionalProperties": true,
                    "description": "gRPC health check."
                },
                "custom_health_check": {
                    "$ref": "#/definitions/envoy.config.core.v3.HealthCheck.CustomHealthCheck",
                    "additionalProperties": true,
                    "description": "Custom health check."
                },
                "no_traffic_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The \"no traffic interval\" is a special health check interval that is used when a cluster has never had traffic routed to it. This lower interval allows cluster information to be kept up to date, without sending a potentially large amount of active health checking traffic for no reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the standard health check interval that is defined. Note that this interval takes precedence over any other. The default value for \"no traffic interval\" is 60 seconds.",
                    "format": "regex"
                },
                "no_traffic_healthy_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The \"no traffic healthy interval\" is a special health check interval that is used for hosts that are currently passing active health checking (including new hosts) when the cluster has received no traffic. This is useful for when we want to send frequent health checks with ``no_traffic_interval`` but then revert to lower frequency ``no_traffic_healthy_interval`` once a host in the cluster is marked as healthy. Once a cluster has been used for traffic routing, Envoy will shift back to using the standard health check interval that is defined. If no_traffic_healthy_interval is not set, it will default to the no traffic interval and send that interval regardless of health state.",
                    "format": "regex"
                },
                "unhealthy_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The \"unhealthy interval\" is a health check interval that is used for hosts that are marked as unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the standard health check interval that is defined. The default value for \"unhealthy interval\" is the same as \"interval\".",
                    "format": "regex"
                },
                "unhealthy_edge_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The \"unhealthy edge interval\" is a special health check interval that is used for the first health check right after a host is marked as unhealthy. For subsequent health checks Envoy will shift back to using either \"unhealthy interval\" if present or the standard health check interval that is defined. The default value for \"unhealthy edge interval\" is the same as \"unhealthy interval\".",
                    "format": "regex"
                },
                "healthy_edge_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The \"healthy edge interval\" is a special health check interval that is used for the first health check right after a host is marked as healthy. For subsequent health checks Envoy will shift back to using the standard health check interval that is defined. The default value for \"healthy edge interval\" is the same as the default interval.",
                    "format": "regex"
                },
                "event_log_path": {
                    "type": "string",
                    "description": ".. attention:: This field is deprecated in favor of the extension :ref:`event_logger \u003cenvoy_v3_api_field_config.core.v3.HealthCheck.event_logger\u003e` and :ref:`event_log_path \u003cenvoy_v3_api_field_extensions.health_check.event_sinks.file.v3.HealthCheckEventFileSink.event_log_path\u003e` in the file sink extension. Specifies the path to the :ref:`health check event log \u003carch_overview_health_check_logging\u003e`."
                },
                "event_logger": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig"
                    },
                    "type": "array",
                    "description": "A list of event log sinks to process the health check event. [#extension-category: envoy.health_check.event_sinks]"
                },
                "event_service": {
                    "$ref": "#/definitions/envoy.config.core.v3.EventServiceConfig",
                    "additionalProperties": true,
                    "description": "[#not-implemented-hide:] The gRPC service for the health check event service. If empty, health check events won't be sent to a remote endpoint."
                },
                "always_log_health_check_failures": {
                    "type": "boolean",
                    "description": "If set to true, health check failure events will always be logged. If set to false, only the initial health check failure event will be logged. The default value is false."
                },
                "always_log_health_check_success": {
                    "type": "boolean",
                    "description": "If set to true, health check success events will always be logged. If set to false, only host addition event will be logged if it is the first successful health check, or if the healthy threshold is reached. The default value is false."
                },
                "tls_options": {
                    "$ref": "#/definitions/envoy.config.core.v3.HealthCheck.TlsOptions",
                    "additionalProperties": true,
                    "description": "This allows overriding the cluster TLS settings, just for health check connections."
                },
                "transport_socket_match_criteria": {
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Optional key/value pairs that will be used to match a transport socket from those specified in the cluster's :ref:`tranport socket matches \u003cenvoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches\u003e`. For example, the following match criteria .. code-block:: yaml  transport_socket_match_criteria:    useMTLS: true Will match the following :ref:`cluster socket match \u003cenvoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch\u003e` .. code-block:: yaml  transport_socket_matches:  - name: \"useMTLS\"    match:      useMTLS: true    transport_socket:      name: envoy.transport_sockets.tls      config: { ... } # tls socket configuration If this field is set, then for health checks it will supersede an entry of ``envoy.transport_socket`` in the :ref:`LbEndpoint.Metadata \u003cenvoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata\u003e`. This allows using different transport socket capabilities for health checking versus proxying to the endpoint. If the key/values pairs specified do not match any :ref:`transport socket matches \u003cenvoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches\u003e`, the cluster's :ref:`transport socket \u003cenvoy_v3_api_field_config.cluster.v3.Cluster.transport_socket\u003e` will be used for health check socket configuration."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Health Check",
            "description": "[#next-free-field: 27]"
        },
        "envoy.config.core.v3.HealthCheck.CustomHealthCheck": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The registered name of the custom health checker."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Custom Health Check",
            "description": "Custom health check."
        },
        "envoy.config.core.v3.HealthCheck.GrpcHealthCheck": {
            "properties": {
                "service_name": {
                    "type": "string",
                    "description": "An optional service name parameter which will be sent to gRPC service in `grpc.health.v1.HealthCheckRequest \u003chttps://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20\u003e`_. message. See `gRPC health-checking overview \u003chttps://github.com/grpc/grpc/blob/master/doc/health-checking.md\u003e`_ for more information."
                },
                "authority": {
                    "type": "string",
                    "description": "The value of the :authority header in the gRPC health check request. If left empty (default value), the name of the cluster this health check is associated with will be used. The authority header can be customized for a specific endpoint by setting the :ref:`hostname \u003cenvoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname\u003e` field."
                },
                "initial_metadata": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.HeaderValueOption"
                    },
                    "type": "array",
                    "description": "Specifies a list of key-value pairs that should be added to the metadata of each GRPC call that is sent to the health checked cluster. For more information, including details on header value syntax, see the documentation on :ref:`custom request headers \u003cconfig_http_conn_man_headers_custom_request_headers\u003e`."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Grpc Health Check",
            "description": "`grpc.health.v1.Health \u003chttps://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto\u003e`_-based healthcheck. See `gRPC doc \u003chttps://github.com/grpc/grpc/blob/master/doc/health-checking.md\u003e`_ for details."
        },
        "envoy.config.core.v3.HealthCheck.HttpHealthCheck": {
            "properties": {
                "host": {
                    "type": "string",
                    "description": "The value of the host header in the HTTP health check request. If left empty (default value), the name of the cluster this health check is associated with will be used. The host header can be customized for a specific endpoint by setting the :ref:`hostname \u003cenvoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname\u003e` field."
                },
                "path": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Specifies the HTTP path that will be requested during health checking. For example ``/healthcheck``."
                },
                "send": {
                    "$ref": "#/definitions/envoy.config.core.v3.HealthCheck.Payload",
                    "additionalProperties": true,
                    "description": "[#not-implemented-hide:] HTTP specific payload."
                },
                "receive": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.HealthCheck.Payload"
                    },
                    "type": "array",
                    "description": "Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body. If it is set, both the expected response check and status code determine the health check. When checking the response, “fuzzy” matching is performed such that each payload block must be found, and in the order specified, but not necessarily contiguous. .. note::   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.   The default buffer size is 1024 bytes when it is not set."
                },
                "response_buffer_size": {
                    "additionalProperties": true,
                    "type": "string",
                    "description": "Specifies the size of response buffer in bytes that is used to Payload match. The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response."
                },
                "request_headers_to_add": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.HeaderValueOption"
                    },
                    "type": "array",
                    "description": "Specifies a list of HTTP headers that should be added to each request that is sent to the health checked cluster. For more information, including details on header value syntax, see the documentation on :ref:`custom request headers \u003cconfig_http_conn_man_headers_custom_request_headers\u003e`."
                },
                "request_headers_to_remove": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "Specifies a list of HTTP headers that should be removed from each request that is sent to the health checked cluster."
                },
                "expected_statuses": {
                    "items": {
                        "$ref": "#/definitions/envoy.type.v3.Int64Range"
                    },
                    "type": "array",
                    "description": "Specifies a list of HTTP response statuses considered healthy. If provided, replaces default 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open semantics of :ref:`Int64Range \u003cenvoy_v3_api_msg_type.v3.Int64Range\u003e`. The start and end of each range are required. Only statuses in the range [100, 600) are allowed."
                },
                "retriable_statuses": {
                    "items": {
                        "$ref": "#/definitions/envoy.type.v3.Int64Range"
                    },
                    "type": "array",
                    "description": "Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range will count towards the configured :ref:`unhealthy_threshold \u003cenvoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold\u003e`, but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of :ref:`Int64Range \u003cenvoy_v3_api_msg_type.v3.Int64Range\u003e`. The start and end of each range are required. Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses \u003cenvoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses\u003e` field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will be considered a successful health check. By default all responses not in :ref:`expected_statuses \u003cenvoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses\u003e` will result in the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any non-200 response will result in the host being marked unhealthy."
                },
                "codec_client_type": {
                    "enum": [
                        "HTTP1",
                        0,
                        "HTTP2",
                        1,
                        "HTTP3",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "[#protodoc-title: HTTP]",
                    "description": "[#protodoc-title: HTTP]"
                },
                "service_name_matcher": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.StringMatcher",
                    "additionalProperties": true,
                    "description": "An optional service name parameter which is used to validate the identity of the health checked cluster using a :ref:`StringMatcher \u003cenvoy_v3_api_msg_type.matcher.v3.StringMatcher\u003e`. See the :ref:`architecture overview \u003carch_overview_health_checking_identity\u003e` for more information."
                },
                "method": {
                    "enum": [
                        "METHOD_UNSPECIFIED",
                        0,
                        "GET",
                        1,
                        "HEAD",
                        2,
                        "POST",
                        3,
                        "PUT",
                        4,
                        "DELETE",
                        5,
                        "CONNECT",
                        6,
                        "OPTIONS",
                        7,
                        "TRACE",
                        8,
                        "PATCH",
                        9
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Request Method",
                    "description": "HTTP request method."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Http Health Check",
            "description": "[#next-free-field: 15]"
        },
        "envoy.config.core.v3.HealthCheck.Payload": {
            "properties": {
                "text": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Hex encoded payload. E.g., \"000000FF\"."
                },
                "binary": {
                    "type": "string",
                    "description": "Binary payload.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Payload",
            "description": "Describes the encoding of the payload bytes in the payload."
        },
        "envoy.config.core.v3.HealthCheck.TcpHealthCheck": {
            "properties": {
                "send": {
                    "$ref": "#/definitions/envoy.config.core.v3.HealthCheck.Payload",
                    "additionalProperties": true,
                    "description": "Empty payloads imply a connect-only health check."
                },
                "receive": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.HealthCheck.Payload"
                    },
                    "type": "array",
                    "description": "When checking the response, “fuzzy” matching is performed such that each payload block must be found, and in the order specified, but not necessarily contiguous."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Tcp Health Check"
        },
        "envoy.config.core.v3.HealthCheck.TlsOptions": {
            "properties": {
                "alpn_protocols": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "Specifies the ALPN protocols for health check connections. This is useful if the corresponding upstream is using ALPN-based :ref:`FilterChainMatch \u003cenvoy_v3_api_msg_config.listener.v3.FilterChainMatch\u003e` along with different protocols for health checks versus data connections. If empty, no ALPN protocols will be set on health check connections."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Tls Options",
            "description": "Health checks occur over the transport socket specified for the cluster. This implies that if a cluster is using a TLS-enabled transport socket, the health check will also occur over TLS. This allows overriding the cluster TLS settings, just for health check connections."
        },
        "envoy.config.core.v3.HealthStatusSet": {
            "properties": {
                "statuses": {
                    "items": {
                        "enum": [
                            "UNKNOWN",
                            0,
                            "HEALTHY",
                            1,
                            "UNHEALTHY",
                            2,
                            "DRAINING",
                            3,
                            "TIMEOUT",
                            4,
                            "DEGRADED",
                            5
                        ]
                    },
                    "type": "array",
                    "title": "[#protodoc-title: Health check]\n * Health checking :ref:`architecture overview \u003carch_overview_health_checking\u003e`.\n * If health checking is configured for a cluster, additional statistics are emitted. They are\n   documented :ref:`here \u003cconfig_cluster_manager_cluster_stats\u003e`.",
                    "description": "[#protodoc-title: Health check] * Health checking :ref:`architecture overview \u003carch_overview_health_checking\u003e`. * If health checking is configured for a cluster, additional statistics are emitted. They are   documented :ref:`here \u003cconfig_cluster_manager_cluster_stats\u003e`.  Endpoint health status."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Health Status Set"
        },
        "envoy.config.core.v3.Http1ProtocolOptions": {
            "properties": {
                "allow_absolute_url": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Handle HTTP requests with absolute URLs in the requests. These requests are generally sent by clients to forward/explicit proxies. This allows clients to configure envoy as their HTTP proxy. In Unix, for example, this is typically done by setting the ``http_proxy`` environment variable."
                },
                "accept_http_10": {
                    "type": "boolean",
                    "description": "Handle incoming HTTP/1.0 and HTTP 0.9 requests. This is off by default, and not fully standards compliant. There is support for pre-HTTP/1.1 style connect logic, dechunking, and handling lack of client host iff ``default_host_for_http_10`` is configured."
                },
                "default_host_for_http_10": {
                    "type": "string",
                    "description": "A default host for HTTP/1.0 requests. This is highly suggested if ``accept_http_10`` is true as Envoy does not otherwise support HTTP/1.0 without a Host header. This is a no-op if ``accept_http_10`` is not true."
                },
                "header_key_format": {
                    "$ref": "#/definitions/envoy.config.core.v3.Http1ProtocolOptions.HeaderKeyFormat",
                    "additionalProperties": true,
                    "description": "Describes how the keys for response headers should be formatted. By default, all header keys are lower cased."
                },
                "enable_trailers": {
                    "type": "boolean",
                    "description": "Enables trailers for HTTP/1. By default the HTTP/1 codec drops proxied trailers. .. attention::   Note that this only happens when Envoy is chunk encoding which occurs when:   - The request is HTTP/1.1.   - Is neither a HEAD only request nor a HTTP Upgrade.   - Not a response to a HEAD request.   - The content length header is not present."
                },
                "allow_chunked_length": {
                    "type": "boolean",
                    "description": "Allows Envoy to process requests/responses with both ``Content-Length`` and ``Transfer-Encoding`` headers set. By default such messages are rejected, but if option is enabled - Envoy will remove Content-Length header and process message. See `RFC7230, sec. 3.3.3 \u003chttps://tools.ietf.org/html/rfc7230#section-3.3.3\u003e`_ for details. .. attention::   Enabling this option might lead to request smuggling vulnerability, especially if traffic   is proxied via multiple layers of proxies. [#comment:TODO: This field is ignored when the :ref:`header validation configuration \u003cenvoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config\u003e` is present.]"
                },
                "override_stream_error_on_invalid_http_message": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Allows invalid HTTP messaging. When this option is false, then Envoy will terminate HTTP/1.1 connections upon receiving an invalid HTTP message. However, when this option is true, then Envoy will leave the HTTP/1.1 connection open where possible. If set, this overrides any HCM :ref:`stream_error_on_invalid_http_messaging \u003cenvoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message\u003e`."
                },
                "send_fully_qualified_url": {
                    "type": "boolean",
                    "description": "Allows sending fully qualified URLs when proxying the first line of the response. By default, Envoy will only send the path components in the first line. If this is true, Envoy will create a fully qualified URI composing scheme (inferred if not present), host (from the host/:authority header) and path (from first line or :path header)."
                },
                "use_balsa_parser": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "[#not-implemented-hide:] Hiding so that field can be removed after BalsaParser is rolled out. If set, force HTTP/1 parser: BalsaParser if true, http-parser if false. If unset, HTTP/1 parser is selected based on envoy.reloadable_features.http1_use_balsa_parser. See issue #21245."
                },
                "allow_custom_methods": {
                    "type": "boolean",
                    "description": "[#not-implemented-hide:] Hiding so that field can be removed. If true, and BalsaParser is used (either `use_balsa_parser` above is true, or `envoy.reloadable_features.http1_use_balsa_parser` is true and `use_balsa_parser` is unset), then every non-empty method with only valid characters is accepted. Otherwise, methods not on the hard-coded list are rejected. Once UHV is enabled, this field should be removed, and BalsaParser should allow any method. UHV validates the method, rejecting empty string or invalid characters, and provides :ref:`restrict_http_methods \u003cenvoy_v3_api_field_extensions.http.header_validators.envoy_default.v3.HeaderValidatorConfig.restrict_http_methods\u003e` to reject custom methods."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Http 1 Protocol Options",
            "description": "[#next-free-field: 11]"
        },
        "envoy.config.core.v3.Http1ProtocolOptions.HeaderKeyFormat": {
            "properties": {
                "proper_case_words": {
                    "$ref": "#/definitions/envoy.config.core.v3.Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords",
                    "additionalProperties": true,
                    "description": "Formats the header by proper casing words: the first character and any character following a special character will be capitalized if it's an alpha character. For example, \"content-type\" becomes \"Content-Type\", and \"foo$b#$are\" becomes \"Foo$B#$Are\". Note that while this results in most headers following conventional casing, certain headers are not covered. For example, the \"TE\" header will be formatted as \"Te\"."
                },
                "stateful_formatter": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Configuration for stateful formatter extensions that allow using received headers to affect the output of encoding headers. E.g., preserving case during proxying. [#extension-category: envoy.http.stateful_header_formatters]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Header Key Format",
            "description": "[#next-free-field: 9]"
        },
        "envoy.config.core.v3.Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords": {
            "additionalProperties": true,
            "type": "object",
            "title": "Proper Case Words"
        },
        "envoy.config.core.v3.Http2ProtocolOptions": {
            "properties": {
                "hpack_table_size": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "`Maximum table size \u003chttps://httpwg.org/specs/rfc7541.html#rfc.section.4.2\u003e`_ (in octets) that the encoder is permitted to use for the dynamic HPACK table. Valid values range from 0 to 4294967295 (2^32 - 1) and defaults to 4096. 0 effectively disables header compression."
                },
                "max_concurrent_streams": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "`Maximum concurrent streams \u003chttps://httpwg.org/specs/rfc7540.html#rfc.section.5.1.2\u003e`_ allowed for peer on one HTTP/2 connection. Valid values range from 1 to 2147483647 (2^31 - 1) and defaults to 2147483647. For upstream connections, this also limits how many streams Envoy will initiate concurrently on a single connection. If the limit is reached, Envoy may queue requests or establish additional connections (as allowed per circuit breaker limits). This acts as an upper bound: Envoy will lower the max concurrent streams allowed on a given connection based on upstream settings. Config dumps will reflect the configured upper bound, not the per-connection negotiated limits."
                },
                "initial_stream_window_size": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "`Initial stream-level flow-control window \u003chttps://httpwg.org/specs/rfc7540.html#rfc.section.6.9.2\u003e`_ size. Valid values range from 65535 (2^16 - 1, HTTP/2 default) to 2147483647 (2^31 - 1, HTTP/2 maximum) and defaults to 268435456 (256 * 1024 * 1024). NOTE: 65535 is the initial window size from HTTP/2 spec. We only support increasing the default window size now, so it's also the minimum. This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the HTTP/2 codec buffers. Once the buffer reaches this pointer, watermark callbacks will fire to stop the flow of data to the codec buffers."
                },
                "initial_connection_window_size": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Similar to ``initial_stream_window_size``, but for connection-level flow-control window. Currently, this has the same minimum/maximum/default as ``initial_stream_window_size``."
                },
                "allow_connect": {
                    "type": "boolean",
                    "description": "Allows proxying Websocket and other upgrades over H2 connect."
                },
                "allow_metadata": {
                    "type": "boolean",
                    "description": "[#not-implemented-hide:] Hiding until Envoy has full metadata support. Still under implementation. DO NOT USE. Allows sending and receiving HTTP/2 METADATA frames. See [metadata docs](https://github.com/envoyproxy/envoy/blob/main/source/docs/h2_metadata.md) for more information."
                },
                "max_outbound_frames": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Limit the number of pending outbound downstream frames of all types (frames that are waiting to be written into the socket). Exceeding this limit triggers flood mitigation and connection is terminated. The ``http2.outbound_flood`` stat tracks the number of terminated connections due to flood mitigation. The default limit is 10000."
                },
                "max_outbound_control_frames": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Limit the number of pending outbound downstream frames of types PING, SETTINGS and RST_STREAM, preventing high memory utilization when receiving continuous stream of these frames. Exceeding this limit triggers flood mitigation and connection is terminated. The ``http2.outbound_control_flood`` stat tracks the number of terminated connections due to flood mitigation. The default limit is 1000."
                },
                "max_consecutive_inbound_frames_with_empty_payload": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Limit the number of consecutive inbound frames of types HEADERS, CONTINUATION and DATA with an empty payload and no end stream flag. Those frames have no legitimate use and are abusive, but might be a result of a broken HTTP/2 implementation. The `http2.inbound_empty_frames_flood`` stat tracks the number of connections terminated due to flood mitigation. Setting this to 0 will terminate connection upon receiving first frame with an empty payload and no end stream flag. The default limit is 1."
                },
                "max_inbound_priority_frames_per_stream": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Limit the number of inbound PRIORITY frames allowed per each opened stream. If the number of PRIORITY frames received over the lifetime of connection exceeds the value calculated using this formula::   ``max_inbound_priority_frames_per_stream`` * (1 + ``opened_streams``) the connection is terminated. For downstream connections the ``opened_streams`` is incremented when Envoy receives complete response headers from the upstream server. For upstream connection the ``opened_streams`` is incremented when Envoy send the HEADERS frame for a new stream. The ``http2.inbound_priority_frames_flood`` stat tracks the number of connections terminated due to flood mitigation. The default limit is 100."
                },
                "max_inbound_window_update_frames_per_data_frame_sent": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Limit the number of inbound WINDOW_UPDATE frames allowed per DATA frame sent. If the number of WINDOW_UPDATE frames received over the lifetime of connection exceeds the value calculated using this formula::   5 + 2 * (``opened_streams`` +            ``max_inbound_window_update_frames_per_data_frame_sent`` * ``outbound_data_frames``) the connection is terminated. For downstream connections the ``opened_streams`` is incremented when Envoy receives complete response headers from the upstream server. For upstream connections the ``opened_streams`` is incremented when Envoy sends the HEADERS frame for a new stream. The ``http2.inbound_priority_frames_flood`` stat tracks the number of connections terminated due to flood mitigation. The default max_inbound_window_update_frames_per_data_frame_sent value is 10. Setting this to 1 should be enough to support HTTP/2 implementations with basic flow control, but more complex implementations that try to estimate available bandwidth require at least 2."
                },
                "stream_error_on_invalid_http_messaging": {
                    "type": "boolean",
                    "description": "Allows invalid HTTP messaging and headers. When this option is disabled (default), then the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However, when this option is enabled, only the offending stream is terminated. This is overridden by HCM :ref:`stream_error_on_invalid_http_messaging \u003cenvoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message\u003e` iff present. This is deprecated in favor of :ref:`override_stream_error_on_invalid_http_message \u003cenvoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message\u003e` See `RFC7540, sec. 8.1 \u003chttps://tools.ietf.org/html/rfc7540#section-8.1\u003e`_ for details."
                },
                "override_stream_error_on_invalid_http_message": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Allows invalid HTTP messaging and headers. When this option is disabled (default), then the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However, when this option is enabled, only the offending stream is terminated. This overrides any HCM :ref:`stream_error_on_invalid_http_messaging \u003cenvoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message\u003e` See `RFC7540, sec. 8.1 \u003chttps://tools.ietf.org/html/rfc7540#section-8.1\u003e`_ for details."
                },
                "custom_settings_parameters": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.Http2ProtocolOptions.SettingsParameter"
                    },
                    "type": "array",
                    "description": "[#not-implemented-hide:] Specifies SETTINGS frame parameters to be sent to the peer, with two exceptions: 1. SETTINGS_ENABLE_PUSH (0x2) is not configurable as HTTP/2 server push is not supported by Envoy. 2. SETTINGS_ENABLE_CONNECT_PROTOCOL (0x8) is only configurable through the named field 'allow_connect'. Note that custom parameters specified through this field can not also be set in the corresponding named parameters: .. code-block:: text   ID    Field Name   ----------------   0x1   hpack_table_size   0x3   max_concurrent_streams   0x4   initial_stream_window_size Collisions will trigger config validation failure on load/update. Likewise, inconsistencies between custom parameters with the same identifier will trigger a failure. See `IANA HTTP/2 Settings \u003chttps://www.iana.org/assignments/http2-parameters/http2-parameters.xhtml#settings\u003e`_ for standardized identifiers."
                },
                "connection_keepalive": {
                    "$ref": "#/definitions/envoy.config.core.v3.KeepaliveSettings",
                    "additionalProperties": true,
                    "description": "Send HTTP/2 PING frames to verify that the connection is still healthy. If the remote peer does not respond within the configured timeout, the connection will be aborted."
                },
                "use_oghttp2_codec": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "[#not-implemented-hide:] Hiding so that the field can be removed after oghttp2 is rolled out. If set, force use of a particular HTTP/2 codec: oghttp2 if true, nghttp2 if false. If unset, HTTP/2 codec is selected based on envoy.reloadable_features.http2_use_oghttp2."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Http 2 Protocol Options",
            "description": "[#next-free-field: 17]"
        },
        "envoy.config.core.v3.Http2ProtocolOptions.SettingsParameter": {
            "properties": {
                "identifier": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The 16 bit parameter identifier."
                },
                "value": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The 32 bit parameter value."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Settings Parameter",
            "description": "Defines a parameter to be sent in the SETTINGS frame. See `RFC7540, sec. 6.5.1 \u003chttps://tools.ietf.org/html/rfc7540#section-6.5.1\u003e`_ for details."
        },
        "envoy.config.core.v3.HttpProtocolOptions": {
            "properties": {
                "idle_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The idle timeout for connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. If the connection is an HTTP/2 downstream connection a drain sequence will occur prior to closing the connection, see :ref:`drain_timeout \u003cenvoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.drain_timeout\u003e`. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. If not specified, this defaults to 1 hour. To disable idle timeouts explicitly set this to 0. .. warning::   Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP   FIN packets, etc. If the :ref:`overload action \u003cconfig_overload_manager_overload_actions\u003e` \"envoy.overload_actions.reduce_timeouts\" is configured, this timeout is scaled for downstream connections according to the value for :ref:`HTTP_DOWNSTREAM_CONNECTION_IDLE \u003cenvoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_CONNECTION_IDLE\u003e`.",
                    "format": "regex"
                },
                "max_connection_duration": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The maximum duration of a connection. The duration is defined as a period since a connection was established. If not set, there is no max duration. When max_connection_duration is reached and if there are no active streams, the connection will be closed. If the connection is a downstream connection and there are any active streams, the drain sequence will kick-in, and the connection will be force-closed after the drain period. See :ref:`drain_timeout \u003cenvoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.drain_timeout\u003e`.",
                    "format": "regex"
                },
                "max_headers_count": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The maximum number of headers. If unconfigured, the default maximum number of request headers allowed is 100. Requests that exceed this limit will receive a 431 response for HTTP/1.x and cause a stream reset for HTTP/2."
                },
                "max_stream_duration": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Total duration to keep alive an HTTP request/response stream. If the time limit is reached the stream will be reset independent of any other timeouts. If not specified, this value is not set.",
                    "format": "regex"
                },
                "headers_with_underscores_action": {
                    "enum": [
                        "ALLOW",
                        0,
                        "REJECT_REQUEST",
                        1,
                        "DROP_HEADER",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Headers With Underscores Action",
                    "description": "Action to take when Envoy receives client request with header names containing underscore characters. Underscore character is allowed in header names by the RFC-7230 and this behavior is implemented as a security measure due to systems that treat '_' and '-' as interchangeable. Envoy by default allows client request headers with underscore characters."
                },
                "max_requests_per_connection": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Optional maximum requests for both upstream and downstream connections. If not specified, there is no limit. Setting this parameter to 1 will effectively disable keep alive. For HTTP/2 and HTTP/3, due to concurrent stream processing, the limit is approximate."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Http Protocol Options",
            "description": "[#next-free-field: 7]"
        },
        "envoy.config.core.v3.KeepaliveSettings": {
            "properties": {
                "interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Send HTTP/2 PING frames at this period, in order to test that the connection is still alive. If this is zero, interval PINGs will not be sent.",
                    "format": "regex"
                },
                "timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "How long to wait for a response to a keepalive PING. If a response is not received within this time period, the connection will be aborted. Note that in order to prevent the influence of Head-of-line (HOL) blocking the timeout period is extended when *any* frame is received on the connection, under the assumption that if a frame is received the connection is healthy.",
                    "format": "regex"
                },
                "interval_jitter": {
                    "$ref": "#/definitions/envoy.type.v3.Percent",
                    "additionalProperties": true,
                    "description": "A random jitter amount as a percentage of interval that will be added to each interval. A value of zero means there will be no jitter. The default value is 15%."
                },
                "connection_idle_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "If the connection has been idle for this duration, send a HTTP/2 ping ahead of new stream creation, to quickly detect dead connections. If this is zero, this type of PING will not be sent. If an interval ping is outstanding, a second ping will not be sent as the interval ping will determine if the connection is dead. The same feature for HTTP/3 is given by inheritance from QUICHE which uses :ref:`connection idle_timeout \u003cenvoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout\u003e` and the current PTO of the connection to decide whether to probe before sending a new request.",
                    "format": "regex"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Keepalive Settings"
        },
        "envoy.config.core.v3.Locality": {
            "properties": {
                "region": {
                    "type": "string",
                    "description": "Region this :ref:`zone \u003cenvoy_v3_api_field_config.core.v3.Locality.zone\u003e` belongs to."
                },
                "zone": {
                    "type": "string",
                    "description": "Defines the local service zone where Envoy is running. Though optional, it should be set if discovery service routing is used and the discovery service exposes :ref:`zone data \u003cenvoy_v3_api_field_config.endpoint.v3.LocalityLbEndpoints.locality\u003e`, either in this message or via :option:`--service-zone`. The meaning of zone is context dependent, e.g. `Availability Zone (AZ) \u003chttps://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html\u003e`_ on AWS, `Zone \u003chttps://cloud.google.com/compute/docs/regions-zones/\u003e`_ on GCP, etc."
                },
                "sub_zone": {
                    "type": "string",
                    "description": "When used for locality of upstream hosts, this field further splits zone into smaller chunks of sub-zones so they can be load balanced independently."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Locality",
            "description": "Identifies location of where either Envoy runs or where upstream hosts run."
        },
        "envoy.config.core.v3.Metadata": {
            "properties": {
                "filter_metadata": {
                    "additionalProperties": {
                        "additionalProperties": true,
                        "type": "object"
                    },
                    "type": "object",
                    "description": "Key is the reverse DNS filter name, e.g. com.acme.widget. The ``envoy.*`` namespace is reserved for Envoy's built-in filters. If both ``filter_metadata`` and :ref:`typed_filter_metadata \u003cenvoy_v3_api_field_config.core.v3.Metadata.typed_filter_metadata\u003e` fields are present in the metadata with same keys, only ``typed_filter_metadata`` field will be parsed."
                },
                "typed_filter_metadata": {
                    "additionalProperties": {
                        "properties": {
                            "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                            },
                            "value": {
                                "type": "string",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "format": "binary",
                                "binaryEncoding": "base64"
                            }
                        },
                        "additionalProperties": true,
                        "type": "object"
                    },
                    "type": "object",
                    "description": "Key is the reverse DNS filter name, e.g. com.acme.widget. The ``envoy.*`` namespace is reserved for Envoy's built-in filters. The value is encoded as google.protobuf.Any. If both :ref:`filter_metadata \u003cenvoy_v3_api_field_config.core.v3.Metadata.filter_metadata\u003e` and ``typed_filter_metadata`` fields are present in the metadata with same keys, only ``typed_filter_metadata`` field will be parsed."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Metadata provides additional inputs to filters based on matched listeners, filter chains, routes and endpoints. It is structured as a map, usually from filter name (in reverse DNS format) to metadata specific to the filter. Metadata key-values for a filter are merged as connection and request handling occurs, with later values for the same key overriding earlier values. An example use of metadata is providing additional values to http_connection_manager in the envoy.http_connection_manager.access_log namespace. Another example use of metadata is to per service config info in cluster metadata, which may get consumed by multiple filters. For load balancing, Metadata provides a means to subset cluster endpoints. Endpoints have a Metadata object associated and routes contain a Metadata object to match against. There are some well defined metadata used today for this purpose: * ``{\"envoy.lb\": {\"canary\": \u003cbool\u003e }}`` This indicates the canary status of an   endpoint and is also used during header processing   (x-envoy-upstream-canary) and for stats purposes. [#next-major-version: move to type/metadata/v2]"
        },
        "envoy.config.core.v3.Node": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "An opaque node identifier for the Envoy node. This also provides the local service node name. It should be set if any of the following features are used: :ref:`statsd \u003carch_overview_statistics\u003e`, :ref:`CDS \u003cconfig_cluster_manager_cds\u003e`, and :ref:`HTTP tracing \u003carch_overview_tracing\u003e`, either in this message or via :option:`--service-node`."
                },
                "cluster": {
                    "type": "string",
                    "description": "Defines the local service cluster name where Envoy is running. Though optional, it should be set if any of the following features are used: :ref:`statsd \u003carch_overview_statistics\u003e`, :ref:`health check cluster verification \u003cenvoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.service_name_matcher\u003e`, :ref:`runtime override directory \u003cenvoy_v3_api_msg_config.bootstrap.v3.Runtime\u003e`, :ref:`user agent addition \u003cenvoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.add_user_agent\u003e`, :ref:`HTTP global rate limiting \u003cconfig_http_filters_rate_limit\u003e`, :ref:`CDS \u003cconfig_cluster_manager_cds\u003e`, and :ref:`HTTP tracing \u003carch_overview_tracing\u003e`, either in this message or via :option:`--service-cluster`."
                },
                "metadata": {
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Opaque metadata extending the node identifier. Envoy will pass this directly to the management server."
                },
                "dynamic_parameters": {
                    "additionalProperties": {
                        "$ref": "#/definitions/xds.core.v3.ContextParams",
                        "additionalProperties": true
                    },
                    "type": "object",
                    "description": "Map from xDS resource type URL to dynamic context parameters. These may vary at runtime (unlike other fields in this message). For example, the xDS client may have a shard identifier that changes during the lifetime of the xDS client. In Envoy, this would be achieved by updating the dynamic context on the Server::Instance's LocalInfo context provider. The shard ID dynamic parameter then appears in this field during future discovery requests."
                },
                "locality": {
                    "$ref": "#/definitions/envoy.config.core.v3.Locality",
                    "additionalProperties": true,
                    "description": "Locality specifying where the Envoy instance is running."
                },
                "user_agent_name": {
                    "type": "string",
                    "description": "Free-form string that identifies the entity requesting config. E.g. \"envoy\" or \"grpc\""
                },
                "user_agent_version": {
                    "type": "string",
                    "description": "Free-form string that identifies the version of the entity requesting config. E.g. \"1.12.2\" or \"abcd1234\", or \"SpecialEnvoyBuild\""
                },
                "user_agent_build_version": {
                    "$ref": "#/definitions/envoy.config.core.v3.BuildVersion",
                    "additionalProperties": true,
                    "description": "Structured version of the entity requesting config."
                },
                "extensions": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.Extension"
                    },
                    "type": "array",
                    "description": "List of extensions and their versions supported by the node."
                },
                "client_features": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "Client feature support list. These are well known features described in the Envoy API repository for a given major version of an API. Client features use reverse DNS naming scheme, for example ``com.acme.feature``. See :ref:`the list of features \u003cclient_features\u003e` that xDS client may support."
                },
                "listening_addresses": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.Address"
                    },
                    "type": "array",
                    "description": "Known listening ports on the node as a generic hint to the management server for filtering :ref:`listeners \u003cconfig_listeners\u003e` to be returned. For example, if there is a listener bound to port 80, the list can optionally contain the SocketAddress ``(0.0.0.0,80)``. The field is optional and just a hint."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Node",
            "description": "Identifies a specific Envoy instance. The node identifier is presented to the management server, which may use this identifier to distinguish per Envoy configuration for serving. [#next-free-field: 13]"
        },
        "envoy.config.core.v3.PathConfigSource": {
            "properties": {
                "path": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Path on the filesystem to source and watch for configuration updates. When sourcing configuration for a :ref:`secret \u003cenvoy_v3_api_msg_extensions.transport_sockets.tls.v3.Secret\u003e`, the certificate and key files are also watched for updates. .. note::  The path to the source must exist at config load time. .. note::   If ``watched_directory`` is *not* configured, Envoy will watch the file path for *moves*.   This is because in general only moves are atomic. The same method of swapping files as is   demonstrated in the :ref:`runtime documentation \u003cconfig_runtime_symbolic_link_swap\u003e` can be   used here also. If ``watched_directory`` is configured, no watch will be placed directly on   this path. Instead, the configured ``watched_directory`` will be used to trigger reloads of   this path. This is required in certain deployment scenarios. See below for more information."
                },
                "watched_directory": {
                    "$ref": "#/definitions/envoy.config.core.v3.WatchedDirectory",
                    "additionalProperties": true,
                    "description": "If configured, this directory will be watched for *moves*. When an entry in this directory is moved to, the ``path`` will be reloaded. This is required in certain deployment scenarios. Specifically, if trying to load an xDS resource using a `Kubernetes ConfigMap \u003chttps://kubernetes.io/docs/concepts/configuration/configmap/\u003e`_, the following configuration might be used: 1. Store xds.yaml inside a ConfigMap. 2. Mount the ConfigMap to ``/config_map/xds`` 3. Configure path ``/config_map/xds/xds.yaml`` 4. Configure watched directory ``/config_map/xds`` The above configuration will ensure that Envoy watches the owning directory for moves which is required due to how Kubernetes manages ConfigMap symbolic links during atomic updates."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Path Config Source",
            "description": "Local filesystem path configuration source."
        },
        "envoy.config.core.v3.Pipe": {
            "properties": {
                "path": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Unix Domain Socket path. On Linux, paths starting with '@' will use the abstract namespace. The starting '@' is replaced by a null byte by Envoy. Paths starting with '@' will result in an error in environments other than Linux."
                },
                "mode": {
                    "type": "integer",
                    "description": "The mode for the Pipe. Not applicable for abstract sockets."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Network addresses]",
            "description": "[#protodoc-title: Network addresses]"
        },
        "envoy.config.core.v3.QuicKeepAliveSettings": {
            "properties": {
                "max_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The max interval for a connection to send keep-alive probing packets (with PING or PATH_RESPONSE). The value should be smaller than :ref:`connection idle_timeout \u003cenvoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout\u003e` to prevent idle timeout while not less than 1s to avoid throttling the connection or flooding the peer with probes. If :ref:`initial_interval \u003cenvoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.initial_interval\u003e` is absent or zero, a client connection will use this value to start probing. If zero, disable keepalive probing. If absent, use the QUICHE default interval to probe.",
                    "format": "regex"
                },
                "initial_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The interval to send the first few keep-alive probing packets to prevent connection from hitting the idle timeout. Subsequent probes will be sent, each one with an interval exponentially longer than previous one, till it reaches :ref:`max_interval \u003cenvoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval\u003e`. And the probes afterwards will always use :ref:`max_interval \u003cenvoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval\u003e`. The value should be smaller than :ref:`connection idle_timeout \u003cenvoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout\u003e` to prevent idle timeout and smaller than max_interval to take effect. If absent or zero, disable keepalive probing for a server connection. For a client connection, if :ref:`max_interval \u003cenvoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval\u003e`  is also zero, do not keepalive, otherwise use max_interval or QUICHE default to probe all the time.",
                    "format": "regex"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Quic Keep Alive Settings",
            "description": "Config for keepalive probes in a QUIC connection. Note that QUIC keep-alive probing packets work differently from HTTP/2 keep-alive PINGs in a sense that the probing packet itself doesn't timeout waiting for a probing response. Quic has a shorter idle timeout than TCP, so it doesn't rely on such probing to discover dead connections. If the peer fails to respond, the connection will idle timeout eventually. Thus, they are configured differently from :ref:`connection_keepalive \u003cenvoy_v3_api_field_config.core.v3.Http2ProtocolOptions.connection_keepalive\u003e`."
        },
        "envoy.config.core.v3.QuicProtocolOptions": {
            "properties": {
                "max_concurrent_streams": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Maximum number of streams that the client can negotiate per connection. 100 if not specified."
                },
                "initial_stream_window_size": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "`Initial stream-level flow-control receive window \u003chttps://tools.ietf.org/html/draft-ietf-quic-transport-34#section-4.1\u003e`_ size. Valid values range from 1 to 16777216 (2^24, maximum supported by QUICHE) and defaults to 16777216 (16 * 1024 * 1024). NOTE: 16384 (2^14) is the minimum window size supported in Google QUIC. If configured smaller than it, we will use 16384 instead. QUICHE IETF Quic implementation supports 1 bytes window. We only support increasing the default window size now, so it's also the minimum. This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the QUIC stream send and receive buffers. Once the buffer reaches this pointer, watermark callbacks will fire to stop the flow of data to the stream buffers."
                },
                "initial_connection_window_size": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Similar to ``initial_stream_window_size``, but for connection-level flow-control. Valid values rage from 1 to 25165824 (24MB, maximum supported by QUICHE) and defaults to 25165824 (24 * 1024 * 1024). NOTE: 16384 (2^14) is the minimum window size supported in Google QUIC. We only support increasing the default window size now, so it's also the minimum."
                },
                "num_timeouts_to_trigger_port_migration": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The number of timeouts that can occur before port migration is triggered for QUIC clients. This defaults to 4. If set to 0, port migration will not occur on path degrading. Timeout here refers to QUIC internal path degrading timeout mechanism, such as PTO. This has no effect on server sessions."
                },
                "connection_keepalive": {
                    "$ref": "#/definitions/envoy.config.core.v3.QuicKeepAliveSettings",
                    "additionalProperties": true,
                    "description": "Probes the peer at the configured interval to solicit traffic, i.e. ACK or PATH_RESPONSE, from the peer to push back connection idle timeout. If absent, use the default keepalive behavior of which a client connection sends PINGs every 15s, and a server connection doesn't do anything."
                },
                "connection_options": {
                    "type": "string",
                    "description": "A comma-separated list of strings representing QUIC connection options defined in `QUICHE \u003chttps://github.com/google/quiche/blob/main/quiche/quic/core/crypto/crypto_protocol.h\u003e`_ and to be sent by upstream connections."
                },
                "client_connection_options": {
                    "type": "string",
                    "description": "A comma-separated list of strings representing QUIC client connection options defined in `QUICHE \u003chttps://github.com/google/quiche/blob/main/quiche/quic/core/crypto/crypto_protocol.h\u003e`_ and to be sent by upstream connections."
                },
                "idle_network_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The duration that a QUIC connection stays idle before it closes itself. If this field is not present, QUICHE default 600s will be applied. For internal corporate network, a long timeout is often fine. But for client facing network, 30s is usually a good choice.",
                    "format": "regex"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Quic Protocol Options",
            "description": "QUIC protocol options which apply to both downstream and upstream connections. [#next-free-field: 9]"
        },
        "envoy.config.core.v3.RateLimitSettings": {
            "properties": {
                "max_tokens": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Maximum number of tokens to be used for rate limiting discovery request calls. If not set, a default value of 100 will be used."
                },
                "fill_rate": {
                    "additionalProperties": true,
                    "type": "number",
                    "description": "Rate at which tokens will be filled per second. If not set, a default fill rate of 10 tokens per second will be used. The minimal fill rate is once per year. Lower fill rates will be set to once per year."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Rate Limit Settings",
            "description": "Rate Limit settings to be applied for discovery requests made by Envoy."
        },
        "envoy.config.core.v3.RetryPolicy": {
            "properties": {
                "retry_back_off": {
                    "$ref": "#/definitions/envoy.config.core.v3.BackoffStrategy",
                    "additionalProperties": true,
                    "description": "Specifies parameters that control :ref:`retry backoff strategy \u003cenvoy_v3_api_msg_config.core.v3.BackoffStrategy\u003e`. This parameter is optional, in which case the default base interval is 1000 milliseconds. The default maximum interval is 10 times the base interval."
                },
                "num_retries": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Specifies the allowed number of retries. This parameter is optional and defaults to 1."
                },
                "retry_on": {
                    "type": "string",
                    "description": "For details, see :ref:`retry_on \u003cenvoy_v3_api_field_config.route.v3.RetryPolicy.retry_on\u003e`."
                },
                "retry_priority": {
                    "$ref": "#/definitions/envoy.config.core.v3.RetryPolicy.RetryPriority",
                    "additionalProperties": true,
                    "description": "For details, see :ref:`retry_priority \u003cenvoy_v3_api_field_config.route.v3.RetryPolicy.retry_priority\u003e`."
                },
                "retry_host_predicate": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.RetryPolicy.RetryHostPredicate"
                    },
                    "type": "array",
                    "description": "For details, see :ref:`RetryHostPredicate \u003cenvoy_v3_api_field_config.route.v3.RetryPolicy.retry_host_predicate\u003e`."
                },
                "host_selection_retry_max_attempts": {
                    "type": "string",
                    "description": "For details, see :ref:`host_selection_retry_max_attempts \u003cenvoy_v3_api_field_config.route.v3.RetryPolicy.host_selection_retry_max_attempts\u003e`."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Retry Policy",
            "description": "The message specifies the retry policy of remote data source when fetching fails. [#next-free-field: 7]"
        },
        "envoy.config.core.v3.RetryPolicy.RetryHostPredicate": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string"
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Retry Host Predicate",
            "description": "See :ref:`RetryHostPredicate \u003cenvoy_v3_api_field_config.route.v3.RetryPolicy.retry_host_predicate\u003e`."
        },
        "envoy.config.core.v3.RetryPolicy.RetryPriority": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string"
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Retry Priority",
            "description": "See :ref:`RetryPriority \u003cenvoy_v3_api_field_config.route.v3.RetryPolicy.retry_priority\u003e`."
        },
        "envoy.config.core.v3.RuntimeDouble": {
            "properties": {
                "default_value": {
                    "type": "number",
                    "description": "Default value if runtime value is not available."
                },
                "runtime_key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Runtime key to get value for comparison. This value is used if defined."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Runtime Double",
            "description": "Runtime derived double with a default when not specified."
        },
        "envoy.config.core.v3.RuntimeFeatureFlag": {
            "properties": {
                "default_value": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Default value if runtime value is not available."
                },
                "runtime_key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Runtime key to get value for comparison. This value is used if defined. The boolean value must be represented via its `canonical JSON encoding \u003chttps://developers.google.com/protocol-buffers/docs/proto3#json\u003e`_."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Runtime Feature Flag",
            "description": "Runtime derived bool with a default when not specified."
        },
        "envoy.config.core.v3.RuntimeUInt32": {
            "properties": {
                "default_value": {
                    "type": "integer",
                    "description": "Default value if runtime value is not available."
                },
                "runtime_key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Runtime key to get value for comparison. This value is used if defined."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Runtime U Int 32",
            "description": "Runtime derived uint32 with a default when not specified."
        },
        "envoy.config.core.v3.SelfConfigSource": {
            "properties": {
                "transport_api_version": {
                    "enum": [
                        "AUTO",
                        0,
                        "V2",
                        1,
                        "V3",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "[#protodoc-title: Configuration sources]",
                    "description": "[#protodoc-title: Configuration sources]  xDS API and non-xDS services version. This is used to describe both resource and transport protocol versions (in distinct configuration fields)."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Self Config Source",
            "description": "[#not-implemented-hide:] Self-referencing config source options. This is currently empty, but when set in :ref:`ConfigSource \u003cenvoy_v3_api_msg_config.core.v3.ConfigSource\u003e` can be used to specify that other data can be obtained from the same server."
        },
        "envoy.config.core.v3.SocketAddress": {
            "properties": {
                "protocol": {
                    "enum": [
                        "TCP",
                        0,
                        "UDP",
                        1
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Protocol"
                },
                "address": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The address for this socket. :ref:`Listeners \u003cconfig_listeners\u003e` will bind to the address. An empty address is not allowed. Specify ``0.0.0.0`` or ``::`` to bind to any address. [#comment:TODO(zuercher) reinstate when implemented: It is possible to distinguish a Listener address via the prefix/suffix matching in :ref:`FilterChainMatch \u003cenvoy_v3_api_msg_config.listener.v3.FilterChainMatch\u003e`.] When used within an upstream :ref:`BindConfig \u003cenvoy_v3_api_msg_config.core.v3.BindConfig\u003e`, the address controls the source address of outbound connections. For :ref:`clusters \u003cenvoy_v3_api_msg_config.cluster.v3.Cluster\u003e`, the cluster type determines whether the address must be an IP (``STATIC`` or ``EDS`` clusters) or a hostname resolved by DNS (``STRICT_DNS`` or ``LOGICAL_DNS`` clusters). Address resolution can be customized via :ref:`resolver_name \u003cenvoy_v3_api_field_config.core.v3.SocketAddress.resolver_name\u003e`."
                },
                "port_value": {
                    "type": "integer"
                },
                "named_port": {
                    "type": "string",
                    "description": "This is only valid if :ref:`resolver_name \u003cenvoy_v3_api_field_config.core.v3.SocketAddress.resolver_name\u003e` is specified below and the named resolver is capable of named port resolution."
                },
                "resolver_name": {
                    "type": "string",
                    "description": "The name of the custom resolver. This must have been registered with Envoy. If this is empty, a context dependent default applies. If the address is a concrete IP address, no resolution will occur. If address is a hostname this should be set for resolution other than DNS. Specifying a custom resolver with ``STRICT_DNS`` or ``LOGICAL_DNS`` will generate an error at runtime."
                },
                "ipv4_compat": {
                    "type": "boolean",
                    "description": "When binding to an IPv6 address above, this enables `IPv4 compatibility \u003chttps://tools.ietf.org/html/rfc3493#page-11\u003e`_. Binding to ``::`` will allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into IPv6 space as ``::FFFF:\u003cIPv4-address\u003e``."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Socket Address",
            "description": "[#next-free-field: 7]"
        },
        "envoy.config.core.v3.SocketOption": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "An optional name to give this socket option for debugging, etc. Uniqueness is not required and no special meaning is assumed."
                },
                "level": {
                    "type": "string",
                    "description": "Corresponding to the level value passed to setsockopt, such as IPPROTO_TCP"
                },
                "name": {
                    "type": "string",
                    "description": "The numeric name as passed to setsockopt"
                },
                "int_value": {
                    "type": "string",
                    "description": "Because many sockopts take an int value."
                },
                "buf_value": {
                    "type": "string",
                    "description": "Otherwise it's a byte buffer.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "state": {
                    "enum": [
                        "STATE_PREBIND",
                        0,
                        "STATE_BOUND",
                        1,
                        "STATE_LISTENING",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Socket State"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Socket option]",
            "description": "[#protodoc-title: Socket option]  Generic socket option message. This would be used to set socket options that might not exist in upstream kernels or precompiled Envoy binaries. For example: .. code-block:: json  {    \"description\": \"support tcp keep alive\",    \"state\": 0,    \"level\": 1,    \"name\": 9,    \"int_value\": 1,  } 1 means SOL_SOCKET and 9 means SO_KEEPALIVE on Linux. With the above configuration, `TCP Keep-Alives \u003chttps://www.freesoft.org/CIE/RFC/1122/114.htm\u003e`_ can be enabled in socket with Linux, which can be used in :ref:`listener's\u003cenvoy_v3_api_field_config.listener.v3.Listener.socket_options\u003e` or :ref:`admin's \u003cenvoy_v3_api_field_config.bootstrap.v3.Admin.socket_options\u003e` socket_options etc. It should be noted that the name or level may have different values on different platforms. [#next-free-field: 7]"
        },
        "envoy.config.core.v3.SocketOptionsOverride": {
            "properties": {
                "socket_options": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.SocketOption"
                    },
                    "type": "array"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Socket Options Override"
        },
        "envoy.config.core.v3.TcpKeepalive": {
            "properties": {
                "keepalive_probes": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Maximum number of keepalive probes to send without response before deciding the connection is dead. Default is to use the OS level configuration (unless overridden, Linux defaults to 9.)"
                },
                "keepalive_time": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The number of seconds a connection needs to be idle before keep-alive probes start being sent. Default is to use the OS level configuration (unless overridden, Linux defaults to 7200s (i.e., 2 hours.)"
                },
                "keepalive_interval": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The number of seconds between keep-alive probes. Default is to use the OS level configuration (unless overridden, Linux defaults to 75s.)"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Tcp Keepalive"
        },
        "envoy.config.core.v3.TransportSocket": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the transport socket to instantiate. The name must match a supported transport socket implementation."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Transport Socket",
            "description": "Configuration for transport socket in :ref:`listeners \u003cconfig_listeners\u003e` and :ref:`clusters \u003cenvoy_v3_api_msg_config.cluster.v3.Cluster\u003e`. If the configuration is empty, a default transport socket implementation and configuration will be chosen based on the platform and existence of tls_context."
        },
        "envoy.config.core.v3.TypedExtensionConfig": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of an extension. This is not used to select the extension, instead it serves the role of an opaque identifier."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "The typed config for the extension. The type URL will be used to identify the extension. In the case that the type URL is ``xds.type.v3.TypedStruct`` (or, for historical reasons, ``udpa.type.v1.TypedStruct``), the inner type URL of ``TypedStruct`` will be utilized. See the :ref:`extension configuration overview \u003cconfig_overview_extension_configuration\u003e` for further details."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Extension configuration]",
            "description": "[#protodoc-title: Extension configuration]  Message type for extension configuration. [#next-major-version: revisit all existing typed_config that doesn't use this wrapper.]."
        },
        "envoy.config.core.v3.UdpSocketConfig": {
            "properties": {
                "max_rx_datagram_size": {
                    "additionalProperties": true,
                    "type": "string",
                    "description": "The maximum size of received UDP datagrams. Using a larger size will cause Envoy to allocate more memory per socket. Received datagrams above this size will be dropped. If not set defaults to 1500 bytes."
                },
                "prefer_gro": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Configures whether Generic Receive Offload (GRO) \u003chttps://en.wikipedia.org/wiki/Large_receive_offload\u003e_ is preferred when reading from the UDP socket. The default is context dependent and is documented where UdpSocketConfig is used. This option affects performance but not functionality. If GRO is not supported by the operating system, non-GRO receive will be used."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: UDP socket config]",
            "description": "[#protodoc-title: UDP socket config]  Generic UDP socket configuration."
        },
        "envoy.config.core.v3.UpstreamHttpProtocolOptions": {
            "properties": {
                "auto_sni": {
                    "type": "boolean",
                    "description": "Set transport socket `SNI \u003chttps://en.wikipedia.org/wiki/Server_Name_Indication\u003e`_ for new upstream connections based on the downstream HTTP host/authority header or any other arbitrary header when :ref:`override_auto_sni_header \u003cenvoy_v3_api_field_config.core.v3.UpstreamHttpProtocolOptions.override_auto_sni_header\u003e` is set, as seen by the :ref:`router filter \u003cconfig_http_filters_router\u003e`. Does nothing if a filter before the http router filter sets the corresponding metadata."
                },
                "auto_san_validation": {
                    "type": "boolean",
                    "description": "Automatic validate upstream presented certificate for new upstream connections based on the downstream HTTP host/authority header or any other arbitrary header when :ref:`override_auto_sni_header \u003cenvoy_v3_api_field_config.core.v3.UpstreamHttpProtocolOptions.override_auto_sni_header\u003e` is set, as seen by the :ref:`router filter \u003cconfig_http_filters_router\u003e`. This field is intended to be set with ``auto_sni`` field. Does nothing if a filter before the http router filter sets the corresponding metadata."
                },
                "override_auto_sni_header": {
                    "type": "string",
                    "description": "An optional alternative to the host/authority header to be used for setting the SNI value. It should be a valid downstream HTTP header, as seen by the :ref:`router filter \u003cconfig_http_filters_router\u003e`. If unset, host/authority header will be used for populating the SNI. If the specified header is not found or the value is empty, host/authority header will be used instead. This field is intended to be set with ``auto_sni`` and/or ``auto_san_validation`` fields. If none of these fields are set then setting this would be a no-op. Does nothing if a filter before the http router filter sets the corresponding metadata."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Upstream Http Protocol Options"
        },
        "envoy.config.core.v3.WatchedDirectory": {
            "properties": {
                "path": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Directory path to watch."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Watched Directory",
            "description": "A directory that is watched for changes, e.g. by inotify on Linux. Move/rename events inside this directory trigger the watch."
        },
        "envoy.config.endpoint.v3.ClusterLoadAssignment": {
            "properties": {
                "cluster_name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Name of the cluster. This will be the :ref:`service_name \u003cenvoy_v3_api_field_config.cluster.v3.Cluster.EdsClusterConfig.service_name\u003e` value if specified in the cluster :ref:`EdsClusterConfig \u003cenvoy_v3_api_msg_config.cluster.v3.Cluster.EdsClusterConfig\u003e`."
                },
                "endpoints": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.endpoint.v3.LocalityLbEndpoints"
                    },
                    "type": "array",
                    "description": "List of endpoints to load balance to."
                },
                "named_endpoints": {
                    "additionalProperties": {
                        "$ref": "#/definitions/envoy.config.endpoint.v3.Endpoint",
                        "additionalProperties": true
                    },
                    "type": "object",
                    "description": "Map of named endpoints that can be referenced in LocalityLbEndpoints. [#not-implemented-hide:]"
                },
                "policy": {
                    "$ref": "#/definitions/envoy.config.endpoint.v3.ClusterLoadAssignment.Policy",
                    "additionalProperties": true,
                    "description": "Load balancing policy settings."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Endpoint configuration]\n Endpoint discovery :ref:`architecture overview \u003carch_overview_service_discovery_types_eds\u003e`",
            "description": "[#protodoc-title: Endpoint configuration] Endpoint discovery :ref:`architecture overview \u003carch_overview_service_discovery_types_eds\u003e`  Each route from RDS will map to a single cluster or traffic split across clusters using weights expressed in the RDS WeightedCluster. With EDS, each cluster is treated independently from a LB perspective, with LB taking place between the Localities within a cluster and at a finer granularity between the hosts within a locality. The percentage of traffic for each endpoint is determined by both its load_balancing_weight, and the load_balancing_weight of its locality. First, a locality will be selected, then an endpoint within that locality will be chose based on its weight. [#next-free-field: 6]"
        },
        "envoy.config.endpoint.v3.ClusterLoadAssignment.Policy": {
            "properties": {
                "drop_overloads": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.endpoint.v3.ClusterLoadAssignment.Policy.DropOverload"
                    },
                    "type": "array",
                    "description": "Action to trim the overall incoming traffic to protect the upstream hosts. This action allows protection in case the hosts are unable to recover from an outage, or unable to autoscale or unable to handle incoming traffic volume for any reason. At the client each category is applied one after the other to generate the 'actual' drop percentage on all outgoing traffic. For example: .. code-block:: json  { \"drop_overloads\": [      { \"category\": \"throttle\", \"drop_percentage\": 60 }      { \"category\": \"lb\", \"drop_percentage\": 50 }  ]} The actual drop percentages applied to the traffic at the clients will be    \"throttle\"_drop = 60%    \"lb\"_drop = 20%  // 50% of the remaining 'actual' load, which is 40%.    actual_outgoing_load = 20% // remaining after applying all categories. Envoy supports only one element and will NACK if more than one element is present. Other xDS-capable data planes will not necessarily have this limitation."
                },
                "overprovisioning_factor": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Priority levels and localities are considered overprovisioned with this factor (in percentage). This means that we don't consider a priority level or locality unhealthy until the fraction of healthy hosts multiplied by the overprovisioning factor drops below 100. With the default value 140(1.4), Envoy doesn't consider a priority level or a locality unhealthy until their percentage of healthy hosts drops below 72%. For example: .. code-block:: json  { \"overprovisioning_factor\": 100 } Read more at :ref:`priority levels \u003carch_overview_load_balancing_priority_levels\u003e` and :ref:`localities \u003carch_overview_load_balancing_locality_weighted_lb\u003e`."
                },
                "endpoint_stale_after": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The max time until which the endpoints from this assignment can be used. If no new assignments are received before this time expires the endpoints are considered stale and should be marked unhealthy. Defaults to 0 which means endpoints never go stale.",
                    "format": "regex"
                },
                "weighted_priority_health": {
                    "type": "boolean",
                    "description": "If true, use the :ref:`load balancing weight \u003cenvoy_v3_api_field_config.endpoint.v3.LbEndpoint.load_balancing_weight\u003e` of healthy and unhealthy hosts to determine the health of the priority level. If false, use the number of healthy and unhealthy hosts to determine the health of the priority level, or in other words assume each host has a weight of 1 for this calculation. Note: this is not currently implemented for :ref:`locality weighted load balancing \u003carch_overview_load_balancing_locality_weighted_lb\u003e`."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Policy",
            "description": "Load balancing policy settings. [#next-free-field: 7]"
        },
        "envoy.config.endpoint.v3.ClusterLoadAssignment.Policy.DropOverload": {
            "properties": {
                "category": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Identifier for the policy specifying the drop."
                },
                "drop_percentage": {
                    "$ref": "#/definitions/envoy.type.v3.FractionalPercent",
                    "additionalProperties": true,
                    "description": "Percentage of traffic that should be dropped for the category."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Drop Overload"
        },
        "envoy.config.endpoint.v3.Endpoint": {
            "properties": {
                "address": {
                    "$ref": "#/definitions/envoy.config.core.v3.Address",
                    "additionalProperties": true,
                    "description": "The upstream host address. .. attention::   The form of host address depends on the given cluster type. For STATIC or EDS,   it is expected to be a direct IP address (or something resolvable by the   specified :ref:`resolver \u003cenvoy_v3_api_field_config.core.v3.SocketAddress.resolver_name\u003e`   in the Address). For LOGICAL or STRICT DNS, it is expected to be hostname,   and will be resolved via DNS."
                },
                "health_check_config": {
                    "$ref": "#/definitions/envoy.config.endpoint.v3.Endpoint.HealthCheckConfig",
                    "additionalProperties": true,
                    "description": "The optional health check configuration is used as configuration for the health checker to contact the health checked host. .. attention::   This takes into effect only for upstream clusters with   :ref:`active health checking \u003carch_overview_health_checking\u003e` enabled."
                },
                "hostname": {
                    "type": "string",
                    "description": "The hostname associated with this endpoint. This hostname is not used for routing or address resolution. If provided, it will be associated with the endpoint, and can be used for features that require a hostname, like :ref:`auto_host_rewrite \u003cenvoy_v3_api_field_config.route.v3.RouteAction.auto_host_rewrite\u003e`."
                },
                "additional_addresses": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.endpoint.v3.Endpoint.AdditionalAddress"
                    },
                    "type": "array",
                    "description": "An ordered list of addresses that together with ``address`` comprise the list of addresses for an endpoint. The address given in the ``address`` is prepended to this list. It is assumed that the list must already be sorted by preference order of the addresses. This will only be supported for STATIC and EDS clusters."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Endpoints]",
            "description": "[#protodoc-title: Endpoints]  Upstream host identifier."
        },
        "envoy.config.endpoint.v3.Endpoint.AdditionalAddress": {
            "properties": {
                "address": {
                    "$ref": "#/definitions/envoy.config.core.v3.Address",
                    "additionalProperties": true,
                    "description": "Additional address that is associated with the endpoint."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Additional Address"
        },
        "envoy.config.endpoint.v3.Endpoint.HealthCheckConfig": {
            "properties": {
                "port_value": {
                    "type": "integer",
                    "description": "Optional alternative health check port value. By default the health check address port of an upstream host is the same as the host's serving address port. This provides an alternative health check port. Setting this with a non-zero value allows an upstream host to have different health check address port."
                },
                "hostname": {
                    "type": "string",
                    "description": "By default, the host header for L7 health checks is controlled by cluster level configuration (see: :ref:`host \u003cenvoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.host\u003e` and :ref:`authority \u003cenvoy_v3_api_field_config.core.v3.HealthCheck.GrpcHealthCheck.authority\u003e`). Setting this to a non-empty value allows overriding the cluster level configuration for a specific endpoint."
                },
                "address": {
                    "$ref": "#/definitions/envoy.config.core.v3.Address",
                    "additionalProperties": true,
                    "description": "Optional alternative health check host address. .. attention::   The form of the health check host address is expected to be a direct IP address."
                },
                "disable_active_health_check": {
                    "type": "boolean",
                    "description": "Optional flag to control if perform active health check for this endpoint. Active health check is enabled by default if there is a health checker."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Health Check Config",
            "description": "The optional health check configuration."
        },
        "envoy.config.endpoint.v3.LbEndpoint": {
            "properties": {
                "endpoint": {
                    "$ref": "#/definitions/envoy.config.endpoint.v3.Endpoint",
                    "additionalProperties": true
                },
                "endpoint_name": {
                    "type": "string",
                    "description": "[#not-implemented-hide:]"
                },
                "health_status": {
                    "enum": [
                        "UNKNOWN",
                        0,
                        "HEALTHY",
                        1,
                        "UNHEALTHY",
                        2,
                        "DRAINING",
                        3,
                        "TIMEOUT",
                        4,
                        "DEGRADED",
                        5
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "[#protodoc-title: Health check]\n * Health checking :ref:`architecture overview \u003carch_overview_health_checking\u003e`.\n * If health checking is configured for a cluster, additional statistics are emitted. They are\n   documented :ref:`here \u003cconfig_cluster_manager_cluster_stats\u003e`.",
                    "description": "[#protodoc-title: Health check] * Health checking :ref:`architecture overview \u003carch_overview_health_checking\u003e`. * If health checking is configured for a cluster, additional statistics are emitted. They are   documented :ref:`here \u003cconfig_cluster_manager_cluster_stats\u003e`.  Endpoint health status."
                },
                "metadata": {
                    "$ref": "#/definitions/envoy.config.core.v3.Metadata",
                    "additionalProperties": true,
                    "description": "The endpoint metadata specifies values that may be used by the load balancer to select endpoints in a cluster for a given request. The filter name should be specified as ``envoy.lb``. An example boolean key-value pair is ``canary``, providing the optional canary status of the upstream host. This may be matched against in a route's :ref:`RouteAction \u003cenvoy_v3_api_msg_config.route.v3.RouteAction\u003e` metadata_match field to subset the endpoints considered in cluster load balancing."
                },
                "load_balancing_weight": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The optional load balancing weight of the upstream host; at least 1. Envoy uses the load balancing weight in some of the built in load balancers. The load balancing weight for an endpoint is divided by the sum of the weights of all endpoints in the endpoint's locality to produce a percentage of traffic for the endpoint. This percentage is then further weighted by the endpoint's locality's load balancing weight from LocalityLbEndpoints. If unspecified, will be treated as 1. The sum of the weights of all endpoints in the endpoint's locality must not exceed uint32_t maximal value (4294967295)."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Lb Endpoint",
            "description": "An Endpoint that Envoy can route traffic to. [#next-free-field: 6]"
        },
        "envoy.config.endpoint.v3.LedsClusterLocalityConfig": {
            "properties": {
                "leds_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.ConfigSource",
                    "additionalProperties": true,
                    "description": "Configuration for the source of LEDS updates for a Locality."
                },
                "leds_collection_name": {
                    "type": "string",
                    "description": "The xDS transport protocol glob collection resource name. The service is only supported in delta xDS (incremental) mode."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Leds Cluster Locality Config",
            "description": "[#not-implemented-hide:] A configuration for a LEDS collection."
        },
        "envoy.config.endpoint.v3.LocalityLbEndpoints": {
            "properties": {
                "locality": {
                    "$ref": "#/definitions/envoy.config.core.v3.Locality",
                    "additionalProperties": true,
                    "description": "Identifies location of where the upstream hosts run."
                },
                "lb_endpoints": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.endpoint.v3.LbEndpoint"
                    },
                    "type": "array",
                    "description": "The group of endpoints belonging to the locality specified. [#comment:TODO(adisuissa): Once LEDS is implemented this field needs to be deprecated and replaced by ``load_balancer_endpoints``.]"
                },
                "load_balancer_endpoints": {
                    "$ref": "#/definitions/envoy.config.endpoint.v3.LocalityLbEndpoints.LbEndpointList",
                    "additionalProperties": true,
                    "description": "The group of endpoints belonging to the locality. [#comment:TODO(adisuissa): Once LEDS is implemented the ``lb_endpoints`` field needs to be deprecated.]"
                },
                "leds_cluster_locality_config": {
                    "$ref": "#/definitions/envoy.config.endpoint.v3.LedsClusterLocalityConfig",
                    "additionalProperties": true,
                    "description": "LEDS Configuration for the current locality."
                },
                "load_balancing_weight": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Optional: Per priority/region/zone/sub_zone weight; at least 1. The load balancing weight for a locality is divided by the sum of the weights of all localities  at the same priority level to produce the effective percentage of traffic for the locality. The sum of the weights of all localities at the same priority level must not exceed uint32_t maximal value (4294967295). Locality weights are only considered when :ref:`locality weighted load balancing \u003carch_overview_load_balancing_locality_weighted_lb\u003e` is configured. These weights are ignored otherwise. If no weights are specified when locality weighted load balancing is enabled, the locality is assigned no load."
                },
                "priority": {
                    "type": "integer",
                    "description": "Optional: the priority for this LocalityLbEndpoints. If unspecified this will default to the highest priority (0). Under usual circumstances, Envoy will only select endpoints for the highest priority (0). In the event that enough endpoints for a particular priority are unavailable/unhealthy, Envoy will fail over to selecting endpoints for the next highest priority group. Read more at :ref:`priority levels \u003carch_overview_load_balancing_priority_levels\u003e`. Priorities should range from 0 (highest) to N (lowest) without skipping."
                },
                "proximity": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Optional: Per locality proximity value which indicates how close this locality is from the source locality. This value only provides ordering information (lower the value, closer it is to the source locality). This will be consumed by load balancing schemes that need proximity order to determine where to route the requests. [#not-implemented-hide:]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Locality Lb Endpoints",
            "description": "A group of endpoints belonging to a Locality. One can have multiple LocalityLbEndpoints for a locality, but only if they have different priorities. [#next-free-field: 9]"
        },
        "envoy.config.endpoint.v3.LocalityLbEndpoints.LbEndpointList": {
            "properties": {
                "lb_endpoints": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.endpoint.v3.LbEndpoint"
                    },
                    "type": "array"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Lb Endpoint List",
            "description": "[#not-implemented-hide:] A list of endpoints of a specific locality."
        },
        "envoy.config.listener.v3.AdditionalAddress": {
            "properties": {
                "address": {
                    "$ref": "#/definitions/envoy.config.core.v3.Address",
                    "additionalProperties": true
                },
                "socket_options": {
                    "$ref": "#/definitions/envoy.config.core.v3.SocketOptionsOverride",
                    "additionalProperties": true,
                    "description": "Additional socket options that may not be present in Envoy source code or precompiled binaries. If specified, this will override the :ref:`socket_options \u003cenvoy_v3_api_field_config.listener.v3.Listener.socket_options\u003e` in the listener. If specified with no :ref:`socket_options \u003cenvoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options\u003e` or an empty list of :ref:`socket_options \u003cenvoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options\u003e`, it means no socket option will apply."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Listener configuration]\n Listener :ref:`configuration overview \u003cconfig_listeners\u003e`",
            "description": "[#protodoc-title: Listener configuration] Listener :ref:`configuration overview \u003cconfig_listeners\u003e`  The additional address the listener is listening on."
        },
        "envoy.config.listener.v3.ApiListener": {
            "properties": {
                "api_listener": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "The type in this field determines the type of API listener. At present, the following types are supported: envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager (HTTP) envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager (HTTP) [#next-major-version: In the v3 API, replace this Any field with a oneof containing the specific config message for each type of API listener. We could not do this in v2 because it would have caused circular dependencies for go protos: lds.proto depends on this file, and http_connection_manager.proto depends on rds.proto, which is in the same directory as lds.proto, so lds.proto cannot depend on this file.]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: API listener]",
            "description": "[#protodoc-title: API listener]  Describes a type of API listener, which is used in non-proxy clients. The type of API exposed to the non-proxy application depends on the type of API listener."
        },
        "envoy.config.listener.v3.Filter": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the filter configuration."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Filter specific configuration which depends on the filter being instantiated. See the supported filters for further documentation. [#extension-category: envoy.filters.network]"
                },
                "config_discovery": {
                    "$ref": "#/definitions/envoy.config.core.v3.ExtensionConfigSource",
                    "additionalProperties": true,
                    "description": "Configuration source specifier for an extension configuration discovery service. In case of a failure and without the default configuration, the listener closes the connections."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Listener components]\n Listener :ref:`configuration overview \u003cconfig_listeners\u003e`",
            "description": "[#protodoc-title: Listener components] Listener :ref:`configuration overview \u003cconfig_listeners\u003e`  [#next-free-field: 6]"
        },
        "envoy.config.listener.v3.FilterChain": {
            "properties": {
                "filter_chain_match": {
                    "$ref": "#/definitions/envoy.config.listener.v3.FilterChainMatch",
                    "additionalProperties": true,
                    "description": "The criteria to use when matching a connection to this filter chain."
                },
                "filters": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.listener.v3.Filter"
                    },
                    "type": "array",
                    "description": "A list of individual network filters that make up the filter chain for connections established with the listener. Order matters as the filters are processed sequentially as connection events happen. Note: If the filter list is empty, the connection will close by default. For QUIC listeners, network filters other than HTTP Connection Manager (HCM) can be created, but due to differences in the connection implementation compared to TCP, the onData() method will never be called. Therefore, network filters for QUIC listeners should only expect to do work at the start of a new connection (i.e. in onNewConnection()). HCM must be the last (or only) filter in the chain."
                },
                "use_proxy_proto": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Whether the listener should expect a PROXY protocol V1 header on new connections. If this option is enabled, the listener will assume that that remote address of the connection is the one specified in the header. Some load balancers including the AWS ELB support this option. If the option is absent or set to false, Envoy will use the physical peer address of the connection as the remote address. This field is deprecated. Add a :ref:`PROXY protocol listener filter \u003cconfig_listener_filters_proxy_protocol\u003e` explicitly instead."
                },
                "metadata": {
                    "$ref": "#/definitions/envoy.config.core.v3.Metadata",
                    "additionalProperties": true,
                    "description": "[#not-implemented-hide:] filter chain metadata."
                },
                "transport_socket": {
                    "$ref": "#/definitions/envoy.config.core.v3.TransportSocket",
                    "additionalProperties": true,
                    "description": "Optional custom transport socket implementation to use for downstream connections. To setup TLS, set a transport socket with name ``envoy.transport_sockets.tls`` and :ref:`DownstreamTlsContext \u003cenvoy_v3_api_msg_extensions.transport_sockets.tls.v3.DownstreamTlsContext\u003e` in the ``typed_config``. If no transport socket configuration is specified, new connections will be set up with plaintext. [#extension-category: envoy.transport_sockets.downstream]"
                },
                "transport_socket_connect_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "If present and nonzero, the amount of time to allow incoming connections to complete any transport socket negotiations. If this expires before the transport reports connection establishment, the connection is summarily closed.",
                    "format": "regex"
                },
                "name": {
                    "type": "string",
                    "description": "The unique name (or empty) by which this filter chain is known. Note: :ref:`filter_chain_matcher \u003cenvoy_v3_api_field_config.listener.v3.Listener.filter_chain_matcher\u003e` requires that filter chains are uniquely named within a listener."
                },
                "on_demand_configuration": {
                    "$ref": "#/definitions/envoy.config.listener.v3.FilterChain.OnDemandConfiguration",
                    "additionalProperties": true,
                    "description": "[#not-implemented-hide:] The configuration to specify whether the filter chain will be built on-demand. If this field is not empty, the filter chain will be built on-demand. Otherwise, the filter chain will be built normally and block listener warming."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Filter Chain",
            "description": "A filter chain wraps a set of match criteria, an option TLS context, a set of filters, and various other parameters. [#next-free-field: 10]"
        },
        "envoy.config.listener.v3.FilterChain.OnDemandConfiguration": {
            "properties": {
                "rebuild_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The timeout to wait for filter chain placeholders to complete rebuilding. 1. If this field is set to 0, timeout is disabled. 2. If not specified, a default timeout of 15s is used. Rebuilding will wait until dependencies are ready, have failed, or this timeout is reached. Upon failure or timeout, all connections related to this filter chain will be closed. Rebuilding will start again on the next new connection.",
                    "format": "regex"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "On Demand Configuration",
            "description": "The configuration for on-demand filter chain. If this field is not empty in FilterChain message, a filter chain will be built on-demand. On-demand filter chains help speedup the warming up of listeners since the building and initialization of an on-demand filter chain will be postponed to the arrival of new connection requests that require this filter chain. Filter chains that are not often used can be set as on-demand."
        },
        "envoy.config.listener.v3.FilterChainMatch": {
            "properties": {
                "destination_port": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Optional destination port to consider when use_original_dst is set on the listener in determining a filter chain match."
                },
                "prefix_ranges": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.CidrRange"
                    },
                    "type": "array",
                    "description": "If non-empty, an IP address and prefix length to match addresses when the listener is bound to 0.0.0.0/:: or when use_original_dst is specified."
                },
                "address_suffix": {
                    "type": "string",
                    "description": "If non-empty, an IP address and suffix length to match addresses when the listener is bound to 0.0.0.0/:: or when use_original_dst is specified. [#not-implemented-hide:]"
                },
                "suffix_len": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "[#not-implemented-hide:]"
                },
                "direct_source_prefix_ranges": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.CidrRange"
                    },
                    "type": "array",
                    "description": "The criteria is satisfied if the directly connected source IP address of the downstream connection is contained in at least one of the specified subnets. If the parameter is not specified or the list is empty, the directly connected source IP address is ignored."
                },
                "source_type": {
                    "enum": [
                        "ANY",
                        0,
                        "SAME_IP_OR_LOOPBACK",
                        1,
                        "EXTERNAL",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Connection Source Type"
                },
                "source_prefix_ranges": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.CidrRange"
                    },
                    "type": "array",
                    "description": "The criteria is satisfied if the source IP address of the downstream connection is contained in at least one of the specified subnets. If the parameter is not specified or the list is empty, the source IP address is ignored."
                },
                "source_ports": {
                    "items": {
                        "type": "integer"
                    },
                    "type": "array",
                    "description": "The criteria is satisfied if the source port of the downstream connection is contained in at least one of the specified ports. If the parameter is not specified, the source port is ignored."
                },
                "server_names": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "If non-empty, a list of server names (e.g. SNI for TLS protocol) to consider when determining a filter chain match. Those values will be compared against the server names of a new connection, when detected by one of the listener filters. The server name will be matched against all wildcard domains, i.e. ``www.example.com`` will be first matched against ``www.example.com``, then ``*.example.com``, then ``*.com``. Note that partial wildcards are not supported, and values like ``*w.example.com`` are invalid. The value ``*`` is also not supported, and ``server_names`` should be omitted instead. .. attention::   See the :ref:`FAQ entry \u003cfaq_how_to_setup_sni\u003e` on how to configure SNI for more   information."
                },
                "transport_protocol": {
                    "type": "string",
                    "description": "If non-empty, a transport protocol to consider when determining a filter chain match. This value will be compared against the transport protocol of a new connection, when it's detected by one of the listener filters. Suggested values include: * ``raw_buffer`` - default, used when no transport protocol is detected, * ``tls`` - set by :ref:`envoy.filters.listener.tls_inspector \u003cconfig_listener_filters_tls_inspector\u003e`   when TLS protocol is detected."
                },
                "application_protocols": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "If non-empty, a list of application protocols (e.g. ALPN for TLS protocol) to consider when determining a filter chain match. Those values will be compared against the application protocols of a new connection, when detected by one of the listener filters. Suggested values include: * ``http/1.1`` - set by :ref:`envoy.filters.listener.tls_inspector   \u003cconfig_listener_filters_tls_inspector\u003e`, * ``h2`` - set by :ref:`envoy.filters.listener.tls_inspector \u003cconfig_listener_filters_tls_inspector\u003e` .. attention::   Currently, only :ref:`TLS Inspector \u003cconfig_listener_filters_tls_inspector\u003e` provides   application protocol detection based on the requested   `ALPN \u003chttps://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation\u003e`_ values.   However, the use of ALPN is pretty much limited to the HTTP/2 traffic on the Internet,   and matching on values other than ``h2`` is going to lead to a lot of false negatives,   unless all connecting clients are known to use ALPN."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Filter Chain Match",
            "description": "Specifies the match criteria for selecting a specific filter chain for a listener. In order for a filter chain to be selected, *ALL* of its criteria must be fulfilled by the incoming connection, properties of which are set by the networking stack and/or listener filters. The following order applies: 1. Destination port. 2. Destination IP address. 3. Server name (e.g. SNI for TLS protocol), 4. Transport protocol. 5. Application protocols (e.g. ALPN for TLS protocol). 6. Directly connected source IP address (this will only be different from the source IP address    when using a listener filter that overrides the source address, such as the :ref:`Proxy Protocol    listener filter \u003cconfig_listener_filters_proxy_protocol\u003e`). 7. Source type (e.g. any, local or external network). 8. Source IP address. 9. Source port. For criteria that allow ranges or wildcards, the most specific value in any of the configured filter chains that matches the incoming connection is going to be used (e.g. for SNI ``www.example.com`` the most specific match would be ``www.example.com``, then ``*.example.com``, then ``*.com``, then any filter chain without ``server_names`` requirements). A different way to reason about the filter chain matches: Suppose there exists N filter chains. Prune the filter chain set using the above 8 steps. In each step, filter chains which most specifically matches the attributes continue to the next step. The listener guarantees at most 1 filter chain is left after all of the steps. Example: For destination port, filter chains specifying the destination port of incoming traffic are the most specific match. If none of the filter chains specifies the exact destination port, the filter chains which do not specify ports are the most specific match. Filter chains specifying the wrong port can never be the most specific match. [#comment: Implemented rules are kept in the preference order, with deprecated fields listed at the end, because that's how we want to list them in the docs. [#comment:TODO(PiotrSikora): Add support for configurable precedence of the rules] [#next-free-field: 14]"
        },
        "envoy.config.listener.v3.Listener": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The unique name by which this listener is known. If no name is provided, Envoy will allocate an internal UUID for the listener. If the listener is to be dynamically updated or removed via :ref:`LDS \u003cconfig_listeners_lds\u003e` a unique name must be provided."
                },
                "address": {
                    "$ref": "#/definitions/envoy.config.core.v3.Address",
                    "additionalProperties": true,
                    "description": "The address that the listener should listen on. In general, the address must be unique, though that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on Linux as the actual port will be allocated by the OS. Required unless ``api_listener`` or ``listener_specifier`` is populated."
                },
                "additional_addresses": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.listener.v3.AdditionalAddress"
                    },
                    "type": "array",
                    "description": "The additional addresses the listener should listen on. The addresses must be unique across all listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener, all addresses use the same protocol, and multiple internal addresses are not supported."
                },
                "stat_prefix": {
                    "type": "string",
                    "description": "Optional prefix to use on listener stats. If empty, the stats will be rooted at ``listener.\u003caddress as string\u003e.``. If non-empty, stats will be rooted at ``listener.\u003cstat_prefix\u003e.``."
                },
                "filter_chains": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.listener.v3.FilterChain"
                    },
                    "type": "array",
                    "description": "A list of filter chains to consider for this listener. The :ref:`FilterChain \u003cenvoy_v3_api_msg_config.listener.v3.FilterChain\u003e` with the most specific :ref:`FilterChainMatch \u003cenvoy_v3_api_msg_config.listener.v3.FilterChainMatch\u003e` criteria is used on a connection. Example using SNI for filter chain selection can be found in the :ref:`FAQ entry \u003cfaq_how_to_setup_sni\u003e`."
                },
                "filter_chain_matcher": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher",
                    "additionalProperties": true,
                    "description": ":ref:`Matcher API \u003carch_overview_matching_listener\u003e` resolving the filter chain name from the network properties. This matcher is used as a replacement for the filter chain match condition :ref:`filter_chain_match \u003cenvoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match\u003e`. If specified, all :ref:`filter_chains \u003cenvoy_v3_api_field_config.listener.v3.Listener.filter_chains\u003e` must have a non-empty and unique :ref:`name \u003cenvoy_v3_api_field_config.listener.v3.FilterChain.name\u003e` field and not specify :ref:`filter_chain_match \u003cenvoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match\u003e` field. .. note::  Once matched, each connection is permanently bound to its filter chain.  If the matcher changes but the filter chain remains the same, the  connections bound to the filter chain are not drained. If, however, the  filter chain is removed or structurally modified, then the drain for its  connections is initiated."
                },
                "use_original_dst": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "If a connection is redirected using ``iptables``, the port on which the proxy receives it might be different from the original destination address. When this flag is set to true, the listener hands off redirected connections to the listener associated with the original destination address. If there is no listener associated with the original destination address, the connection is handled by the listener that receives it. Defaults to false."
                },
                "default_filter_chain": {
                    "$ref": "#/definitions/envoy.config.listener.v3.FilterChain",
                    "additionalProperties": true,
                    "description": "The default filter chain if none of the filter chain matches. If no default filter chain is supplied, the connection will be closed. The filter chain match is ignored in this field."
                },
                "per_connection_buffer_limit_bytes": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Soft limit on size of the listener’s new connection read and write buffers. If unspecified, an implementation defined default is applied (1MiB)."
                },
                "metadata": {
                    "$ref": "#/definitions/envoy.config.core.v3.Metadata",
                    "additionalProperties": true,
                    "description": "Listener metadata."
                },
                "deprecated_v1": {
                    "$ref": "#/definitions/envoy.config.listener.v3.Listener.DeprecatedV1",
                    "additionalProperties": true,
                    "description": "[#not-implemented-hide:]"
                },
                "drain_type": {
                    "enum": [
                        "DEFAULT",
                        0,
                        "MODIFY_ONLY",
                        1
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Drain Type"
                },
                "listener_filters": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.listener.v3.ListenerFilter"
                    },
                    "type": "array",
                    "description": "Listener filters have the opportunity to manipulate and augment the connection metadata that is used in connection filter chain matching, for example. These filters are run before any in :ref:`filter_chains \u003cenvoy_v3_api_field_config.listener.v3.Listener.filter_chains\u003e`. Order matters as the filters are processed sequentially right after a socket has been accepted by the listener, and before a connection is created. UDP Listener filters can be specified when the protocol in the listener socket address in :ref:`protocol \u003cenvoy_v3_api_field_config.core.v3.SocketAddress.protocol\u003e` is :ref:`UDP \u003cenvoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP\u003e` and no :ref:`quic_options \u003cenvoy_v3_api_field_config.listener.v3.UdpListenerConfig.quic_options\u003e` is specified in :ref:`udp_listener_config \u003cenvoy_v3_api_field_config.listener.v3.Listener.udp_listener_config\u003e`. QUIC listener filters can be specified when :ref:`quic_options \u003cenvoy_v3_api_field_config.listener.v3.UdpListenerConfig.quic_options\u003e` is specified in :ref:`udp_listener_config \u003cenvoy_v3_api_field_config.listener.v3.Listener.udp_listener_config\u003e`. They are processed sequentially right before connection creation. And like TCP Listener filters, they can be used to manipulate the connection metadata and socket. But the difference is that they can't be used to pause connection creation."
                },
                "listener_filters_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The timeout to wait for all listener filters to complete operation. If the timeout is reached, the accepted socket is closed without a connection being created unless ``continue_on_listener_filters_timeout`` is set to true. Specify 0 to disable the timeout. If not specified, a default timeout of 15s is used.",
                    "format": "regex"
                },
                "continue_on_listener_filters_timeout": {
                    "type": "boolean",
                    "description": "Whether a connection should be created when listener filters timeout. Default is false. .. attention::   Some listener filters, such as :ref:`Proxy Protocol filter   \u003cconfig_listener_filters_proxy_protocol\u003e`, should not be used with this option. It will cause   unexpected behavior when a connection is created."
                },
                "transparent": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Whether the listener should be set as a transparent socket. When this flag is set to true, connections can be redirected to the listener using an ``iptables`` ``TPROXY`` target, in which case the original source and destination addresses and ports are preserved on accepted connections. This flag should be used in combination with :ref:`an original_dst \u003cconfig_listener_filters_original_dst\u003e` :ref:`listener filter \u003cenvoy_v3_api_field_config.listener.v3.Listener.listener_filters\u003e` to mark the connections' local addresses as \"restored.\" This can be used to hand off each redirected connection to another listener associated with the connection's destination address. Direct connections to the socket without using ``TPROXY`` cannot be distinguished from connections redirected using ``TPROXY`` and are therefore treated as if they were redirected. When this flag is set to false, the listener's socket is explicitly reset as non-transparent. Setting this flag requires Envoy to run with the ``CAP_NET_ADMIN`` capability. When this flag is not set (default), the socket is not modified, i.e. the transparent option is neither set nor reset."
                },
                "freebind": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Whether the listener should set the ``IP_FREEBIND`` socket option. When this flag is set to true, listeners can be bound to an IP address that is not configured on the system running Envoy. When this flag is set to false, the option ``IP_FREEBIND`` is disabled on the socket. When this flag is not set (default), the socket is not modified, i.e. the option is neither enabled nor disabled."
                },
                "socket_options": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.SocketOption"
                    },
                    "type": "array",
                    "description": "Additional socket options that may not be present in Envoy source code or precompiled binaries. The socket options can be updated for a listener when :ref:`enable_reuse_port \u003cenvoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port\u003e` is ``true``. Otherwise, if socket options change during a listener update the update will be rejected to make it clear that the options were not updated."
                },
                "tcp_fast_open_queue_length": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Whether the listener should accept TCP Fast Open (TFO) connections. When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on the socket, with a queue length of the specified size (see `details in RFC7413 \u003chttps://tools.ietf.org/html/rfc7413#section-5.1\u003e`_). When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket. When this flag is not set (default), the socket is not modified, i.e. the option is neither enabled nor disabled. On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable TCP_FASTOPEN. See `ip-sysctl.txt \u003chttps://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt\u003e`_. On macOS, only values of 0, 1, and unset are valid; other values may result in an error. To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter."
                },
                "traffic_direction": {
                    "enum": [
                        "UNSPECIFIED",
                        0,
                        "INBOUND",
                        1,
                        "OUTBOUND",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Traffic Direction",
                    "description": "Identifies the direction of the traffic relative to the local Envoy."
                },
                "udp_listener_config": {
                    "$ref": "#/definitions/envoy.config.listener.v3.UdpListenerConfig",
                    "additionalProperties": true,
                    "description": "If the protocol in the listener socket address in :ref:`protocol \u003cenvoy_v3_api_field_config.core.v3.SocketAddress.protocol\u003e` is :ref:`UDP \u003cenvoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP\u003e`, this field specifies UDP listener specific configuration."
                },
                "api_listener": {
                    "$ref": "#/definitions/envoy.config.listener.v3.ApiListener",
                    "additionalProperties": true,
                    "description": "Used to represent an API listener, which is used in non-proxy clients. The type of API exposed to the non-proxy application depends on the type of API listener. When this field is set, no other field except for :ref:`name\u003cenvoy_v3_api_field_config.listener.v3.Listener.name\u003e` should be set. .. note::  Currently only one ApiListener can be installed; and it can only be done via bootstrap config,  not LDS. [#next-major-version: In the v3 API, instead of this messy approach where the socket listener fields are directly in the top-level Listener message and the API listener types are in the ApiListener message, the socket listener messages should be in their own message, and the top-level Listener should essentially be a oneof that selects between the socket listener and the various types of API listener. That way, a given Listener message can structurally only contain the fields of the relevant type.]"
                },
                "connection_balance_config": {
                    "$ref": "#/definitions/envoy.config.listener.v3.Listener.ConnectionBalanceConfig",
                    "additionalProperties": true,
                    "description": "The listener's connection balancer configuration, currently only applicable to TCP listeners. If no configuration is specified, Envoy will not attempt to balance active connections between worker threads. In the scenario that the listener X redirects all the connections to the listeners Y1 and Y2 by setting :ref:`use_original_dst \u003cenvoy_v3_api_field_config.listener.v3.Listener.use_original_dst\u003e` in X and :ref:`bind_to_port \u003cenvoy_v3_api_field_config.listener.v3.Listener.bind_to_port\u003e` to false in Y1 and Y2, it is recommended to disable the balance config in listener X to avoid the cost of balancing, and enable the balance config in Y1 and Y2 to balance the connections among the workers."
                },
                "reuse_port": {
                    "type": "boolean",
                    "description": "Deprecated. Use ``enable_reuse_port`` instead."
                },
                "enable_reuse_port": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "When this flag is set to true, listeners set the ``SO_REUSEPORT`` socket option and create one socket for each worker thread. This makes inbound connections distribute among worker threads roughly evenly in cases where there are a high number of connections. When this flag is set to false, all worker threads share one socket. This field defaults to true. The change of field will be rejected during an listener update when the runtime flag ``envoy.reloadable_features.enable_update_listener_socket_options`` is enabled. Otherwise, the update of this field will be ignored quietly. .. attention::   Although this field defaults to true, it has different behavior on different platforms. See   the following text for more information. * On Linux, reuse_port is respected for both TCP and UDP listeners. It also works correctly   with hot restart. * On macOS, reuse_port for TCP does not do what it does on Linux. Instead of load balancing,   the last socket wins and receives all connections/packets. For TCP, reuse_port is force   disabled and the user is warned. For UDP, it is enabled, but only one worker will receive   packets. For QUIC/H3, SW routing will send packets to other workers. For \"raw\" UDP, only   a single worker will currently receive packets. * On Windows, reuse_port for TCP has undefined behavior. It is force disabled and the user   is warned similar to macOS. It is left enabled for UDP with undefined behavior currently."
                },
                "access_log": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.accesslog.v3.AccessLog"
                    },
                    "type": "array",
                    "description": "Configuration for :ref:`access logs \u003carch_overview_access_logs\u003e` emitted by this listener."
                },
                "tcp_backlog_size": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The maximum length a tcp listener's pending connections queue can grow to. If no value is provided net.core.somaxconn will be used on Linux and 128 otherwise."
                },
                "max_connections_to_accept_per_socket_event": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "The maximum number of connections to accept from the kernel per socket event. Envoy may decide to close these connections after accepting them from the kernel e.g. due to load shedding, or other policies. If there are more than max_connections_to_accept_per_socket_event connections pending accept, connections over this threshold will be accepted in later event loop iterations. If no value is provided Envoy will accept all connections pending accept from the kernel."
                },
                "bind_to_port": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Whether the listener should bind to the port. A listener that doesn't bind can only receive connections redirected from other listeners that set :ref:`use_original_dst \u003cenvoy_v3_api_field_config.listener.v3.Listener.use_original_dst\u003e` to true. Default is true."
                },
                "internal_listener": {
                    "$ref": "#/definitions/envoy.config.listener.v3.Listener.InternalListenerConfig",
                    "additionalProperties": true,
                    "description": "Used to represent an internal listener which does not listen on OSI L4 address but can be used by the :ref:`envoy cluster \u003cenvoy_v3_api_msg_config.cluster.v3.Cluster\u003e` to create a user space connection to. The internal listener acts as a TCP listener. It supports listener filters and network filter chains. Upstream clusters refer to the internal listeners by their :ref:`name \u003cenvoy_v3_api_field_config.listener.v3.Listener.name\u003e`. :ref:`Address \u003cenvoy_v3_api_field_config.listener.v3.Listener.address\u003e` must not be set on the internal listeners. There are some limitations that are derived from the implementation. The known limitations include: * :ref:`ConnectionBalanceConfig \u003cenvoy_v3_api_msg_config.listener.v3.Listener.ConnectionBalanceConfig\u003e` is not   allowed because both the cluster connection and the listener connection must be owned by the same dispatcher. * :ref:`tcp_backlog_size \u003cenvoy_v3_api_field_config.listener.v3.Listener.tcp_backlog_size\u003e` * :ref:`freebind \u003cenvoy_v3_api_field_config.listener.v3.Listener.freebind\u003e` * :ref:`transparent \u003cenvoy_v3_api_field_config.listener.v3.Listener.transparent\u003e`"
                },
                "enable_mptcp": {
                    "type": "boolean",
                    "description": "Enable MPTCP (multi-path TCP) on this listener. Clients will be allowed to establish MPTCP connections. Non-MPTCP clients will fall back to regular TCP."
                },
                "ignore_global_conn_limit": {
                    "type": "boolean",
                    "description": "Whether the listener should limit connections based upon the value of :ref:`global_downstream_max_connections \u003cconfig_overload_manager_limiting_connections\u003e`."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Listener",
            "description": "[#next-free-field: 35]"
        },
        "envoy.config.listener.v3.Listener.ConnectionBalanceConfig": {
            "properties": {
                "exact_balance": {
                    "$ref": "#/definitions/envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance",
                    "additionalProperties": true,
                    "description": "If specified, the listener will use the exact connection balancer."
                },
                "extend_balance": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "The listener will use the connection balancer according to ``type_url``. If ``type_url`` is invalid, Envoy will not attempt to balance active connections between worker threads. [#extension-category: envoy.network.connection_balance]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Connection Balance Config",
            "description": "Configuration for listener connection balancing."
        },
        "envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance": {
            "additionalProperties": true,
            "type": "object",
            "title": "Exact Balance",
            "description": "A connection balancer implementation that does exact balancing. This means that a lock is held during balancing so that connection counts are nearly exactly balanced between worker threads. This is \"nearly\" exact in the sense that a connection might close in parallel thus making the counts incorrect, but this should be rectified on the next accept. This balancer sacrifices accept throughput for accuracy and should be used when there are a small number of connections that rarely cycle (e.g., service mesh gRPC egress)."
        },
        "envoy.config.listener.v3.Listener.DeprecatedV1": {
            "properties": {
                "bind_to_port": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Whether the listener should bind to the port. A listener that doesn't bind can only receive connections redirected from other listeners that set use_original_dst parameter to true. Default is true. This is deprecated. Use :ref:`Listener.bind_to_port \u003cenvoy_v3_api_field_config.listener.v3.Listener.bind_to_port\u003e`"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Deprecated V 1",
            "description": "[#not-implemented-hide:]"
        },
        "envoy.config.listener.v3.Listener.InternalListenerConfig": {
            "additionalProperties": true,
            "type": "object",
            "title": "Internal Listener Config",
            "description": "Configuration for envoy internal listener. All the future internal listener features should be added here."
        },
        "envoy.config.listener.v3.ListenerFilter": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the filter configuration."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Filter specific configuration which depends on the filter being instantiated. See the supported filters for further documentation. [#extension-category: envoy.filters.listener,envoy.filters.udp_listener]"
                },
                "config_discovery": {
                    "$ref": "#/definitions/envoy.config.core.v3.ExtensionConfigSource",
                    "additionalProperties": true,
                    "description": "Configuration source specifier for an extension configuration discovery service. In case of a failure and without the default configuration, the listener closes the connections."
                },
                "filter_disabled": {
                    "$ref": "#/definitions/envoy.config.listener.v3.ListenerFilterChainMatchPredicate",
                    "additionalProperties": true,
                    "description": "Optional match predicate used to disable the filter. The filter is enabled when this field is empty. See :ref:`ListenerFilterChainMatchPredicate \u003cenvoy_v3_api_msg_config.listener.v3.ListenerFilterChainMatchPredicate\u003e` for further examples."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Listener Filter",
            "description": "[#next-free-field: 6]"
        },
        "envoy.config.listener.v3.ListenerFilterChainMatchPredicate": {
            "properties": {
                "or_match": {
                    "$ref": "#/definitions/envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet",
                    "additionalProperties": true,
                    "description": "A set that describes a logical OR. If any member of the set matches, the match configuration matches."
                },
                "and_match": {
                    "$ref": "#/definitions/envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet",
                    "additionalProperties": true,
                    "description": "A set that describes a logical AND. If all members of the set match, the match configuration matches."
                },
                "not_match": {
                    "$ref": "#/definitions/envoy.config.listener.v3.ListenerFilterChainMatchPredicate",
                    "additionalProperties": true,
                    "description": "A negation match. The match configuration will match if the negated match condition matches."
                },
                "any_match": {
                    "type": "boolean",
                    "description": "The match configuration will always match."
                },
                "destination_port_range": {
                    "$ref": "#/definitions/envoy.type.v3.Int32Range",
                    "additionalProperties": true,
                    "description": "Match destination port. Particularly, the match evaluation must use the recovered local port if the owning listener filter is after :ref:`an original_dst listener filter \u003cconfig_listener_filters_original_dst\u003e`."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Listener Filter Chain Match Predicate",
            "description": "Listener filter chain match configuration. This is a recursive structure which allows complex nested match configurations to be built using various logical operators. Examples: * Matches if the destination port is 3306. .. code-block:: yaml  destination_port_range:   start: 3306   end: 3307 * Matches if the destination port is 3306 or 15000. .. code-block:: yaml  or_match:    rules:      - destination_port_range:          start: 3306          end: 3307      - destination_port_range:          start: 15000          end: 15001 [#next-free-field: 6]"
        },
        "envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet": {
            "properties": {
                "rules": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.listener.v3.ListenerFilterChainMatchPredicate"
                    },
                    "type": "array",
                    "description": "The list of rules that make up the set."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Match Set",
            "description": "A set of match configurations used for logical operations."
        },
        "envoy.config.listener.v3.QuicProtocolOptions": {
            "properties": {
                "quic_protocol_options": {
                    "$ref": "#/definitions/envoy.config.core.v3.QuicProtocolOptions",
                    "additionalProperties": true
                },
                "idle_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Maximum number of milliseconds that connection will be alive when there is no network activity. If it is less than 1ms, Envoy will use 1ms. 300000ms if not specified.",
                    "format": "regex"
                },
                "crypto_handshake_timeout": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "Connection timeout in milliseconds before the crypto handshake is finished. If it is less than 5000ms, Envoy will use 5000ms. 20000ms if not specified.",
                    "format": "regex"
                },
                "enabled": {
                    "$ref": "#/definitions/envoy.config.core.v3.RuntimeFeatureFlag",
                    "additionalProperties": true,
                    "description": "Runtime flag that controls whether the listener is enabled or not. If not specified, defaults to enabled."
                },
                "packets_to_read_to_connection_count_ratio": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "A multiplier to number of connections which is used to determine how many packets to read per event loop. A reasonable number should allow the listener to process enough payload but not starve TCP and other UDP sockets and also prevent long event loop duration. The default value is 32. This means if there are N QUIC connections, the total number of packets to read in each read event will be 32 * N. The actual number of packets to read in total by the UDP listener is also bound by 6000, regardless of this field or how many connections there are."
                },
                "crypto_stream_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Configure which implementation of ``quic::QuicCryptoClientStreamBase`` to be used for this listener. If not specified the :ref:`QUICHE default one configured by \u003cenvoy_v3_api_msg_extensions.quic.crypto_stream.v3.CryptoServerStreamConfig\u003e` will be used. [#extension-category: envoy.quic.server.crypto_stream]"
                },
                "proof_source_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Configure which implementation of ``quic::ProofSource`` to be used for this listener. If not specified the :ref:`default one configured by \u003cenvoy_v3_api_msg_extensions.quic.proof_source.v3.ProofSourceConfig\u003e` will be used. [#extension-category: envoy.quic.proof_source]"
                },
                "connection_id_generator_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Config which implementation of ``quic::ConnectionIdGeneratorInterface`` to be used for this listener. If not specified the :ref:`default one configured by \u003cenvoy_v3_api_msg_extensions.quic.connection_id_generator.v3.DeterministicConnectionIdGeneratorConfig\u003e` will be used. [#extension-category: envoy.quic.connection_id_generator]"
                },
                "server_preferred_address_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Configure the server's preferred address to advertise so that client can migrate to it. See :ref:`example \u003cenvoy_v3_api_msg_extensions.quic.server_preferred_address.v3.FixedServerPreferredAddressConfig\u003e` which configures a pair of v4 and v6 preferred addresses. The current QUICHE implementation will advertise only one of the preferred IPv4 and IPv6 addresses based on the address family the client initially connects with. If not specified, Envoy will not advertise any server's preferred address. [#extension-category: envoy.quic.server_preferred_address]"
                },
                "send_disable_active_migration": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Configure the server to send transport parameter `disable_active_migration \u003chttps://www.rfc-editor.org/rfc/rfc9000#section-18.2-4.30.1\u003e`_. Defaults to false (do not send this transport parameter)."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: QUIC listener config]",
            "description": "[#protodoc-title: QUIC listener config]  Configuration specific to the UDP QUIC listener. [#next-free-field: 11]"
        },
        "envoy.config.listener.v3.UdpListenerConfig": {
            "properties": {
                "downstream_socket_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.UdpSocketConfig",
                    "additionalProperties": true,
                    "description": "UDP socket configuration for the listener. The default for :ref:`prefer_gro \u003cenvoy_v3_api_field_config.core.v3.UdpSocketConfig.prefer_gro\u003e` is false for listener sockets. If receiving a large amount of datagrams from a small number of sources, it may be worthwhile to enable this option after performance testing."
                },
                "quic_options": {
                    "$ref": "#/definitions/envoy.config.listener.v3.QuicProtocolOptions",
                    "additionalProperties": true,
                    "description": "Configuration for QUIC protocol. If empty, QUIC will not be enabled on this listener. Set to the default object to enable QUIC without modifying any additional options."
                },
                "udp_packet_packet_writer_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Configuration for the UDP packet writer. If empty, HTTP/3 will use GSO if available (:ref:`UdpDefaultWriterFactory \u003cenvoy_v3_api_msg_extensions.udp_packet_writer.v3.UdpGsoBatchWriterFactory\u003e`) or the default kernel sendmsg if not, (:ref:`UdpDefaultWriterFactory \u003cenvoy_v3_api_msg_extensions.udp_packet_writer.v3.UdpDefaultWriterFactory\u003e`) and raw UDP will use kernel sendmsg. [#extension-category: envoy.udp_packet_writer]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: UDP listener config]\n Listener :ref:`configuration overview \u003cconfig_listeners\u003e`",
            "description": "[#protodoc-title: UDP listener config] Listener :ref:`configuration overview \u003cconfig_listeners\u003e`  [#next-free-field: 9]"
        },
        "envoy.config.metrics.v3.HistogramBucketSettings": {
            "properties": {
                "match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.StringMatcher",
                    "additionalProperties": true,
                    "description": "The stats that this rule applies to. The match is applied to the original stat name before tag-extraction, for example ``cluster.exampleclustername.upstream_cx_length_ms``."
                },
                "buckets": {
                    "items": {
                        "type": "number"
                    },
                    "minItems": 1,
                    "type": "array",
                    "description": "Each value is the upper bound of a bucket. Each bucket must be greater than 0 and unique. The order of the buckets does not matter."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Histogram Bucket Settings",
            "description": "Specifies a matcher for stats and the buckets that matching stats should use."
        },
        "envoy.config.metrics.v3.StatsConfig": {
            "properties": {
                "stats_tags": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.metrics.v3.TagSpecifier"
                    },
                    "type": "array",
                    "description": "Each stat name is independently processed through these tag specifiers. When a tag is matched, the first capture group is not immediately removed from the name, so later :ref:`TagSpecifiers \u003cenvoy_v3_api_msg_config.metrics.v3.TagSpecifier\u003e` can also match that same portion of the match. After all tag matching is complete, a tag-extracted version of the name is produced and is used in stats sinks that represent tags, such as Prometheus."
                },
                "use_all_default_tags": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Use all default tag regexes specified in Envoy. These can be combined with custom tags specified in :ref:`stats_tags \u003cenvoy_v3_api_field_config.metrics.v3.StatsConfig.stats_tags\u003e`. They will be processed before the custom tags. .. note::   If any default tags are specified twice, the config will be considered   invalid. See :repo:`well_known_names.h \u003csource/common/config/well_known_names.h\u003e` for a list of the default tags in Envoy. If not provided, the value is assumed to be true."
                },
                "stats_matcher": {
                    "$ref": "#/definitions/envoy.config.metrics.v3.StatsMatcher",
                    "additionalProperties": true,
                    "description": "Inclusion/exclusion matcher for stat name creation. If not provided, all stats are instantiated as normal. Preventing the instantiation of certain families of stats can improve memory performance for Envoys running especially large configs. .. warning::   Excluding stats may affect Envoy's behavior in undocumented ways. See   `issue #8771 \u003chttps://github.com/envoyproxy/envoy/issues/8771\u003e`_ for more information.   If any unexpected behavior changes are observed, please open a new issue immediately."
                },
                "histogram_bucket_settings": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.metrics.v3.HistogramBucketSettings"
                    },
                    "type": "array",
                    "description": "Defines rules for setting the histogram buckets. Rules are evaluated in order, and the first match is applied. If no match is found (or if no rules are set), the following default buckets are used:   .. code-block:: json     [       0.5,       1,       5,       10,       25,       50,       100,       250,       500,       1000,       2500,       5000,       10000,       30000,       60000,       300000,       600000,       1800000,       3600000     ]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Stats Config",
            "description": "Statistics configuration such as tagging."
        },
        "envoy.config.metrics.v3.StatsMatcher": {
            "properties": {
                "reject_all": {
                    "type": "boolean",
                    "description": "If ``reject_all`` is true, then all stats are disabled. If ``reject_all`` is false, then all stats are enabled."
                },
                "exclusion_list": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.ListStringMatcher",
                    "additionalProperties": true,
                    "description": "Exclusive match. All stats are enabled except for those matching one of the supplied StringMatcher protos."
                },
                "inclusion_list": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.ListStringMatcher",
                    "additionalProperties": true,
                    "description": "Inclusive match. No stats are enabled except for those matching one of the supplied StringMatcher protos."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Stats Matcher",
            "description": "Configuration for disabling stat instantiation.  The instantiation of stats is unrestricted by default. If the goal is to configure Envoy to instantiate all stats, there is no need to construct a StatsMatcher. However, StatsMatcher can be used to limit the creation of families of stats in order to conserve memory. Stats can either be disabled entirely, or they can be limited by either an exclusion or an inclusion list of :ref:`StringMatcher \u003cenvoy_v3_api_msg_type.matcher.v3.StringMatcher\u003e` protos: * If ``reject_all`` is set to ``true``, no stats will be instantiated. If ``reject_all`` is set to   ``false``, all stats will be instantiated. * If an exclusion list is supplied, any stat name matching *any* of the StringMatchers in the   list will not instantiate. * If an inclusion list is supplied, no stats will instantiate, except those matching *any* of   the StringMatchers in the list. A StringMatcher can be used to match against an exact string, a suffix / prefix, or a regex. **NB:** For performance reasons, it is highly recommended to use a prefix- or suffix-based matcher rather than a regex-based matcher. Example 1. Excluding all stats. .. code-block:: json   {     \"statsMatcher\": {       \"rejectAll\": \"true\"     }   } Example 2. Excluding all cluster-specific stats, but not cluster-manager stats: .. code-block:: json   {     \"statsMatcher\": {       \"exclusionList\": {         \"patterns\": [           {             \"prefix\": \"cluster.\"           }         ]       }     }   } Example 3. Including only manager-related stats: .. code-block:: json   {     \"statsMatcher\": {       \"inclusionList\": {         \"patterns\": [           {             \"prefix\": \"cluster_manager.\"           },           {             \"prefix\": \"listener_manager.\"           }         ]       }     }   }"
        },
        "envoy.config.metrics.v3.StatsSink": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the stats sink to instantiate. The name must match a supported stats sink. See the :ref:`extensions listed in typed_config below \u003cextension_category_envoy.stats_sinks\u003e` for the default list of available stats sink. Sinks optionally support tagged/multiple dimensional metrics."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Stats]\n Statistics :ref:`architecture overview \u003carch_overview_statistics\u003e`.",
            "description": "[#protodoc-title: Stats] Statistics :ref:`architecture overview \u003carch_overview_statistics\u003e`.  Configuration for pluggable stats sinks."
        },
        "envoy.config.metrics.v3.TagSpecifier": {
            "properties": {
                "tag_name": {
                    "type": "string",
                    "description": "Attaches an identifier to the tag values to identify the tag being in the sink. Envoy has a set of default names and regexes to extract dynamic portions of existing stats, which can be found in :repo:`well_known_names.h \u003csource/common/config/well_known_names.h\u003e` in the Envoy repository. If a :ref:`tag_name \u003cenvoy_v3_api_field_config.metrics.v3.TagSpecifier.tag_name\u003e` is provided in the config and neither :ref:`regex \u003cenvoy_v3_api_field_config.metrics.v3.TagSpecifier.regex\u003e` or :ref:`fixed_value \u003cenvoy_v3_api_field_config.metrics.v3.TagSpecifier.fixed_value\u003e` were specified, Envoy will attempt to find that name in its set of defaults and use the accompanying regex. .. note::   A stat name may be spelled in such a way that it matches two different   tag extractors for the same tag name. In that case, all but one of the   tag values will be dropped. It is not specified which tag value will be   retained. The extraction will only occur for one of the extractors, and   only the matched extraction will be removed from the tag name."
                },
                "regex": {
                    "type": "string",
                    "description": "Designates a tag to strip from the tag extracted name and provide as a named tag value for all statistics. This will only occur if any part of the name matches the regex provided with one or more capture groups. The first capture group identifies the portion of the name to remove. The second capture group (which will normally be nested inside the first) will designate the value of the tag for the statistic. If no second capture group is provided, the first will also be used to set the value of the tag. All other capture groups will be ignored. Example 1. a stat name ``cluster.foo_cluster.upstream_rq_timeout`` and one tag specifier: .. code-block:: json   {     \"tag_name\": \"envoy.cluster_name\",     \"regex\": \"^cluster\\\\.((.+?)\\\\.)\"   } Note that the regex will remove ``foo_cluster.`` making the tag extracted name ``cluster.upstream_rq_timeout`` and the tag value for ``envoy.cluster_name`` will be ``foo_cluster`` (note: there will be no ``.`` character because of the second capture group). Example 2. a stat name ``http.connection_manager_1.user_agent.ios.downstream_cx_total`` and two tag specifiers: .. code-block:: json   [     {       \"tag_name\": \"envoy.http_user_agent\",       \"regex\": \"^http(?=\\\\.).*?\\\\.user_agent\\\\.((.+?)\\\\.)\\\\w+?$\"     },     {       \"tag_name\": \"envoy.http_conn_manager_prefix\",       \"regex\": \"^http\\\\.((.*?)\\\\.)\"     }   ] The two regexes of the specifiers will be processed from the elaborated stat name. The first regex will save ``ios.`` as the tag value for ``envoy.http_user_agent``. It will leave it in the name for potential matching with additional tag specifiers. After all tag specifiers are processed the tags will be removed from the name. The second regex will populate tag ``envoy.http_conn_manager_prefix`` with value ``connection_manager_1.``, based on the original stat name. As a final step, the matched tags are removed, leaving ``http.user_agent.downstream_cx_total`` as the tag extracted name."
                },
                "fixed_value": {
                    "type": "string",
                    "description": "Specifies a fixed tag value for the ``tag_name``."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Tag Specifier",
            "description": "Designates a tag name and value pair. The value may be either a fixed value or a regex providing the value via capture groups. The specified tag will be unconditionally set if a fixed value, otherwise it will only be set if one or more capture groups in the regex match."
        },
        "envoy.config.overload.v3.BufferFactoryConfig": {
            "properties": {
                "minimum_account_to_track_power_of_two": {
                    "type": "integer",
                    "description": "The minimum power of two at which Envoy starts tracking an account. Envoy has 8 power of two buckets starting with the provided exponent below. Concretely the 1st bucket contains accounts for streams that use [2^minimum_account_to_track_power_of_two, 2^(minimum_account_to_track_power_of_two + 1)) bytes. With the 8th bucket tracking accounts \u003e= 128 * 2^minimum_account_to_track_power_of_two. The maximum value is 56, since we're using uint64_t for bytes counting, and that's the last value that would use the 8 buckets. In practice, we don't expect the proxy to be holding 2^56 bytes. If omitted, Envoy should not do any tracking."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Buffer Factory Config",
            "description": "Configuration for which accounts the WatermarkBuffer Factories should track."
        },
        "envoy.config.overload.v3.LoadShedPoint": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "This is just a well-known string for the LoadShedPoint. Deployment specific LoadShedPoints e.g. within a custom extension should be prefixed by the company / deployment name to avoid colliding with any open source LoadShedPoints."
                },
                "triggers": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.overload.v3.Trigger"
                    },
                    "type": "array",
                    "description": "A set of triggers for this LoadShedPoint. The LoadShedPoint will use the the maximum state of all triggers, which can be scalar values between 0 and 1 or saturated. A LoadShedPoint can only have one trigger for a given resource e.g. :ref:`Trigger.name \u003cenvoy_v3_api_field_config.overload.v3.Trigger.name\u003e` must be unique in this list."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Load Shed Point",
            "description": "A point within the connection or request lifecycle that provides context on whether to shed load at that given stage for the current entity at the point."
        },
        "envoy.config.overload.v3.OverloadAction": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the overload action. This is just a well-known string that listeners can use for registering callbacks. Custom overload actions should be named using reverse DNS to ensure uniqueness."
                },
                "triggers": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.overload.v3.Trigger"
                    },
                    "type": "array",
                    "description": "A set of triggers for this action. The state of the action is the maximum state of all triggers, which can be scalar values between 0 and 1 or saturated. Listeners are notified when the overload action changes state. An overload manager action can only have one trigger for a given resource e.g. :ref:`Trigger.name \u003cenvoy_v3_api_field_config.overload.v3.Trigger.name\u003e` must be unique in this list."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Configuration for the action being instantiated."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Overload Action"
        },
        "envoy.config.overload.v3.OverloadManager": {
            "properties": {
                "refresh_interval": {
                    "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
                    "type": "string",
                    "description": "The interval for refreshing resource usage.",
                    "format": "regex"
                },
                "resource_monitors": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.overload.v3.ResourceMonitor"
                    },
                    "type": "array",
                    "description": "The set of resources to monitor."
                },
                "actions": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.overload.v3.OverloadAction"
                    },
                    "type": "array",
                    "description": "The set of overload actions."
                },
                "loadshed_points": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.overload.v3.LoadShedPoint"
                    },
                    "type": "array",
                    "description": "The set of load shed points."
                },
                "buffer_factory_config": {
                    "$ref": "#/definitions/envoy.config.overload.v3.BufferFactoryConfig",
                    "additionalProperties": true,
                    "description": "Configuration for buffer factory."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Overload Manager",
            "description": "[#next-free-field: 6]"
        },
        "envoy.config.overload.v3.ResourceMonitor": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the resource monitor to instantiate. Must match a registered resource monitor type. See the :ref:`extensions listed in typed_config below \u003cextension_category_envoy.resource_monitors\u003e` for the default list of available resource monitor."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "The Overload Manager provides an extensible framework to protect Envoy instances\n from overload of various resources (memory, cpu, file descriptors, etc).\n It monitors a configurable set of resources and notifies registered listeners\n when triggers related to those resources fire.",
            "description": "[#protodoc-title: Overload Manager]  The Overload Manager provides an extensible framework to protect Envoy instances from overload of various resources (memory, cpu, file descriptors, etc). It monitors a configurable set of resources and notifies registered listeners when triggers related to those resources fire."
        },
        "envoy.config.overload.v3.ScaledTrigger": {
            "properties": {
                "scaling_threshold": {
                    "type": "number",
                    "description": "If the resource pressure is greater than this value, the trigger will be in the :ref:`scaling \u003carch_overview_overload_manager-triggers-state\u003e` state with value ``(pressure - scaling_threshold) / (saturation_threshold - scaling_threshold)``."
                },
                "saturation_threshold": {
                    "type": "number",
                    "description": "If the resource pressure is greater than this value, the trigger will enter saturation."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Scaled Trigger"
        },
        "envoy.config.overload.v3.ThresholdTrigger": {
            "properties": {
                "value": {
                    "type": "number",
                    "description": "If the resource pressure is greater than or equal to this value, the trigger will enter saturation."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Threshold Trigger"
        },
        "envoy.config.overload.v3.Trigger": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the resource this is a trigger for."
                },
                "threshold": {
                    "$ref": "#/definitions/envoy.config.overload.v3.ThresholdTrigger",
                    "additionalProperties": true
                },
                "scaled": {
                    "$ref": "#/definitions/envoy.config.overload.v3.ScaledTrigger",
                    "additionalProperties": true
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Trigger"
        },
        "envoy.config.route.v3.HeaderMatcher": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Specifies the name of the header in the request."
                },
                "exact_match": {
                    "type": "string",
                    "description": "If specified, header match will be performed based on the value of the header. This field is deprecated. Please use :ref:`string_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.string_match\u003e`."
                },
                "safe_regex_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.RegexMatcher",
                    "additionalProperties": true,
                    "description": "If specified, this regex string is a regular expression rule which implies the entire request header value must match the regex. The rule will not match if only a subsequence of the request header value matches the regex. This field is deprecated. Please use :ref:`string_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.string_match\u003e`."
                },
                "range_match": {
                    "$ref": "#/definitions/envoy.type.v3.Int64Range",
                    "additionalProperties": true,
                    "description": "If specified, header match will be performed based on range. The rule will match if the request header value is within this range. The entire request header value must represent an integer in base 10 notation: consisting of an optional plus or minus sign followed by a sequence of digits. The rule will not match if the header value does not represent an integer. Match will fail for empty values, floating point numbers or if only a subsequence of the header value is an integer. Examples: * For range [-10,0), route will match for header value -1, but not for 0, ``somestring``, 10.9,   ``-1somestring``"
                },
                "present_match": {
                    "type": "boolean",
                    "description": "If specified as true, header match will be performed based on whether the header is in the request. If specified as false, header match will be performed based on whether the header is absent."
                },
                "prefix_match": {
                    "minLength": 1,
                    "type": "string",
                    "description": "If specified, header match will be performed based on the prefix of the header value. Note: empty prefix is not allowed, please use present_match instead. This field is deprecated. Please use :ref:`string_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.string_match\u003e`. Examples: * The prefix ``abcd`` matches the value ``abcdxyz``, but not for ``abcxyz``."
                },
                "suffix_match": {
                    "minLength": 1,
                    "type": "string",
                    "description": "If specified, header match will be performed based on the suffix of the header value. Note: empty suffix is not allowed, please use present_match instead. This field is deprecated. Please use :ref:`string_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.string_match\u003e`. Examples: * The suffix ``abcd`` matches the value ``xyzabcd``, but not for ``xyzbcd``."
                },
                "contains_match": {
                    "minLength": 1,
                    "type": "string",
                    "description": "If specified, header match will be performed based on whether the header value contains the given value or not. Note: empty contains match is not allowed, please use present_match instead. This field is deprecated. Please use :ref:`string_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.string_match\u003e`. Examples: * The value ``abcd`` matches the value ``xyzabcdpqr``, but not for ``xyzbcdpqr``."
                },
                "string_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.StringMatcher",
                    "additionalProperties": true,
                    "description": "If specified, header match will be performed based on the string match of the header value."
                },
                "invert_match": {
                    "type": "boolean",
                    "description": "If specified, the match result will be inverted before checking. Defaults to false. Examples: * The regex ``\\d{3}`` does not match the value ``1234``, so it will match when inverted. * The range [-10,0) will match the value -1, so it will not match when inverted."
                },
                "treat_missing_header_as_empty": {
                    "type": "boolean",
                    "description": "If specified, for any header match rule, if the header match rule specified header does not exist, this header value will be treated as empty. Defaults to false. Examples: * The header match rule specified header \"header1\" to range match of [0, 10],   :ref:`invert_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.invert_match\u003e`   is set to true and :ref:`treat_missing_header_as_empty \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty\u003e`   is set to true; The \"header1\" header is not present. The match rule will   treat the \"header1\" as an empty header. The empty header does not match the range,   so it will match when inverted. * The header match rule specified header \"header2\" to range match of [0, 10],   :ref:`invert_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.invert_match\u003e`   is set to true and :ref:`treat_missing_header_as_empty \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty\u003e`   is set to false; The \"header2\" header is not present and the header   matcher rule for \"header2\" will be ignored so it will not match. * The header match rule specified header \"header3\" to a string regex match   ``^$`` which means an empty string, and   :ref:`treat_missing_header_as_empty \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty\u003e`   is set to true; The \"header3\" header is not present.   The match rule will treat the \"header3\" header as an empty header so it will match. * The header match rule specified header \"header4\" to a string regex match   ``^$`` which means an empty string, and   :ref:`treat_missing_header_as_empty \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty\u003e`   is set to false; The \"header4\" header is not present.   The match rule for \"header4\" will be ignored so it will not match."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Header Matcher",
            "description": ".. attention::   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1 ``Host``   header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead. .. attention::   To route on HTTP method, use the special HTTP/2 ``:method`` header. This works for both   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,   .. code-block:: json     {       \"name\": \":method\",       \"string_match\": {         \"exact\": \"POST\"       }     } .. attention::   In the absence of any header match specifier, match will default to :ref:`present_match   \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.present_match\u003e`. i.e, a request that has the :ref:`name   \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.name\u003e` header will match, regardless of the header's   value.  [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.] [#next-free-field: 15]"
        },
        "envoy.config.trace.v3.Tracing": {
            "properties": {
                "http": {
                    "$ref": "#/definitions/envoy.config.trace.v3.Tracing.Http",
                    "additionalProperties": true,
                    "description": "Provides configuration for the HTTP tracer."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Tracing]\n Tracing :ref:`architecture overview \u003carch_overview_tracing\u003e`.",
            "description": "[#protodoc-title: Tracing] Tracing :ref:`architecture overview \u003carch_overview_tracing\u003e`.  The tracing configuration specifies settings for an HTTP tracer provider used by Envoy. Envoy may support other tracers in the future, but right now the HTTP tracer is the only one supported. .. attention::   Use of this message type has been deprecated in favor of direct use of   :ref:`Tracing.Http \u003cenvoy_v3_api_msg_config.trace.v3.Tracing.Http\u003e`."
        },
        "envoy.config.trace.v3.Tracing.Http": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of the HTTP trace driver to instantiate. The name must match a supported HTTP trace driver. See the :ref:`extensions listed in typed_config below \u003cextension_category_envoy.tracers\u003e` for the default list of the HTTP trace driver."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Http",
            "description": "Configuration for an HTTP tracer provider used by Envoy. The configuration is defined by the :ref:`HttpConnectionManager.Tracing \u003cenvoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing\u003e` :ref:`provider \u003cenvoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.provider\u003e` field."
        },
        "envoy.extensions.transport_sockets.tls.v3.CertificateProviderPluginInstance": {
            "properties": {
                "instance_name": {
                    "type": "string",
                    "description": "Provider instance name. If not present, defaults to \"default\". Instance names should generally be defined not in terms of the underlying provider implementation (e.g., \"file_watcher\") but rather in terms of the function of the certificates (e.g., \"foo_deployment_identity\")."
                },
                "certificate_name": {
                    "type": "string",
                    "description": "Opaque name used to specify certificate instances or types. For example, \"ROOTCA\" to specify a root-certificate (validation context) or \"example.com\" to specify a certificate for a particular domain. Not all provider instances will actually use this field, so the value defaults to the empty string."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Certificate Provider Plugin Instance",
            "description": "Indicates a certificate to be obtained from a named CertificateProvider plugin instance. The plugin instances are defined in the client's bootstrap file. The plugin allows certificates to be fetched/refreshed over the network asynchronously with respect to the TLS handshake. [#not-implemented-hide:]"
        },
        "envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext": {
            "properties": {
                "trusted_ca": {
                    "$ref": "#/definitions/envoy.config.core.v3.DataSource",
                    "additionalProperties": true,
                    "description": "TLS certificate data containing certificate authority certificates to use in verifying a presented peer certificate (e.g. server certificate for clusters or client certificate for listeners). If not specified and a peer certificate is presented it will not be verified. By default, a client certificate is optional, unless one of the additional options (:ref:`require_client_certificate \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.require_client_certificate\u003e`, :ref:`verify_certificate_spki \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki\u003e`, :ref:`verify_certificate_hash \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash\u003e`, or :ref:`match_typed_subject_alt_names \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names\u003e`) is also specified. It can optionally contain certificate revocation lists, in which case Envoy will verify that the presented peer certificate has not been revoked by one of the included CRLs. Note that if a CRL is provided for any certificate authority in a trust chain, a CRL must be provided for all certificate authorities in that chain. Failure to do so will result in verification failure for both revoked and unrevoked certificates from that chain. The behavior of requiring all certificates to contain CRLs can be altered by setting :ref:`only_verify_leaf_cert_crl \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.only_verify_leaf_cert_crl\u003e` true. If set to true, only the final certificate in the chain undergoes CRL verification. See :ref:`the TLS overview \u003carch_overview_ssl_enabling_verification\u003e` for a list of common system CA locations. If ``trusted_ca`` is a filesystem path, a watch will be added to the parent directory for any file moves to support rotation. This currently only applies to dynamic secrets, when the ``CertificateValidationContext`` is delivered via SDS. X509_V_FLAG_PARTIAL_CHAIN is set by default, so non-root/intermediate ca certificate in ``trusted_ca`` can be treated as trust anchor as well. It allows verification with building valid partial chain instead of a full chain. Only one of ``trusted_ca`` and ``ca_certificate_provider_instance`` may be specified. [#next-major-version: This field and watched_directory below should ideally be moved into a separate sub-message, since there's no point in specifying the latter field without this one.]"
                },
                "ca_certificate_provider_instance": {
                    "$ref": "#/definitions/envoy.extensions.transport_sockets.tls.v3.CertificateProviderPluginInstance",
                    "additionalProperties": true,
                    "description": "Certificate provider instance for fetching TLS certificates. Only one of ``trusted_ca`` and ``ca_certificate_provider_instance`` may be specified. [#not-implemented-hide:]"
                },
                "watched_directory": {
                    "$ref": "#/definitions/envoy.config.core.v3.WatchedDirectory",
                    "additionalProperties": true,
                    "description": "If specified, updates of a file-based ``trusted_ca`` source will be triggered by this watch. This allows explicit control over the path watched, by default the parent directory of the filesystem path in ``trusted_ca`` is watched if this field is not specified. This only applies when a ``CertificateValidationContext`` is delivered by SDS with references to filesystem paths. See the :ref:`SDS key rotation \u003csds_key_rotation\u003e` documentation for further details."
                },
                "verify_certificate_spki": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate matches one of the specified values. A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate can be generated with the following command: .. code-block:: bash   $ openssl x509 -in path/to/client.crt -noout -pubkey     | openssl pkey -pubin -outform DER     | openssl dgst -sha256 -binary     | openssl enc -base64   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A= This is the format used in HTTP Public Key Pinning. When both: :ref:`verify_certificate_hash \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash\u003e` and :ref:`verify_certificate_spki \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki\u003e` are specified, a hash matching value from either of the lists will result in the certificate being accepted. .. attention::   This option is preferred over :ref:`verify_certificate_hash   \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash\u003e`,   because SPKI is tied to a private key, so it doesn't change when the certificate   is renewed using the same private key."
                },
                "verify_certificate_hash": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that the SHA-256 of the DER-encoded presented certificate matches one of the specified values. A hex-encoded SHA-256 of the certificate can be generated with the following command: .. code-block:: bash   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d\" \" -f2   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a A long hex-encoded and colon-separated SHA-256 (a.k.a. \"fingerprint\") of the certificate can be generated with the following command: .. code-block:: bash   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d\"=\" -f2   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A Both of those formats are acceptable. When both: :ref:`verify_certificate_hash \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash\u003e` and :ref:`verify_certificate_spki \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki\u003e` are specified, a hash matching value from either of the lists will result in the certificate being accepted."
                },
                "match_typed_subject_alt_names": {
                    "items": {
                        "$ref": "#/definitions/envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher"
                    },
                    "type": "array",
                    "description": "An optional list of Subject Alternative name matchers. If specified, Envoy will verify that the Subject Alternative Name of the presented certificate matches one of the specified matchers. The matching uses \"any\" semantics, that is to say, the SAN is verified if at least one matcher is matched. When a certificate has wildcard DNS SAN entries, to match a specific client, it should be configured with exact match type in the :ref:`string matcher \u003cenvoy_v3_api_msg_type.matcher.v3.StringMatcher\u003e`. For example if the certificate has \"\\*.example.com\" as DNS SAN entry, to allow only \"api.example.com\", it should be configured as shown below. .. code-block:: yaml  match_typed_subject_alt_names:  - san_type: DNS    matcher:      exact: \"api.example.com\" .. attention::   Subject Alternative Names are easily spoofable and verifying only them is insecure,   therefore this option must be used together with :ref:`trusted_ca   \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca\u003e`."
                },
                "match_subject_alt_names": {
                    "items": {
                        "$ref": "#/definitions/envoy.type.matcher.v3.StringMatcher"
                    },
                    "type": "array",
                    "description": "This field is deprecated in favor of :ref:`match_typed_subject_alt_names \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names\u003e`. Note that if both this field and :ref:`match_typed_subject_alt_names \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names\u003e` are specified, the former (deprecated field) is ignored."
                },
                "require_signed_certificate_timestamp": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "[#not-implemented-hide:] Must present signed certificate time-stamp."
                },
                "crl": {
                    "$ref": "#/definitions/envoy.config.core.v3.DataSource",
                    "additionalProperties": true,
                    "description": "An optional `certificate revocation list \u003chttps://en.wikipedia.org/wiki/Certificate_revocation_list\u003e`_ (in PEM format). If specified, Envoy will verify that the presented peer certificate has not been revoked by this CRL. If this DataSource contains multiple CRLs, all of them will be used. Note that if a CRL is provided for any certificate authority in a trust chain, a CRL must be provided for all certificate authorities in that chain. Failure to do so will result in verification failure for both revoked and unrevoked certificates from that chain. This default behavior can be altered by setting :ref:`only_verify_leaf_cert_crl \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.only_verify_leaf_cert_crl\u003e` to true. If ``crl`` is a filesystem path, a watch will be added to the parent directory for any file moves to support rotation. This currently only applies to dynamic secrets, when the ``CertificateValidationContext`` is delivered via SDS."
                },
                "allow_expired_certificate": {
                    "type": "boolean",
                    "description": "If specified, Envoy will not reject expired certificates."
                },
                "trust_chain_verification": {
                    "enum": [
                        "VERIFY_TRUST_CHAIN",
                        0,
                        "ACCEPT_UNTRUSTED",
                        1
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Trust Chain Verification",
                    "description": "Peer certificate verification mode."
                },
                "custom_validator_config": {
                    "$ref": "#/definitions/envoy.config.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "The configuration of an extension specific certificate validator. If specified, all validation is done by the specified validator, and the behavior of all other validation settings is defined by the specified validator (and may be entirely ignored, unused, and unvalidated). Refer to the documentation for the specified validator. If you do not want a custom validation algorithm, do not set this field. [#extension-category: envoy.tls.cert_validator]"
                },
                "only_verify_leaf_cert_crl": {
                    "type": "boolean",
                    "description": "If this option is set to true, only the certificate at the end of the certificate chain will be subject to validation by :ref:`CRL \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.crl\u003e`."
                },
                "max_verify_depth": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Defines maximum depth of a certificate chain accepted in verification, the default limit is 100, though this can be system-dependent. This number does not include the leaf but includes the trust anchor, so a depth of 1 allows the leaf and one CA certificate. If a trusted issuer appears in the chain, but in a depth larger than configured, the certificate validation will fail. This matches the semantics of ``SSL_CTX_set_verify_depth`` in OpenSSL 1.0.x and older versions of BoringSSL. It differs from ``SSL_CTX_set_verify_depth`` in OpenSSL 1.1.x and newer versions of BoringSSL in that the trust anchor is included. Trusted issues are specified by setting :ref:`trusted_ca \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca\u003e`"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Certificate Validation Context",
            "description": "[#next-free-field: 17]"
        },
        "envoy.extensions.transport_sockets.tls.v3.GenericSecret": {
            "properties": {
                "secret": {
                    "$ref": "#/definitions/envoy.config.core.v3.DataSource",
                    "additionalProperties": true,
                    "description": "Secret of generic type and is available to filters."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Secrets configuration]",
            "description": "[#protodoc-title: Secrets configuration]"
        },
        "envoy.extensions.transport_sockets.tls.v3.PrivateKeyProvider": {
            "properties": {
                "provider_name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Private key method provider name. The name must match a supported private key method provider type."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                },
                "fallback": {
                    "type": "boolean",
                    "description": "If the private key provider isn't available (eg. the required hardware capability doesn't existed), Envoy will fallback to the BoringSSL default implementation when the ``fallback`` is true. The default value is ``false``."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Private Key Provider",
            "description": "BoringSSL private key method configuration. The private key methods are used for external (potentially asynchronous) signing and decryption operations. Some use cases for private key methods would be TPM support and TLS acceleration."
        },
        "envoy.extensions.transport_sockets.tls.v3.Secret": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to."
                },
                "tls_certificate": {
                    "$ref": "#/definitions/envoy.extensions.transport_sockets.tls.v3.TlsCertificate",
                    "additionalProperties": true
                },
                "session_ticket_keys": {
                    "$ref": "#/definitions/envoy.extensions.transport_sockets.tls.v3.TlsSessionTicketKeys",
                    "additionalProperties": true
                },
                "validation_context": {
                    "$ref": "#/definitions/envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext",
                    "additionalProperties": true
                },
                "generic_secret": {
                    "$ref": "#/definitions/envoy.extensions.transport_sockets.tls.v3.GenericSecret",
                    "additionalProperties": true
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Secret",
            "description": "[#next-free-field: 6]"
        },
        "envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher": {
            "properties": {
                "san_type": {
                    "enum": [
                        "SAN_TYPE_UNSPECIFIED",
                        0,
                        "EMAIL",
                        1,
                        "DNS",
                        2,
                        "URI",
                        3,
                        "IP_ADDRESS",
                        4
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "San Type",
                    "description": "Indicates the choice of GeneralName as defined in section 4.2.1.5 of RFC 5280 to match against."
                },
                "matcher": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.StringMatcher",
                    "additionalProperties": true,
                    "description": "Matcher for SAN value."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Subject Alt Name Matcher",
            "description": "Matcher for subject alternative names, to match both type and value of the SAN."
        },
        "envoy.extensions.transport_sockets.tls.v3.TlsCertificate": {
            "properties": {
                "certificate_chain": {
                    "$ref": "#/definitions/envoy.config.core.v3.DataSource",
                    "additionalProperties": true,
                    "description": "The TLS certificate chain. If ``certificate_chain`` is a filesystem path, a watch will be added to the parent directory for any file moves to support rotation. This currently only applies to dynamic secrets, when the ``TlsCertificate`` is delivered via SDS."
                },
                "private_key": {
                    "$ref": "#/definitions/envoy.config.core.v3.DataSource",
                    "additionalProperties": true,
                    "description": "The TLS private key. If ``private_key`` is a filesystem path, a watch will be added to the parent directory for any file moves to support rotation. This currently only applies to dynamic secrets, when the ``TlsCertificate`` is delivered via SDS."
                },
                "pkcs12": {
                    "$ref": "#/definitions/envoy.config.core.v3.DataSource",
                    "additionalProperties": true,
                    "description": "``Pkcs12`` data containing TLS certificate, chain, and private key. If ``pkcs12`` is a filesystem path, the file will be read, but no watch will be added to the parent directory, since ``pkcs12`` isn't used by SDS. This field is mutually exclusive with ``certificate_chain``, ``private_key`` and ``private_key_provider``. This can't be marked as ``oneof`` due to API compatibility reasons. Setting both :ref:`private_key \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key\u003e`, :ref:`certificate_chain \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.certificate_chain\u003e`, or :ref:`private_key_provider \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key_provider\u003e` and :ref:`pkcs12 \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.pkcs12\u003e` fields will result in an error. Use :ref:`password \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.password\u003e` to specify the password to unprotect the ``PKCS12`` data, if necessary."
                },
                "watched_directory": {
                    "$ref": "#/definitions/envoy.config.core.v3.WatchedDirectory",
                    "additionalProperties": true,
                    "description": "If specified, updates of file-based ``certificate_chain`` and ``private_key`` sources will be triggered by this watch. The certificate/key pair will be read together and validated for atomic read consistency (i.e. no intervening modification occurred between cert/key read, verified by file hash comparisons). This allows explicit control over the path watched, by default the parent directories of the filesystem paths in ``certificate_chain`` and ``private_key`` are watched if this field is not specified. This only applies when a ``TlsCertificate`` is delivered by SDS with references to filesystem paths. See the :ref:`SDS key rotation \u003csds_key_rotation\u003e` documentation for further details."
                },
                "private_key_provider": {
                    "$ref": "#/definitions/envoy.extensions.transport_sockets.tls.v3.PrivateKeyProvider",
                    "additionalProperties": true,
                    "description": "BoringSSL private key method provider. This is an alternative to :ref:`private_key \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key\u003e` field. This can't be marked as ``oneof`` due to API compatibility reasons. Setting both :ref:`private_key \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key\u003e` and :ref:`private_key_provider \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key_provider\u003e` fields will result in an error."
                },
                "password": {
                    "$ref": "#/definitions/envoy.config.core.v3.DataSource",
                    "additionalProperties": true,
                    "description": "The password to decrypt the TLS private key. If this field is not set, it is assumed that the TLS private key is not password encrypted."
                },
                "ocsp_staple": {
                    "$ref": "#/definitions/envoy.config.core.v3.DataSource",
                    "additionalProperties": true,
                    "description": "The OCSP response to be stapled with this certificate during the handshake. The response must be DER-encoded and may only be  provided via ``filename`` or ``inline_bytes``. The response may pertain to only one certificate."
                },
                "signed_certificate_timestamp": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.DataSource"
                    },
                    "type": "array",
                    "description": "[#not-implemented-hide:]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Tls Certificate",
            "description": "[#next-free-field: 9]"
        },
        "envoy.extensions.transport_sockets.tls.v3.TlsSessionTicketKeys": {
            "properties": {
                "keys": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.DataSource"
                    },
                    "type": "array",
                    "description": "Keys for encrypting and decrypting TLS session tickets. The first key in the array contains the key to encrypt all new sessions created by this context. All keys are candidates for decrypting received tickets. This allows for easy rotation of keys by, for example, putting the new key first, and the previous key second. If :ref:`session_ticket_keys \u003cenvoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys\u003e` is not specified, the TLS library will still support resuming sessions via tickets, but it will use an internally-generated and managed key, so sessions cannot be resumed across hot restarts or on different hosts. Each key must contain exactly 80 bytes of cryptographically-secure random data. For example, the output of ``openssl rand 80``. .. attention::   Using this feature has serious security considerations and risks. Improper handling of keys   may result in loss of secrecy in connections, even if ciphers supporting perfect forward   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some   discussion. To minimize the risk, you must:   * Keep the session ticket keys at least as secure as your TLS certificate private keys   * Rotate session ticket keys at least daily, and preferably hourly   * Always generate keys using a cryptographically-secure random data source"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Tls Session Ticket Keys"
        },
        "envoy.type.matcher.v3.DoubleMatcher": {
            "properties": {
                "range": {
                    "$ref": "#/definitions/envoy.type.v3.DoubleRange",
                    "additionalProperties": true,
                    "description": "If specified, the input double value must be in the range specified here. Note: The range is using half-open interval semantics [start, end)."
                },
                "exact": {
                    "type": "number",
                    "description": "If specified, the input double value must be equal to the value specified here."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Number matcher]",
            "description": "[#protodoc-title: Number matcher]  Specifies the way to match a double value."
        },
        "envoy.type.matcher.v3.ListMatcher": {
            "properties": {
                "one_of": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.ValueMatcher",
                    "additionalProperties": true,
                    "description": "If specified, at least one of the values in the list must match the value specified."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "List Matcher",
            "description": "Specifies the way to match a list value."
        },
        "envoy.type.matcher.v3.ListStringMatcher": {
            "properties": {
                "patterns": {
                    "items": {
                        "$ref": "#/definitions/envoy.type.matcher.v3.StringMatcher"
                    },
                    "type": "array"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "List String Matcher",
            "description": "Specifies a list of ways to match a string."
        },
        "envoy.type.matcher.v3.MetadataMatcher": {
            "properties": {
                "filter": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The filter name to retrieve the Struct from the Metadata."
                },
                "path": {
                    "items": {
                        "$ref": "#/definitions/envoy.type.matcher.v3.MetadataMatcher.PathSegment"
                    },
                    "type": "array",
                    "description": "The path to retrieve the Value from the Struct."
                },
                "value": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.ValueMatcher",
                    "additionalProperties": true,
                    "description": "The MetadataMatcher is matched if the value retrieved by path is matched to this value."
                },
                "invert": {
                    "type": "boolean",
                    "description": "If true, the match result will be inverted."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "MetadataMatcher provides a general interface to check if a given value is matched in\n :ref:`Metadata \u003cenvoy_v3_api_msg_config.core.v3.Metadata\u003e`. It uses `filter` and `path` to retrieve the value\n from the Metadata and then check if it's matched to the specified value.\n\n For example, for the following Metadata:\n\n .. code-block:: yaml\n\n    filter_metadata:\n      envoy.filters.http.rbac:\n        fields:\n          a:\n            struct_value:\n              fields:\n                b:\n                  struct_value:\n                    fields:\n                      c:\n                        string_value: pro\n                t:\n                  list_value:\n                    values:\n                      - string_value: m\n                      - string_value: n\n\n The following MetadataMatcher is matched as the path [a, b, c] will retrieve a string value \"pro\"\n from the Metadata which is matched to the specified prefix match.\n\n .. code-block:: yaml\n\n    filter: envoy.filters.http.rbac\n    path:\n    - key: a\n    - key: b\n    - key: c\n    value:\n      string_match:\n        prefix: pr\n\n The following MetadataMatcher is matched as the code will match one of the string values in the\n list at the path [a, t].\n\n .. code-block:: yaml\n\n    filter: envoy.filters.http.rbac\n    path:\n    - key: a\n    - key: t\n    value:\n      list_match:\n        one_of:\n          string_match:\n            exact: m\n\n An example use of MetadataMatcher is specifying additional metadata in envoy.filters.http.rbac to\n enforce access control based on dynamic metadata in a request. See :ref:`Permission\n \u003cenvoy_v3_api_msg_config.rbac.v3.Permission\u003e` and :ref:`Principal\n \u003cenvoy_v3_api_msg_config.rbac.v3.Principal\u003e`.",
            "description": "[#protodoc-title: Metadata matcher]  MetadataMatcher provides a general interface to check if a given value is matched in :ref:`Metadata \u003cenvoy_v3_api_msg_config.core.v3.Metadata\u003e`. It uses `filter` and `path` to retrieve the value from the Metadata and then check if it's matched to the specified value. For example, for the following Metadata: .. code-block:: yaml    filter_metadata:      envoy.filters.http.rbac:        fields:          a:            struct_value:              fields:                b:                  struct_value:                    fields:                      c:                        string_value: pro                t:                  list_value:                    values:                      - string_value: m                      - string_value: n The following MetadataMatcher is matched as the path [a, b, c] will retrieve a string value \"pro\" from the Metadata which is matched to the specified prefix match. .. code-block:: yaml    filter: envoy.filters.http.rbac    path:    - key: a    - key: b    - key: c    value:      string_match:        prefix: pr The following MetadataMatcher is matched as the code will match one of the string values in the list at the path [a, t]. .. code-block:: yaml    filter: envoy.filters.http.rbac    path:    - key: a    - key: t    value:      list_match:        one_of:          string_match:            exact: m An example use of MetadataMatcher is specifying additional metadata in envoy.filters.http.rbac to enforce access control based on dynamic metadata in a request. See :ref:`Permission \u003cenvoy_v3_api_msg_config.rbac.v3.Permission\u003e` and :ref:`Principal \u003cenvoy_v3_api_msg_config.rbac.v3.Principal\u003e`.  [#next-major-version: MetadataMatcher should use StructMatcher]"
        },
        "envoy.type.matcher.v3.MetadataMatcher.PathSegment": {
            "properties": {
                "key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "If specified, use the key to retrieve the value in a Struct."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Path Segment",
            "description": "Specifies the segment in a path to retrieve value from Metadata. Note: Currently it's not supported to retrieve a value from a list in Metadata. This means that if the segment key refers to a list, it has to be the last segment in a path."
        },
        "envoy.type.matcher.v3.OrMatcher": {
            "properties": {
                "value_matchers": {
                    "items": {
                        "$ref": "#/definitions/envoy.type.matcher.v3.ValueMatcher"
                    },
                    "type": "array"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Or Matcher",
            "description": "Specifies a list of alternatives for the match."
        },
        "envoy.type.matcher.v3.RegexMatcher": {
            "properties": {
                "google_re2": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.RegexMatcher.GoogleRE2",
                    "additionalProperties": true,
                    "description": "Google's RE2 regex engine."
                },
                "regex": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The regex match string. The string must be supported by the configured engine. The regex is matched against the full string, not as a partial match."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Regex matcher]",
            "description": "[#protodoc-title: Regex matcher]  A regex matcher designed for safety when used with untrusted input."
        },
        "envoy.type.matcher.v3.RegexMatcher.GoogleRE2": {
            "properties": {
                "max_program_size": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "This field controls the RE2 \"program size\" which is a rough estimate of how complex a compiled regex is to evaluate. A regex that has a program size greater than the configured value will fail to compile. In this case, the configured max program size can be increased or the regex can be simplified. If not specified, the default is 100. This field is deprecated; regexp validation should be performed on the management server instead of being done by each individual client. .. note::  Although this field is deprecated, the program size will still be checked against the  global ``re2.max_program_size.error_level`` runtime value."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Google RE 2",
            "description": "Google's `RE2 \u003chttps://github.com/google/re2\u003e`_ regex engine. The regex string must adhere to the documented `syntax \u003chttps://github.com/google/re2/wiki/Syntax\u003e`_. The engine is designed to complete execution in linear time as well as limit the amount of memory used. Envoy supports program size checking via runtime. The runtime keys ``re2.max_program_size.error_level`` and ``re2.max_program_size.warn_level`` can be set to integers as the maximum program size or complexity that a compiled regex can have before an exception is thrown or a warning is logged, respectively. ``re2.max_program_size.error_level`` defaults to 100, and ``re2.max_program_size.warn_level`` has no default if unset (will not check/log a warning). Envoy emits two stats for tracking the program size of regexes: the histogram ``re2.program_size``, which records the program size, and the counter ``re2.exceeded_warn_level``, which is incremented each time the program size exceeds the warn level threshold."
        },
        "envoy.type.matcher.v3.StringMatcher": {
            "properties": {
                "exact": {
                    "type": "string",
                    "description": "The input string must match exactly the string specified here. Examples: * ``abc`` only matches the value ``abc``."
                },
                "prefix": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead. Examples: * ``abc`` matches the value ``abc.xyz``"
                },
                "suffix": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead. Examples: * ``abc`` matches the value ``xyz.abc``"
                },
                "safe_regex": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.RegexMatcher",
                    "additionalProperties": true,
                    "description": "The input string must match the regular expression specified here."
                },
                "contains": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead. Examples: * ``abc`` matches the value ``xyz.abc.def``"
                },
                "custom": {
                    "$ref": "#/definitions/xds.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Use an extension as the matcher type. [#extension-category: envoy.string_matcher]"
                },
                "ignore_case": {
                    "type": "boolean",
                    "description": "If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. This has no effect for the safe_regex match. For example, the matcher ``data`` will match both input string ``Data`` and ``data`` if set to true."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: String matcher]",
            "description": "[#protodoc-title: String matcher]  Specifies the way to match a string. [#next-free-field: 9]"
        },
        "envoy.type.matcher.v3.ValueMatcher": {
            "properties": {
                "null_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.ValueMatcher.NullMatch",
                    "additionalProperties": true,
                    "description": "If specified, a match occurs if and only if the target value is a NullValue."
                },
                "double_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.DoubleMatcher",
                    "additionalProperties": true,
                    "description": "If specified, a match occurs if and only if the target value is a double value and is matched to this field."
                },
                "string_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.StringMatcher",
                    "additionalProperties": true,
                    "description": "If specified, a match occurs if and only if the target value is a string value and is matched to this field."
                },
                "bool_match": {
                    "type": "boolean",
                    "description": "If specified, a match occurs if and only if the target value is a bool value and is equal to this field."
                },
                "present_match": {
                    "type": "boolean",
                    "description": "If specified, value match will be performed based on whether the path is referring to a valid primitive value in the metadata. If the path is referring to a non-primitive value, the result is always not matched."
                },
                "list_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.ListMatcher",
                    "additionalProperties": true,
                    "description": "If specified, a match occurs if and only if the target value is a list value and is matched to this field."
                },
                "or_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.OrMatcher",
                    "additionalProperties": true,
                    "description": "If specified, a match occurs if and only if any of the alternatives in the match accept the value."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Value matcher]",
            "description": "[#protodoc-title: Value matcher]  Specifies the way to match a ProtobufWkt::Value. Primitive values and ListValue are supported. StructValue is not supported and is always not matched. [#next-free-field: 8]"
        },
        "envoy.type.matcher.v3.ValueMatcher.NullMatch": {
            "additionalProperties": true,
            "type": "object",
            "title": "Null Match",
            "description": "NullMatch is an empty message to specify a null value."
        },
        "envoy.type.metadata.v3.MetadataKey": {
            "properties": {
                "key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The key name of Metadata to retrieve the Struct from the metadata. Typically, it represents a builtin subsystem or custom extension."
                },
                "path": {
                    "items": {
                        "$ref": "#/definitions/envoy.type.metadata.v3.MetadataKey.PathSegment"
                    },
                    "type": "array",
                    "description": "The path to retrieve the Value from the Struct. It can be a prefix or a full path, e.g. ``[prop, xyz]`` for a struct or ``[prop, foo]`` for a string in the example, which depends on the particular scenario. Note: Due to that only the key type segment is supported, the path can not specify a list unless the list is the last segment."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Metadata]",
            "description": "[#protodoc-title: Metadata]  MetadataKey provides a general interface using ``key`` and ``path`` to retrieve value from :ref:`Metadata \u003cenvoy_v3_api_msg_config.core.v3.Metadata\u003e`. For example, for the following Metadata: .. code-block:: yaml    filter_metadata:      envoy.xxx:        prop:          foo: bar          xyz:            hello: envoy The following MetadataKey will retrieve a string value \"bar\" from the Metadata. .. code-block:: yaml    key: envoy.xxx    path:    - key: prop    - key: foo"
        },
        "envoy.type.metadata.v3.MetadataKey.PathSegment": {
            "properties": {
                "key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "If specified, use the key to retrieve the value in a Struct."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Path Segment",
            "description": "Specifies the segment in a path to retrieve value from Metadata. Currently it is only supported to specify the key, i.e. field name, as one segment of a path."
        },
        "envoy.type.v3.DoubleRange": {
            "properties": {
                "start": {
                    "type": "number",
                    "description": "start of the range (inclusive)"
                },
                "end": {
                    "type": "number",
                    "description": "end of the range (exclusive)"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Double Range",
            "description": "Specifies the double start and end of the range using half-open interval semantics [start, end)."
        },
        "envoy.type.v3.FractionalPercent": {
            "properties": {
                "numerator": {
                    "type": "integer",
                    "description": "Specifies the numerator. Defaults to 0."
                },
                "denominator": {
                    "enum": [
                        "HUNDRED",
                        0,
                        "TEN_THOUSAND",
                        1,
                        "MILLION",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Denominator Type",
                    "description": "Fraction percentages support several fixed denominator values."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Fractional Percent",
            "description": "A fractional percentage is used in cases in which for performance reasons performing floating point to integer conversions during randomness calculations is undesirable. The message includes both a numerator and denominator that together determine the final fractional value. * **Example**: 1/100 = 1%. * **Example**: 3/10000 = 0.03%."
        },
        "envoy.type.v3.Int32Range": {
            "properties": {
                "start": {
                    "type": "integer",
                    "description": "start of the range (inclusive)"
                },
                "end": {
                    "type": "integer",
                    "description": "end of the range (exclusive)"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Int 32 Range",
            "description": "Specifies the int32 start and end of the range using half-open interval semantics [start, end)."
        },
        "envoy.type.v3.Int64Range": {
            "properties": {
                "start": {
                    "type": "string",
                    "description": "start of the range (inclusive)"
                },
                "end": {
                    "type": "string",
                    "description": "end of the range (exclusive)"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Range]",
            "description": "[#protodoc-title: Range]  Specifies the int64 start and end of the range using half-open interval semantics [start, end)."
        },
        "envoy.type.v3.Percent": {
            "properties": {
                "value": {
                    "type": "number"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Percent]",
            "description": "[#protodoc-title: Percent]  Identifies a percentage, in the range [0.0, 100.0]."
        },
        "envoy.type.v3.SemanticVersion": {
            "properties": {
                "major_number": {
                    "type": "integer"
                },
                "minor_number": {
                    "type": "integer"
                },
                "patch": {
                    "type": "integer"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Semantic version]",
            "description": "[#protodoc-title: Semantic version]  Envoy uses SemVer (https://semver.org/). Major/minor versions indicate expected behaviors and APIs, the patch version field is used only for security fixes and can be generally ignored."
        },
        "xds.core.v3.Authority": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Authority",
            "description": "xDS authority information."
        },
        "xds.core.v3.ContextParams": {
            "properties": {
                "params": {
                    "additionalProperties": {
                        "type": "string"
                    },
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Context Params",
            "description": "Additional parameters that can be used to select resource variants. These include any global context parameters, per-resource type client feature capabilities and per-resource type functional attributes. All per-resource type attributes will be `xds.resource.` prefixed and some of these are documented below: `xds.resource.listening_address`: The value is \"IP:port\" (e.g. \"10.1.1.3:8080\") which is   the listening address of a Listener. Used in a Listener resource query."
        },
        "xds.core.v3.TypedExtensionConfig": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of an extension. This is not used to select the extension, instead it serves the role of an opaque identifier."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "The typed config for the extension. The type URL will be used to identify the extension. In the case that the type URL is *xds.type.v3.TypedStruct* (or, for historical reasons, *udpa.type.v1.TypedStruct*), the inner type URL of *TypedStruct* will be utilized. See the :ref:`extension configuration overview \u003cconfig_overview_extension_configuration\u003e` for further details."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Typed Extension Config",
            "description": "Message type for extension configuration."
        },
        "xds.type.matcher.v3.Matcher": {
            "properties": {
                "matcher_list": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherList",
                    "additionalProperties": true,
                    "description": "A linear list of matchers to evaluate."
                },
                "matcher_tree": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherTree",
                    "additionalProperties": true,
                    "description": "A match tree to evaluate."
                },
                "on_no_match": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.OnMatch",
                    "additionalProperties": true,
                    "description": "Optional OnMatch to use if no matcher above matched (e.g., if there are no matchers specified above, or if none of the matches specified above succeeded). If no matcher above matched and this field is not populated, the match will be considered unsuccessful."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Unified Matcher API]",
            "description": "[#protodoc-title: Unified Matcher API]  A matcher, which may traverse a matching tree in order to result in a match action. During matching, the tree will be traversed until a match is found, or if no match is found the action specified by the most specific on_no_match will be evaluated. As an on_no_match might result in another matching tree being evaluated, this process might repeat several times until the final OnMatch (or no match) is decided."
        },
        "xds.type.matcher.v3.Matcher.MatcherList": {
            "properties": {
                "matchers": {
                    "items": {
                        "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherList.FieldMatcher"
                    },
                    "type": "array",
                    "description": "A list of matchers. First match wins."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Matcher List",
            "description": "A linear list of field matchers. The field matchers are evaluated in order, and the first match wins."
        },
        "xds.type.matcher.v3.Matcher.MatcherList.FieldMatcher": {
            "properties": {
                "predicate": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherList.Predicate",
                    "additionalProperties": true,
                    "description": "Determines if the match succeeds."
                },
                "on_match": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.OnMatch",
                    "additionalProperties": true,
                    "description": "What to do if the match succeeds."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Field Matcher",
            "description": "An individual matcher."
        },
        "xds.type.matcher.v3.Matcher.MatcherList.Predicate": {
            "properties": {
                "single_predicate": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate",
                    "additionalProperties": true,
                    "description": "A single predicate to evaluate."
                },
                "or_matcher": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherList.Predicate.PredicateList",
                    "additionalProperties": true,
                    "description": "A list of predicates to be OR-ed together."
                },
                "and_matcher": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherList.Predicate.PredicateList",
                    "additionalProperties": true,
                    "description": "A list of predicates to be AND-ed together."
                },
                "not_matcher": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherList.Predicate",
                    "additionalProperties": true,
                    "description": "The invert of a predicate"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Predicate",
            "description": "Predicate to determine if a match is successful."
        },
        "xds.type.matcher.v3.Matcher.MatcherList.Predicate.PredicateList": {
            "properties": {
                "predicate": {
                    "items": {
                        "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherList.Predicate"
                    },
                    "type": "array"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Predicate List",
            "description": "A list of two or more matchers. Used to allow using a list within a oneof."
        },
        "xds.type.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate": {
            "properties": {
                "input": {
                    "$ref": "#/definitions/xds.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Protocol-specific specification of input field to match on. [#extension-category: envoy.matching.common_inputs]"
                },
                "value_match": {
                    "$ref": "#/definitions/xds.type.matcher.v3.StringMatcher",
                    "additionalProperties": true,
                    "description": "Built-in string matcher."
                },
                "custom_match": {
                    "$ref": "#/definitions/xds.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Extension for custom matching logic. [#extension-category: envoy.matching.input_matchers]"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Single Predicate",
            "description": "Predicate for a single input field."
        },
        "xds.type.matcher.v3.Matcher.MatcherTree": {
            "properties": {
                "input": {
                    "$ref": "#/definitions/xds.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Protocol-specific specification of input field to match on."
                },
                "exact_match_map": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherTree.MatchMap",
                    "additionalProperties": true
                },
                "prefix_match_map": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher.MatcherTree.MatchMap",
                    "additionalProperties": true,
                    "description": "Longest matching prefix wins."
                },
                "custom_match": {
                    "$ref": "#/definitions/xds.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Extension for custom matching logic."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Matcher Tree"
        },
        "xds.type.matcher.v3.Matcher.MatcherTree.MatchMap": {
            "properties": {
                "map": {
                    "additionalProperties": {
                        "$ref": "#/definitions/xds.type.matcher.v3.Matcher.OnMatch",
                        "additionalProperties": true
                    },
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Match Map",
            "description": "A map of configured matchers. Used to allow using a map within a oneof."
        },
        "xds.type.matcher.v3.Matcher.OnMatch": {
            "properties": {
                "matcher": {
                    "$ref": "#/definitions/xds.type.matcher.v3.Matcher",
                    "additionalProperties": true,
                    "description": "Nested matcher to evaluate. If the nested matcher does not match and does not specify on_no_match, then this matcher is considered not to have matched, even if a predicate at this level or above returned true."
                },
                "action": {
                    "$ref": "#/definitions/xds.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Protocol-specific action to take."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "On Match",
            "description": "What to do if a match is successful."
        },
        "xds.type.matcher.v3.RegexMatcher": {
            "properties": {
                "google_re2": {
                    "$ref": "#/definitions/xds.type.matcher.v3.RegexMatcher.GoogleRE2",
                    "additionalProperties": true,
                    "description": "Google's RE2 regex engine."
                },
                "regex": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The regex match string. The string must be supported by the configured engine."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Regex matcher]",
            "description": "[#protodoc-title: Regex matcher]  A regex matcher designed for safety when used with untrusted input."
        },
        "xds.type.matcher.v3.RegexMatcher.GoogleRE2": {
            "additionalProperties": true,
            "type": "object",
            "title": "Google RE 2",
            "description": "Google's `RE2 \u003chttps://github.com/google/re2\u003e`_ regex engine. The regex string must adhere to the documented `syntax \u003chttps://github.com/google/re2/wiki/Syntax\u003e`_. The engine is designed to complete execution in linear time as well as limit the amount of memory used. Envoy supports program size checking via runtime. The runtime keys `re2.max_program_size.error_level` and `re2.max_program_size.warn_level` can be set to integers as the maximum program size or complexity that a compiled regex can have before an exception is thrown or a warning is logged, respectively. `re2.max_program_size.error_level` defaults to 100, and `re2.max_program_size.warn_level` has no default if unset (will not check/log a warning). Envoy emits two stats for tracking the program size of regexes: the histogram `re2.program_size`, which records the program size, and the counter `re2.exceeded_warn_level`, which is incremented each time the program size exceeds the warn level threshold."
        },
        "xds.type.matcher.v3.StringMatcher": {
            "properties": {
                "exact": {
                    "type": "string",
                    "description": "The input string must match exactly the string specified here. Examples: * *abc* only matches the value *abc*."
                },
                "prefix": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead. Examples: * *abc* matches the value *abc.xyz*"
                },
                "suffix": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead. Examples: * *abc* matches the value *xyz.abc*"
                },
                "safe_regex": {
                    "$ref": "#/definitions/xds.type.matcher.v3.RegexMatcher",
                    "additionalProperties": true,
                    "description": "The input string must match the regular expression specified here."
                },
                "contains": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead. Examples: * *abc* matches the value *xyz.abc.def*"
                },
                "custom": {
                    "$ref": "#/definitions/xds.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Use an extension as the matcher type. [#extension-category: envoy.string_matcher]"
                },
                "ignore_case": {
                    "type": "boolean",
                    "description": "If true, indicates the exact/prefix/suffix matching should be case insensitive. This has no effect for the safe_regex match. For example, the matcher *data* will match both input string *Data* and *data* if set to true."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: String matcher]",
            "description": "[#protodoc-title: String matcher]  Specifies the way to match a string. [#next-free-field: 9]"
        }
    }
}