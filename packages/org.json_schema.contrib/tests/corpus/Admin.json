{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "$ref": "#/definitions/Admin",
    "$package": "envoy.config.bootstrap.v3",
    "definitions": {
        "Admin": {
            "properties": {
                "access_log": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.accesslog.v3.AccessLog"
                    },
                    "type": "array",
                    "description": "Configuration for :ref:`access logs \u003carch_overview_access_logs\u003e` emitted by the administration server."
                },
                "access_log_path": {
                    "type": "string",
                    "description": "The path to write the access log for the administration server. If no access log is desired specify ‘/dev/null’. This is only required if :ref:`address \u003cenvoy_v3_api_field_config.bootstrap.v3.Admin.address\u003e` is set. Deprecated in favor of ``access_log`` which offers more options."
                },
                "profile_path": {
                    "type": "string",
                    "description": "The cpu profiler output path for the administration server. If no profile path is specified, the default is ‘/var/log/envoy/envoy.prof’."
                },
                "address": {
                    "$ref": "#/definitions/envoy.config.core.v3.Address",
                    "additionalProperties": true,
                    "description": "The TCP address that the administration server will listen on. If not specified, Envoy will not start an administration server."
                },
                "socket_options": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.core.v3.SocketOption"
                    },
                    "type": "array",
                    "description": "Additional socket options that may not be present in Envoy source code or precompiled binaries."
                },
                "ignore_global_conn_limit": {
                    "type": "boolean",
                    "description": "Indicates whether :ref:`global_downstream_max_connections \u003cconfig_overload_manager_limiting_connections\u003e` should apply to the admin interface or not."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Admin",
            "description": "Administration interface :ref:`operations documentation \u003coperations_admin_interface\u003e`. [#next-free-field: 7]"
        },
        "envoy.config.accesslog.v3.AccessLog": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the access log extension configuration."
                },
                "filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.AccessLogFilter",
                    "additionalProperties": true,
                    "description": "Filter which is used to determine if the access log needs to be written."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Common access log types]",
            "description": "[#protodoc-title: Common access log types]"
        },
        "envoy.config.accesslog.v3.AccessLogFilter": {
            "properties": {
                "status_code_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.StatusCodeFilter",
                    "additionalProperties": true,
                    "description": "Status code filter."
                },
                "duration_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.DurationFilter",
                    "additionalProperties": true,
                    "description": "Duration filter."
                },
                "not_health_check_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.NotHealthCheckFilter",
                    "additionalProperties": true,
                    "description": "Not health check filter."
                },
                "traceable_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.TraceableFilter",
                    "additionalProperties": true,
                    "description": "Traceable filter."
                },
                "runtime_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.RuntimeFilter",
                    "additionalProperties": true,
                    "description": "Runtime filter."
                },
                "and_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.AndFilter",
                    "additionalProperties": true,
                    "description": "And filter."
                },
                "or_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.OrFilter",
                    "additionalProperties": true,
                    "description": "Or filter."
                },
                "header_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.HeaderFilter",
                    "additionalProperties": true,
                    "description": "Header filter."
                },
                "response_flag_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.ResponseFlagFilter",
                    "additionalProperties": true,
                    "description": "Response flag filter."
                },
                "grpc_status_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.GrpcStatusFilter",
                    "additionalProperties": true,
                    "description": "gRPC status filter."
                },
                "extension_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.ExtensionFilter",
                    "additionalProperties": true,
                    "description": "Extension filter. [#extension-category: envoy.access_loggers.extension_filters]"
                },
                "metadata_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.MetadataFilter",
                    "additionalProperties": true,
                    "description": "Metadata Filter"
                },
                "log_type_filter": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.LogTypeFilter",
                    "additionalProperties": true,
                    "description": "Log Type Filter"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Access Log Filter",
            "description": "[#next-free-field: 14]"
        },
        "envoy.config.accesslog.v3.AndFilter": {
            "properties": {
                "filters": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.accesslog.v3.AccessLogFilter"
                    },
                    "type": "array"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "And Filter",
            "description": "Performs a logical “and” operation on the result of each filter in filters. Filters are evaluated sequentially and if one of them returns false, the filter returns false immediately."
        },
        "envoy.config.accesslog.v3.ComparisonFilter": {
            "properties": {
                "op": {
                    "enum": [
                        "EQ",
                        0,
                        "GE",
                        1,
                        "LE",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Op"
                },
                "value": {
                    "$ref": "#/definitions/envoy.config.core.v3.RuntimeUInt32",
                    "additionalProperties": true,
                    "description": "Value to compare against."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Comparison Filter",
            "description": "Filter on an integer comparison."
        },
        "envoy.config.accesslog.v3.DurationFilter": {
            "properties": {
                "comparison": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.ComparisonFilter",
                    "additionalProperties": true,
                    "description": "Comparison."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Duration Filter",
            "description": "Filters based on the duration of the request or stream, in milliseconds. For end of stream access logs, the total duration of the stream will be used. For :ref:`periodic access logs\u003carch_overview_access_log_periodic\u003e`, the duration of the stream at the time of log recording will be used."
        },
        "envoy.config.accesslog.v3.ExtensionFilter": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the filter implementation to instantiate. The name must match a statically registered filter."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Extension Filter",
            "description": "Extension filter is statically registered at runtime."
        },
        "envoy.config.accesslog.v3.GrpcStatusFilter": {
            "properties": {
                "statuses": {
                    "items": {
                        "enum": [
                            "OK",
                            0,
                            "CANCELED",
                            1,
                            "UNKNOWN",
                            2,
                            "INVALID_ARGUMENT",
                            3,
                            "DEADLINE_EXCEEDED",
                            4,
                            "NOT_FOUND",
                            5,
                            "ALREADY_EXISTS",
                            6,
                            "PERMISSION_DENIED",
                            7,
                            "RESOURCE_EXHAUSTED",
                            8,
                            "FAILED_PRECONDITION",
                            9,
                            "ABORTED",
                            10,
                            "OUT_OF_RANGE",
                            11,
                            "UNIMPLEMENTED",
                            12,
                            "INTERNAL",
                            13,
                            "UNAVAILABLE",
                            14,
                            "DATA_LOSS",
                            15,
                            "UNAUTHENTICATED",
                            16
                        ]
                    },
                    "type": "array",
                    "title": "Status"
                },
                "exclude": {
                    "type": "boolean",
                    "description": "If included and set to true, the filter will instead block all responses with a gRPC status or inferred gRPC status enumerated in statuses, and allow all other responses."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Grpc Status Filter",
            "description": "Filters gRPC requests based on their response status. If a gRPC status is not provided, the filter will infer the status from the HTTP status code."
        },
        "envoy.config.accesslog.v3.HeaderFilter": {
            "properties": {
                "header": {
                    "$ref": "#/definitions/envoy.config.route.v3.HeaderMatcher",
                    "additionalProperties": true,
                    "description": "Only requests with a header which matches the specified HeaderMatcher will pass the filter check."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Header Filter",
            "description": "Filters requests based on the presence or value of a request header."
        },
        "envoy.config.accesslog.v3.LogTypeFilter": {
            "properties": {
                "types": {
                    "items": {
                        "enum": [
                            "NotSet",
                            0,
                            "TcpUpstreamConnected",
                            1,
                            "TcpPeriodic",
                            2,
                            "TcpConnectionEnd",
                            3,
                            "DownstreamStart",
                            4,
                            "DownstreamPeriodic",
                            5,
                            "DownstreamEnd",
                            6,
                            "UpstreamPoolReady",
                            7,
                            "UpstreamPeriodic",
                            8,
                            "UpstreamEnd",
                            9,
                            "DownstreamTunnelSuccessfullyEstablished",
                            10,
                            "UdpTunnelUpstreamConnected",
                            11,
                            "UdpPeriodic",
                            12,
                            "UdpSessionEnd",
                            13
                        ]
                    },
                    "type": "array",
                    "title": "[#protodoc-title: gRPC access logs]\n Envoy access logs describe incoming interaction with Envoy over a fixed\n period of time, and typically cover a single request/response exchange,\n (e.g. HTTP), stream (e.g. over HTTP/gRPC), or proxied connection (e.g. TCP).\n Access logs contain fields defined in protocol-specific protobuf messages.\n\n Except where explicitly declared otherwise, all fields describe\n *downstream* interaction between Envoy and a connected client.\n Fields describing *upstream* interaction will explicitly include ``upstream``\n in their name.",
                    "description": "[#protodoc-title: gRPC access logs] Envoy access logs describe incoming interaction with Envoy over a fixed period of time, and typically cover a single request/response exchange, (e.g. HTTP), stream (e.g. over HTTP/gRPC), or proxied connection (e.g. TCP). Access logs contain fields defined in protocol-specific protobuf messages. Except where explicitly declared otherwise, all fields describe *downstream* interaction between Envoy and a connected client. Fields describing *upstream* interaction will explicitly include ``upstream`` in their name."
                },
                "exclude": {
                    "type": "boolean",
                    "description": "If this field is set to true, the filter will instead block all records with a access log type in types field, and allow all other records."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Log Type Filter",
            "description": "Filters based on access log type."
        },
        "envoy.config.accesslog.v3.MetadataFilter": {
            "properties": {
                "matcher": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.MetadataMatcher",
                    "additionalProperties": true,
                    "description": "Matcher to check metadata for specified value. For example, to match on the access_log_hint metadata, set the filter to \"envoy.common\" and the path to \"access_log_hint\", and the value to \"true\"."
                },
                "match_if_key_not_found": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Default result if the key does not exist in dynamic metadata: if unset or true, then log; if false, then don't log."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata Filter",
            "description": "Filters based on matching dynamic metadata. If the matcher path and key correspond to an existing key in dynamic metadata, the request is logged only if the matcher value is equal to the metadata value. If the matcher path and key *do not* correspond to an existing key in dynamic metadata, the request is logged only if match_if_key_not_found is \"true\" or unset."
        },
        "envoy.config.accesslog.v3.NotHealthCheckFilter": {
            "additionalProperties": true,
            "type": "object",
            "title": "Not Health Check Filter",
            "description": "Filters for requests that are not health check requests. A health check request is marked by the health check filter."
        },
        "envoy.config.accesslog.v3.OrFilter": {
            "properties": {
                "filters": {
                    "items": {
                        "$ref": "#/definitions/envoy.config.accesslog.v3.AccessLogFilter"
                    },
                    "type": "array"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Or Filter",
            "description": "Performs a logical “or” operation on the result of each individual filter. Filters are evaluated sequentially and if one of them returns true, the filter returns true immediately."
        },
        "envoy.config.accesslog.v3.ResponseFlagFilter": {
            "properties": {
                "flags": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "Only responses with the any of the flags listed in this field will be logged. This field is optional. If it is not specified, then any response flag will pass the filter check."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Response Flag Filter",
            "description": "Filters requests that received responses with an Envoy response flag set. A list of the response flags can be found in the access log formatter :ref:`documentation\u003cconfig_access_log_format_response_flags\u003e`."
        },
        "envoy.config.accesslog.v3.RuntimeFilter": {
            "properties": {
                "runtime_key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Runtime key to get an optional overridden numerator for use in the ``percent_sampled`` field. If found in runtime, this value will replace the default numerator."
                },
                "percent_sampled": {
                    "$ref": "#/definitions/envoy.type.v3.FractionalPercent",
                    "additionalProperties": true,
                    "description": "The default sampling percentage. If not specified, defaults to 0% with denominator of 100."
                },
                "use_independent_randomness": {
                    "type": "boolean",
                    "description": "By default, sampling pivots on the header :ref:`x-request-id\u003cconfig_http_conn_man_headers_x-request-id\u003e` being present. If :ref:`x-request-id\u003cconfig_http_conn_man_headers_x-request-id\u003e` is present, the filter will consistently sample across multiple hosts based on the runtime key value and the value extracted from :ref:`x-request-id\u003cconfig_http_conn_man_headers_x-request-id\u003e`. If it is missing, or ``use_independent_randomness`` is set to true, the filter will randomly sample based on the runtime key value alone. ``use_independent_randomness`` can be used for logging kill switches within complex nested :ref:`AndFilter \u003cenvoy_v3_api_msg_config.accesslog.v3.AndFilter\u003e` and :ref:`OrFilter \u003cenvoy_v3_api_msg_config.accesslog.v3.OrFilter\u003e` blocks that are easier to reason about from a probability perspective (i.e., setting to true will cause the filter to behave like an independent random variable when composed within logical operator filters)."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Runtime Filter",
            "description": "Filters for random sampling of requests."
        },
        "envoy.config.accesslog.v3.StatusCodeFilter": {
            "properties": {
                "comparison": {
                    "$ref": "#/definitions/envoy.config.accesslog.v3.ComparisonFilter",
                    "additionalProperties": true,
                    "description": "Comparison."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Status Code Filter",
            "description": "Filters on HTTP response/status code."
        },
        "envoy.config.accesslog.v3.TraceableFilter": {
            "additionalProperties": true,
            "type": "object",
            "title": "Traceable Filter",
            "description": "Filters for requests that are traceable. See the tracing overview for more information on how a request becomes traceable."
        },
        "envoy.config.core.v3.Address": {
            "properties": {
                "socket_address": {
                    "$ref": "#/definitions/envoy.config.core.v3.SocketAddress",
                    "additionalProperties": true
                },
                "pipe": {
                    "$ref": "#/definitions/envoy.config.core.v3.Pipe",
                    "additionalProperties": true
                },
                "envoy_internal_address": {
                    "$ref": "#/definitions/envoy.config.core.v3.EnvoyInternalAddress",
                    "additionalProperties": true,
                    "description": "Specifies a user-space address handled by :ref:`internal listeners \u003cenvoy_v3_api_field_config.listener.v3.Listener.internal_listener\u003e`."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Address",
            "description": "Addresses specify either a logical or physical address and port, which are used to tell Envoy where to bind/listen, connect to upstream and find management servers."
        },
        "envoy.config.core.v3.EnvoyInternalAddress": {
            "properties": {
                "server_listener_name": {
                    "type": "string",
                    "description": "Specifies the :ref:`name \u003cenvoy_v3_api_field_config.listener.v3.Listener.name\u003e` of the internal listener."
                },
                "endpoint_id": {
                    "type": "string",
                    "description": "Specifies an endpoint identifier to distinguish between multiple endpoints for the same internal listener in a single upstream pool. Only used in the upstream addresses for tracking changes to individual endpoints. This, for example, may be set to the final destination IP for the target internal listener."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Envoy Internal Address",
            "description": "The address represents an envoy internal listener. [#comment: TODO(asraa): When address available, remove workaround from test/server/server_fuzz_test.cc:30.]"
        },
        "envoy.config.core.v3.Pipe": {
            "properties": {
                "path": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Unix Domain Socket path. On Linux, paths starting with '@' will use the abstract namespace. The starting '@' is replaced by a null byte by Envoy. Paths starting with '@' will result in an error in environments other than Linux."
                },
                "mode": {
                    "type": "integer",
                    "description": "The mode for the Pipe. Not applicable for abstract sockets."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Network addresses]",
            "description": "[#protodoc-title: Network addresses]"
        },
        "envoy.config.core.v3.RuntimeUInt32": {
            "properties": {
                "default_value": {
                    "type": "integer",
                    "description": "Default value if runtime value is not available."
                },
                "runtime_key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Runtime key to get value for comparison. This value is used if defined."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Runtime U Int 32",
            "description": "Runtime derived uint32 with a default when not specified."
        },
        "envoy.config.core.v3.SocketAddress": {
            "properties": {
                "protocol": {
                    "enum": [
                        "TCP",
                        0,
                        "UDP",
                        1
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Protocol"
                },
                "address": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The address for this socket. :ref:`Listeners \u003cconfig_listeners\u003e` will bind to the address. An empty address is not allowed. Specify ``0.0.0.0`` or ``::`` to bind to any address. [#comment:TODO(zuercher) reinstate when implemented: It is possible to distinguish a Listener address via the prefix/suffix matching in :ref:`FilterChainMatch \u003cenvoy_v3_api_msg_config.listener.v3.FilterChainMatch\u003e`.] When used within an upstream :ref:`BindConfig \u003cenvoy_v3_api_msg_config.core.v3.BindConfig\u003e`, the address controls the source address of outbound connections. For :ref:`clusters \u003cenvoy_v3_api_msg_config.cluster.v3.Cluster\u003e`, the cluster type determines whether the address must be an IP (``STATIC`` or ``EDS`` clusters) or a hostname resolved by DNS (``STRICT_DNS`` or ``LOGICAL_DNS`` clusters). Address resolution can be customized via :ref:`resolver_name \u003cenvoy_v3_api_field_config.core.v3.SocketAddress.resolver_name\u003e`."
                },
                "port_value": {
                    "type": "integer"
                },
                "named_port": {
                    "type": "string",
                    "description": "This is only valid if :ref:`resolver_name \u003cenvoy_v3_api_field_config.core.v3.SocketAddress.resolver_name\u003e` is specified below and the named resolver is capable of named port resolution."
                },
                "resolver_name": {
                    "type": "string",
                    "description": "The name of the custom resolver. This must have been registered with Envoy. If this is empty, a context dependent default applies. If the address is a concrete IP address, no resolution will occur. If address is a hostname this should be set for resolution other than DNS. Specifying a custom resolver with ``STRICT_DNS`` or ``LOGICAL_DNS`` will generate an error at runtime."
                },
                "ipv4_compat": {
                    "type": "boolean",
                    "description": "When binding to an IPv6 address above, this enables `IPv4 compatibility \u003chttps://tools.ietf.org/html/rfc3493#page-11\u003e`_. Binding to ``::`` will allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into IPv6 space as ``::FFFF:\u003cIPv4-address\u003e``."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Socket Address",
            "description": "[#next-free-field: 7]"
        },
        "envoy.config.core.v3.SocketOption": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "An optional name to give this socket option for debugging, etc. Uniqueness is not required and no special meaning is assumed."
                },
                "level": {
                    "type": "string",
                    "description": "Corresponding to the level value passed to setsockopt, such as IPPROTO_TCP"
                },
                "name": {
                    "type": "string",
                    "description": "The numeric name as passed to setsockopt"
                },
                "int_value": {
                    "type": "string",
                    "description": "Because many sockopts take an int value."
                },
                "buf_value": {
                    "type": "string",
                    "description": "Otherwise it's a byte buffer.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "state": {
                    "enum": [
                        "STATE_PREBIND",
                        0,
                        "STATE_BOUND",
                        1,
                        "STATE_LISTENING",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Socket State"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Socket option]",
            "description": "[#protodoc-title: Socket option]  Generic socket option message. This would be used to set socket options that might not exist in upstream kernels or precompiled Envoy binaries. For example: .. code-block:: json  {    \"description\": \"support tcp keep alive\",    \"state\": 0,    \"level\": 1,    \"name\": 9,    \"int_value\": 1,  } 1 means SOL_SOCKET and 9 means SO_KEEPALIVE on Linux. With the above configuration, `TCP Keep-Alives \u003chttps://www.freesoft.org/CIE/RFC/1122/114.htm\u003e`_ can be enabled in socket with Linux, which can be used in :ref:`listener's\u003cenvoy_v3_api_field_config.listener.v3.Listener.socket_options\u003e` or :ref:`admin's \u003cenvoy_v3_api_field_config.bootstrap.v3.Admin.socket_options\u003e` socket_options etc. It should be noted that the name or level may have different values on different platforms. [#next-free-field: 7]"
        },
        "envoy.config.route.v3.HeaderMatcher": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "Specifies the name of the header in the request."
                },
                "exact_match": {
                    "type": "string",
                    "description": "If specified, header match will be performed based on the value of the header. This field is deprecated. Please use :ref:`string_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.string_match\u003e`."
                },
                "safe_regex_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.RegexMatcher",
                    "additionalProperties": true,
                    "description": "If specified, this regex string is a regular expression rule which implies the entire request header value must match the regex. The rule will not match if only a subsequence of the request header value matches the regex. This field is deprecated. Please use :ref:`string_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.string_match\u003e`."
                },
                "range_match": {
                    "$ref": "#/definitions/envoy.type.v3.Int64Range",
                    "additionalProperties": true,
                    "description": "If specified, header match will be performed based on range. The rule will match if the request header value is within this range. The entire request header value must represent an integer in base 10 notation: consisting of an optional plus or minus sign followed by a sequence of digits. The rule will not match if the header value does not represent an integer. Match will fail for empty values, floating point numbers or if only a subsequence of the header value is an integer. Examples: * For range [-10,0), route will match for header value -1, but not for 0, ``somestring``, 10.9,   ``-1somestring``"
                },
                "present_match": {
                    "type": "boolean",
                    "description": "If specified as true, header match will be performed based on whether the header is in the request. If specified as false, header match will be performed based on whether the header is absent."
                },
                "prefix_match": {
                    "minLength": 1,
                    "type": "string",
                    "description": "If specified, header match will be performed based on the prefix of the header value. Note: empty prefix is not allowed, please use present_match instead. This field is deprecated. Please use :ref:`string_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.string_match\u003e`. Examples: * The prefix ``abcd`` matches the value ``abcdxyz``, but not for ``abcxyz``."
                },
                "suffix_match": {
                    "minLength": 1,
                    "type": "string",
                    "description": "If specified, header match will be performed based on the suffix of the header value. Note: empty suffix is not allowed, please use present_match instead. This field is deprecated. Please use :ref:`string_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.string_match\u003e`. Examples: * The suffix ``abcd`` matches the value ``xyzabcd``, but not for ``xyzbcd``."
                },
                "contains_match": {
                    "minLength": 1,
                    "type": "string",
                    "description": "If specified, header match will be performed based on whether the header value contains the given value or not. Note: empty contains match is not allowed, please use present_match instead. This field is deprecated. Please use :ref:`string_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.string_match\u003e`. Examples: * The value ``abcd`` matches the value ``xyzabcdpqr``, but not for ``xyzbcdpqr``."
                },
                "string_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.StringMatcher",
                    "additionalProperties": true,
                    "description": "If specified, header match will be performed based on the string match of the header value."
                },
                "invert_match": {
                    "type": "boolean",
                    "description": "If specified, the match result will be inverted before checking. Defaults to false. Examples: * The regex ``\\d{3}`` does not match the value ``1234``, so it will match when inverted. * The range [-10,0) will match the value -1, so it will not match when inverted."
                },
                "treat_missing_header_as_empty": {
                    "type": "boolean",
                    "description": "If specified, for any header match rule, if the header match rule specified header does not exist, this header value will be treated as empty. Defaults to false. Examples: * The header match rule specified header \"header1\" to range match of [0, 10],   :ref:`invert_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.invert_match\u003e`   is set to true and :ref:`treat_missing_header_as_empty \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty\u003e`   is set to true; The \"header1\" header is not present. The match rule will   treat the \"header1\" as an empty header. The empty header does not match the range,   so it will match when inverted. * The header match rule specified header \"header2\" to range match of [0, 10],   :ref:`invert_match \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.invert_match\u003e`   is set to true and :ref:`treat_missing_header_as_empty \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty\u003e`   is set to false; The \"header2\" header is not present and the header   matcher rule for \"header2\" will be ignored so it will not match. * The header match rule specified header \"header3\" to a string regex match   ``^$`` which means an empty string, and   :ref:`treat_missing_header_as_empty \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty\u003e`   is set to true; The \"header3\" header is not present.   The match rule will treat the \"header3\" header as an empty header so it will match. * The header match rule specified header \"header4\" to a string regex match   ``^$`` which means an empty string, and   :ref:`treat_missing_header_as_empty \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty\u003e`   is set to false; The \"header4\" header is not present.   The match rule for \"header4\" will be ignored so it will not match."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Header Matcher",
            "description": ".. attention::   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1 ``Host``   header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead. .. attention::   To route on HTTP method, use the special HTTP/2 ``:method`` header. This works for both   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,   .. code-block:: json     {       \"name\": \":method\",       \"string_match\": {         \"exact\": \"POST\"       }     } .. attention::   In the absence of any header match specifier, match will default to :ref:`present_match   \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.present_match\u003e`. i.e, a request that has the :ref:`name   \u003cenvoy_v3_api_field_config.route.v3.HeaderMatcher.name\u003e` header will match, regardless of the header's   value.  [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.] [#next-free-field: 15]"
        },
        "envoy.type.matcher.v3.DoubleMatcher": {
            "properties": {
                "range": {
                    "$ref": "#/definitions/envoy.type.v3.DoubleRange",
                    "additionalProperties": true,
                    "description": "If specified, the input double value must be in the range specified here. Note: The range is using half-open interval semantics [start, end)."
                },
                "exact": {
                    "type": "number",
                    "description": "If specified, the input double value must be equal to the value specified here."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Number matcher]",
            "description": "[#protodoc-title: Number matcher]  Specifies the way to match a double value."
        },
        "envoy.type.matcher.v3.ListMatcher": {
            "properties": {
                "one_of": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.ValueMatcher",
                    "additionalProperties": true,
                    "description": "If specified, at least one of the values in the list must match the value specified."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "List Matcher",
            "description": "Specifies the way to match a list value."
        },
        "envoy.type.matcher.v3.MetadataMatcher": {
            "properties": {
                "filter": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The filter name to retrieve the Struct from the Metadata."
                },
                "path": {
                    "items": {
                        "$ref": "#/definitions/envoy.type.matcher.v3.MetadataMatcher.PathSegment"
                    },
                    "type": "array",
                    "description": "The path to retrieve the Value from the Struct."
                },
                "value": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.ValueMatcher",
                    "additionalProperties": true,
                    "description": "The MetadataMatcher is matched if the value retrieved by path is matched to this value."
                },
                "invert": {
                    "type": "boolean",
                    "description": "If true, the match result will be inverted."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "MetadataMatcher provides a general interface to check if a given value is matched in\n :ref:`Metadata \u003cenvoy_v3_api_msg_config.core.v3.Metadata\u003e`. It uses `filter` and `path` to retrieve the value\n from the Metadata and then check if it's matched to the specified value.\n\n For example, for the following Metadata:\n\n .. code-block:: yaml\n\n    filter_metadata:\n      envoy.filters.http.rbac:\n        fields:\n          a:\n            struct_value:\n              fields:\n                b:\n                  struct_value:\n                    fields:\n                      c:\n                        string_value: pro\n                t:\n                  list_value:\n                    values:\n                      - string_value: m\n                      - string_value: n\n\n The following MetadataMatcher is matched as the path [a, b, c] will retrieve a string value \"pro\"\n from the Metadata which is matched to the specified prefix match.\n\n .. code-block:: yaml\n\n    filter: envoy.filters.http.rbac\n    path:\n    - key: a\n    - key: b\n    - key: c\n    value:\n      string_match:\n        prefix: pr\n\n The following MetadataMatcher is matched as the code will match one of the string values in the\n list at the path [a, t].\n\n .. code-block:: yaml\n\n    filter: envoy.filters.http.rbac\n    path:\n    - key: a\n    - key: t\n    value:\n      list_match:\n        one_of:\n          string_match:\n            exact: m\n\n An example use of MetadataMatcher is specifying additional metadata in envoy.filters.http.rbac to\n enforce access control based on dynamic metadata in a request. See :ref:`Permission\n \u003cenvoy_v3_api_msg_config.rbac.v3.Permission\u003e` and :ref:`Principal\n \u003cenvoy_v3_api_msg_config.rbac.v3.Principal\u003e`.",
            "description": "[#protodoc-title: Metadata matcher]  MetadataMatcher provides a general interface to check if a given value is matched in :ref:`Metadata \u003cenvoy_v3_api_msg_config.core.v3.Metadata\u003e`. It uses `filter` and `path` to retrieve the value from the Metadata and then check if it's matched to the specified value. For example, for the following Metadata: .. code-block:: yaml    filter_metadata:      envoy.filters.http.rbac:        fields:          a:            struct_value:              fields:                b:                  struct_value:                    fields:                      c:                        string_value: pro                t:                  list_value:                    values:                      - string_value: m                      - string_value: n The following MetadataMatcher is matched as the path [a, b, c] will retrieve a string value \"pro\" from the Metadata which is matched to the specified prefix match. .. code-block:: yaml    filter: envoy.filters.http.rbac    path:    - key: a    - key: b    - key: c    value:      string_match:        prefix: pr The following MetadataMatcher is matched as the code will match one of the string values in the list at the path [a, t]. .. code-block:: yaml    filter: envoy.filters.http.rbac    path:    - key: a    - key: t    value:      list_match:        one_of:          string_match:            exact: m An example use of MetadataMatcher is specifying additional metadata in envoy.filters.http.rbac to enforce access control based on dynamic metadata in a request. See :ref:`Permission \u003cenvoy_v3_api_msg_config.rbac.v3.Permission\u003e` and :ref:`Principal \u003cenvoy_v3_api_msg_config.rbac.v3.Principal\u003e`.  [#next-major-version: MetadataMatcher should use StructMatcher]"
        },
        "envoy.type.matcher.v3.MetadataMatcher.PathSegment": {
            "properties": {
                "key": {
                    "minLength": 1,
                    "type": "string",
                    "description": "If specified, use the key to retrieve the value in a Struct."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Path Segment",
            "description": "Specifies the segment in a path to retrieve value from Metadata. Note: Currently it's not supported to retrieve a value from a list in Metadata. This means that if the segment key refers to a list, it has to be the last segment in a path."
        },
        "envoy.type.matcher.v3.OrMatcher": {
            "properties": {
                "value_matchers": {
                    "items": {
                        "$ref": "#/definitions/envoy.type.matcher.v3.ValueMatcher"
                    },
                    "type": "array"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Or Matcher",
            "description": "Specifies a list of alternatives for the match."
        },
        "envoy.type.matcher.v3.RegexMatcher": {
            "properties": {
                "google_re2": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.RegexMatcher.GoogleRE2",
                    "additionalProperties": true,
                    "description": "Google's RE2 regex engine."
                },
                "regex": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The regex match string. The string must be supported by the configured engine. The regex is matched against the full string, not as a partial match."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Regex matcher]",
            "description": "[#protodoc-title: Regex matcher]  A regex matcher designed for safety when used with untrusted input."
        },
        "envoy.type.matcher.v3.RegexMatcher.GoogleRE2": {
            "properties": {
                "max_program_size": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "This field controls the RE2 \"program size\" which is a rough estimate of how complex a compiled regex is to evaluate. A regex that has a program size greater than the configured value will fail to compile. In this case, the configured max program size can be increased or the regex can be simplified. If not specified, the default is 100. This field is deprecated; regexp validation should be performed on the management server instead of being done by each individual client. .. note::  Although this field is deprecated, the program size will still be checked against the  global ``re2.max_program_size.error_level`` runtime value."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Google RE 2",
            "description": "Google's `RE2 \u003chttps://github.com/google/re2\u003e`_ regex engine. The regex string must adhere to the documented `syntax \u003chttps://github.com/google/re2/wiki/Syntax\u003e`_. The engine is designed to complete execution in linear time as well as limit the amount of memory used. Envoy supports program size checking via runtime. The runtime keys ``re2.max_program_size.error_level`` and ``re2.max_program_size.warn_level`` can be set to integers as the maximum program size or complexity that a compiled regex can have before an exception is thrown or a warning is logged, respectively. ``re2.max_program_size.error_level`` defaults to 100, and ``re2.max_program_size.warn_level`` has no default if unset (will not check/log a warning). Envoy emits two stats for tracking the program size of regexes: the histogram ``re2.program_size``, which records the program size, and the counter ``re2.exceeded_warn_level``, which is incremented each time the program size exceeds the warn level threshold."
        },
        "envoy.type.matcher.v3.StringMatcher": {
            "properties": {
                "exact": {
                    "type": "string",
                    "description": "The input string must match exactly the string specified here. Examples: * ``abc`` only matches the value ``abc``."
                },
                "prefix": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead. Examples: * ``abc`` matches the value ``abc.xyz``"
                },
                "suffix": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead. Examples: * ``abc`` matches the value ``xyz.abc``"
                },
                "safe_regex": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.RegexMatcher",
                    "additionalProperties": true,
                    "description": "The input string must match the regular expression specified here."
                },
                "contains": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead. Examples: * ``abc`` matches the value ``xyz.abc.def``"
                },
                "custom": {
                    "$ref": "#/definitions/xds.core.v3.TypedExtensionConfig",
                    "additionalProperties": true,
                    "description": "Use an extension as the matcher type. [#extension-category: envoy.string_matcher]"
                },
                "ignore_case": {
                    "type": "boolean",
                    "description": "If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. This has no effect for the safe_regex match. For example, the matcher ``data`` will match both input string ``Data`` and ``data`` if set to true."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: String matcher]",
            "description": "[#protodoc-title: String matcher]  Specifies the way to match a string. [#next-free-field: 9]"
        },
        "envoy.type.matcher.v3.ValueMatcher": {
            "properties": {
                "null_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.ValueMatcher.NullMatch",
                    "additionalProperties": true,
                    "description": "If specified, a match occurs if and only if the target value is a NullValue."
                },
                "double_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.DoubleMatcher",
                    "additionalProperties": true,
                    "description": "If specified, a match occurs if and only if the target value is a double value and is matched to this field."
                },
                "string_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.StringMatcher",
                    "additionalProperties": true,
                    "description": "If specified, a match occurs if and only if the target value is a string value and is matched to this field."
                },
                "bool_match": {
                    "type": "boolean",
                    "description": "If specified, a match occurs if and only if the target value is a bool value and is equal to this field."
                },
                "present_match": {
                    "type": "boolean",
                    "description": "If specified, value match will be performed based on whether the path is referring to a valid primitive value in the metadata. If the path is referring to a non-primitive value, the result is always not matched."
                },
                "list_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.ListMatcher",
                    "additionalProperties": true,
                    "description": "If specified, a match occurs if and only if the target value is a list value and is matched to this field."
                },
                "or_match": {
                    "$ref": "#/definitions/envoy.type.matcher.v3.OrMatcher",
                    "additionalProperties": true,
                    "description": "If specified, a match occurs if and only if any of the alternatives in the match accept the value."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Value matcher]",
            "description": "[#protodoc-title: Value matcher]  Specifies the way to match a ProtobufWkt::Value. Primitive values and ListValue are supported. StructValue is not supported and is always not matched. [#next-free-field: 8]"
        },
        "envoy.type.matcher.v3.ValueMatcher.NullMatch": {
            "additionalProperties": true,
            "type": "object",
            "title": "Null Match",
            "description": "NullMatch is an empty message to specify a null value."
        },
        "envoy.type.v3.DoubleRange": {
            "properties": {
                "start": {
                    "type": "number",
                    "description": "start of the range (inclusive)"
                },
                "end": {
                    "type": "number",
                    "description": "end of the range (exclusive)"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Double Range",
            "description": "Specifies the double start and end of the range using half-open interval semantics [start, end)."
        },
        "envoy.type.v3.FractionalPercent": {
            "properties": {
                "numerator": {
                    "type": "integer",
                    "description": "Specifies the numerator. Defaults to 0."
                },
                "denominator": {
                    "enum": [
                        "HUNDRED",
                        0,
                        "TEN_THOUSAND",
                        1,
                        "MILLION",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "title": "Denominator Type",
                    "description": "Fraction percentages support several fixed denominator values."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Fractional Percent",
            "description": "A fractional percentage is used in cases in which for performance reasons performing floating point to integer conversions during randomness calculations is undesirable. The message includes both a numerator and denominator that together determine the final fractional value. * **Example**: 1/100 = 1%. * **Example**: 3/10000 = 0.03%."
        },
        "envoy.type.v3.Int64Range": {
            "properties": {
                "start": {
                    "type": "string",
                    "description": "start of the range (inclusive)"
                },
                "end": {
                    "type": "string",
                    "description": "end of the range (exclusive)"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "[#protodoc-title: Range]",
            "description": "[#protodoc-title: Range]  Specifies the int64 start and end of the range using half-open interval semantics [start, end)."
        },
        "xds.core.v3.TypedExtensionConfig": {
            "properties": {
                "name": {
                    "minLength": 1,
                    "type": "string",
                    "description": "The name of an extension. This is not used to select the extension, instead it serves the role of an opaque identifier."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "binary",
                            "binaryEncoding": "base64"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "The typed config for the extension. The type URL will be used to identify the extension. In the case that the type URL is *xds.type.v3.TypedStruct* (or, for historical reasons, *udpa.type.v1.TypedStruct*), the inner type URL of *TypedStruct* will be utilized. See the :ref:`extension configuration overview \u003cconfig_overview_extension_configuration\u003e` for further details."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "title": "Typed Extension Config",
            "description": "Message type for extension configuration."
        }
    }
}